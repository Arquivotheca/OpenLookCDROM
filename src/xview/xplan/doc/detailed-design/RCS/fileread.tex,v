head	1.9;
access;
symbols;
locks; strict;
comment	@% @;


1.9
date	92.10.28.10.17.02;	author lacey;	state Exp;
branches;
next	1.8;

1.8
date	92.10.28.10.12.14;	author gaubert;	state Exp;
branches;
next	1.7;

1.7
date	92.10.28.09.58.41;	author gaubert;	state Exp;
branches;
next	1.6;

1.6
date	92.10.28.07.54.10;	author lacey;	state Exp;
branches;
next	1.5;

1.5
date	92.10.28.07.10.38;	author lacey;	state Exp;
branches;
next	1.4;

1.4
date	92.10.28.06.06.43;	author lacey;	state Exp;
branches;
next	1.3;

1.3
date	92.10.28.05.21.36;	author gaubert;	state Exp;
branches;
next	1.2;

1.2
date	92.10.27.07.59.40;	author gaubert;	state Exp;
branches;
next	1.1;

1.1
date	92.10.25.18.25.19;	author lacey;	state Exp;
branches;
next	;


desc
@@


1.9
log
@*** empty log message ***
@
text
@%
% For each module and major submodule complete the following
% section and subsections
%
\subsection{File Read Module}
This section will contain information for the read file function.
% 
% Include a data flow diagram for this module
%
\subsubsection{Data Flow Diagram}


Figure~\ref{fr:dfd} on page~\pageref{fr:dfd} presents the
flow of data throughout this module.

\begin{figure}
\centering
\centerline{\psfig{figure=dataflo_readfile.ps,width=6in}}
\caption[Data Flow Diagram for File Read]{Data
flow diagram for file read.}
\label{fr:dfd}
\end{figure}

%
% Include a Structure Chart for this module
%
\subsubsection{Structure Chart}

To gain some insight into the calling structure of this module, refer
to Figure~\ref{fr:sc} on page~\pageref{fr:sc}.

\begin{figure}
\centering
\centerline{\psfig{figure=structure_readfile.ps,width=6in}}
\caption[Structure Chart for File Read]{Structure
chart for file read.}
\label{fr:sc}
\end{figure}

%
% Include a processing narrative for this module
%

\subsubsection{Narrative}
The tools Flex and Bison play an important part in reading a project
file The tool Flex will be used to generate code that scans a file and
looks for different tokens that are later assigned to the database
structure that is used in creating a task list. The Flex tool will
create tables that are used to look up the keywords that are used in
the file. The tool creates a file called lex.yy.c and will create a
function called yylex().  Bison, on the other hand, is used to create
a parser which in turn parses the file so that the database can get
the information that it needs to build the task list.  The set up of
the bison file correlates to the grammar that is used to read the
correct information from the file. Bison, like Flex, will use the
input file that parses the input. These files are called
parser.tab.c and parser.tab.h. The function that is created
from the Bison tool is called yyparse(). These functions use a file
pointer for the file to be read in called yyin. The function yyparse()
will call yylex(), the scanner. From here the scanner, yylex(), will
send the correct tokens to the parser from the input file.

The structure yylval will contain a token (taken from the scanner),
a string constant, and an integer (which will be used to insert into
the database). The string used in scanning the file will initially come
from the global variable created from the scanner called yytext. From
the scanner this variable will be placed into the stack yylval. Bison
will then use the information from the stack to update the database.
The file will be parsed in a bottom-up manner, so when each element of
a task is parsed, a local variable within the structure will be updated. Then
when all of the variables of that particular task have been parsed, a
call will be made to insert the task into the task list, thus by
creating a list and a node that is appended to the list. If the task
has subtasks, a list will be created under that main task, and the the
subtasks will follow under it in a list of itself. This process will
take place for all of the task in the file until the file has been
totally read in. The grammar used in Bison will know when all of the
tasks for the file have been read in and the control will be issued
back to the read-file routine, which will end this routine. The
control will then return back to the user interface.

The function yyparse is created from the tool Bison. The files created
by Bison include the parser.tab.c and the parser.tab.h. These
Bison files are related directly to the files created by the Flex
tool. The purpose of using Bison is to allow the read from the file to
the user interface to be easy and easily changeable, thus creating a
file that can be made up from another source rather than the program
itself. The functionality of yyparse will involve parsing the file
according to the keywords used in yylex(). The parse will use a bottom
up approach which is done by Bison automatically. From the parsing
stage, Bison allows for code to be executed whenever it reaches a
certain point in the parse tree or rule in the grammar. Upon reaching
a single task in the parse of the file, the parser will make calls to
the database functions to create-main-task-list, create-task-node,
create-task-list, create-task-info, and add-task-to-end. The function
create-main-task-list will create the main task list from the first
task within the file. Other lists (subtask) and main task nodes will
added on to this main task node.  The function create-task-node will
create a node so the information can be stored within a node which
will make it easier in maintaining the list that is currently being
worked on. The function create-task-list will be used for creating any
other list , subtask or main task, for the database. The function
create-task-info will store all of the information of that task in the
node specified. Lastly, the function add-task-to-end will add the task
to the end of the list.  This process of adding a single task, along
with all of its subtask lists, dependencies, and resources will
involve a simple stack for that particular task. Once a task is
created it will be stored into the stack, then all of its subtasks
will be stored on top of the main task. Then, when the main task is
done being read from the file, contents of the stack will come off and
will be placed into the database.

The function yylex will involve the scanning part of the read function.
The scanner will scan through the file and look for specific keywords
and identifiers that will be used later in the parsing section of the
read. When an identifier is found, the scanner will return a token to
the caller of the function, yyparse. When a specific identifier is
found in the file that is a STRING or an INT the scanner will return a
token code and will assign it to the correct variable in the yylval
structure. The yylval structure will contain the token code, an long
integer variable and a character pointer. 

%
% Include a PDL pseudocode description for this module
%
\subsubsection{PDL Description}
This PDL gives the general format of the Flex generated file.
\begin{verbatim}

PROCEDURE read-file EXTERNAL REFERENCE;
INTERFACE filename;
  BEGIN
     yyin = OPEN filename;
     CALL yyparse PROCEDURE;
     CLOSE yyin;
  END

TYPE stack-t IS STRUCTURED DEFINED 
  token-code IS LONG INTEGER;
  uint IS UNSIGNEDINT DEFINED;
  *str IS CHARACTER DEFINED;
END stack-t TYPE;

TYPE task-list-stack IS STRUCTURED DEFINED
  *taskl IS TASK LIST;
  *top IS TASK STACK;
END task-stack TYPE

TYPE dependent IS STRUCTURED DEFINED
  *depend IS RESOURCE LIST;
  *top IS DEPEND STACK;
END depend-stack TYPE;

TYPE rec-stack IS STRUCTURED DEFINED
  *resorc IS RESOURCE LIST;
  *top IS REC STACK;
END rec-stack TYPE


PROCEDURE yyparse, the files created from this file will call yylex()
INTERFACE All variables stored are global within the yyparse and yylex file
  name IS STRING OF LENGTH (MAXNAMELEN+1);
  desc IS STRING OF LENGTH (MAXDESCLEN+1);
  duration IS INTEGER;
  planned-start-date IS INTEGER;
  planned-end-date IS INTEGER;
  actual-start-date IS INTEGER;
  actual-end-date IS INTEGER;
  forecast-start-date IS INTEGER;
  forecast-end-date IS INTEGER;
  earliest-start-date IS INTEGER;
  earliest-end-date IS INTEGER;
  latest-start-date IS INTEGER;
  latest-end-date IS INTEGER;
  float-time IS INTEGER;
  milestone IS BOOLEAN;
  deliverable IS BOOLEAN;
  *resources IS TYPE RESOURCE LIST
  *parent IS TYPE TASK NODE
  *dependencies IS TYPE TASK LISK

COMMENTS
  This is the file format for the Bison file which gets converted into
  yyparse. The left hand side of the file consist of the grammar, and
  the right hand side consist of the code that will assign the correct
  string or integer to the correct variable
END COMMENTS



project 
        : tasklist                              
                { RETURN TO CALLER - read-file 
                }
        |                                       
                { RETURN TO CALLER - read-file 
                }
        ;

tasklist
        : taskblock '.'
                { 
                }
        ;

taskblock
        : taskblockhead taskblocktail
                {
                }
        ;

taskblockhead
        : BEG TASKS
                {
                  BEGIN <Check the stack for subtask or not>
                    IF TOP(task-list-stack) != NULL
                      CALL push PROCEDURE WITH subtask-node
                  ENDIF
                }
        ;

taskblocktail
        : tasksublist END TASKS 
                {
                  
                }
        ;

tasksublist
        : atask tasksublist                     
                {
                  BEGIN <Add the task to the list>
                    CALL pop PROCEDURE WITH task-list-stack, gets the
                                                     top of the stack
                    CALL add-task-to-end PROCEDURE WITH atask , TOP task-list-stack;
                  END
                }
        | atask                                 
                {  
                  BEGIN <Add the task to the list>
                    CALL add-task-to-end PROCEDURE WITH atask , TOP task-list-stack;
                  END
                }
        ;

atask 
        : TASK '=' '{' alist '}'                
                {

                  BEGIN <Push task on to the list>
                    CALL create-task-info PROCEDURE WITH name,
                           description, duration,
                           planned-start-date, actual-start-date,
                           actual-end-date,
                           forecast-end-date, forecaste-start-date,
                           earliest-start-date,
                           earliest-end-date, latest-start-date,
                           latest-end-date, float-time,
                           milestone, deliverable, resources,
                           subtasks, parent, dependencies,
                           dependents, number-of-dependents,x,y,length

                    CALL create-task-node PROCEDURE WITH task-node
                    CALL push PROCEDURE WITH task-node
                  END
                }
        ;

alist
        : assignment ';' alist                  
                { 
                }
        | assignment ';'                        
                { 
                }
        ;

assignment
        : stringassign                          
                { print-rule(10); 
                }
        | dependencylist                        
                { print-rule(11); 
                }
        | resourcelist                          
                { print-rule(12); 
                }
        | numberassign                          
                { print-rule(13); 
                }
        | booleanassign                         
                { print-rule(14); 
                }
        | taskblock                             
                {
                }
        ;

stringassign 
        : NAME '=' STRING                       
                {
                  BEGIN <Assign the value for name>
                    CALL strncpy PROCEDURE WITH name, $3.val.str, MAXNAMELEN;
                    name[MAXNAMELEN] = '\0';
                    CALL free PROCEDURE WITH $3.val.str;
                  END
                }
        | DESCRIPTION '=' STRING                
                { 
                  BEGIN <Assign the value for name>
                    CALL strncpy PROCEDURE WITH desc, $3.val.str, MAXDESCLEN;
                    desc[MAXNAMELEN] = '\0';
                    CALL free PROCEDURE WITH $3.val.str;
                  END
                }
        | PARENT '=' STRING                     
                {
                  BEGIN <Find the task in the list>
                    parent = find-task FUNCTION WITH task-list, $3.val.str
                    CALL free PROCEDURE WITH $3.val.str
                  END
                }
        ;

dependencylist
        : dependhead dependencytail             
                { 
                }
        ;

dependhead
        : BEG DEPENDENCIES                      
                { 
                }
        ;

dependencytail
        : dependency END DEPENDENCIES           
                {  
                }
        | dependency ',' dependencytail         
                {  
                }
        ;

dependency
        : STRING                                
                {
                  BEGIN <Insert into dependency table>
                    CALL create-task-node PROCEDURE WITH description-node
                    CALL add-task-to-end PROCEDURE WITH description-node
                  END
                }
        ;

resourcelist
        : resourcehead resourcetail             
                { 
                }
        ;

resourcehead
        : BEG RESOURCES                         
                {
                }
        ;

resourcetail
        : resource END RESOURCES                
                { 
                }
        | resource ',' resourcetail             
                { 
                }
        ;

resource
        : STRING                                
                {
                  BEGIN <Add resource to the resource list>
                    CALL create-resource-info PROCEDURE WITH resource;
                  END
                }
        ;

numberassign 
        : DURATION '=' UNSIGNED                 
                {
                  BEGIN <Update the duration with the current task information>
                    duration = $3.val.uint;
                  END
                }
        | FLOAT '=' UNSIGNED                    
                {
                  BEGIN <Update the duration with the current task information>
                    float-time = $3.val.uint;
                  END
                }
        | PLANNEDSTART '=' UNSIGNED             
                {
                  BEGIN <Update the duration with the current task information>
                    planned-start-date = $3.val.uint;
                  END
                } 
        | ACTUALSTART '=' UNSIGNED              
                {
                  BEGIN <Update the duration with the current task information>
                    actual-start-date = $3.val.uint;
                  END
                }
        | FORECASTSTART '=' UNSIGNED            
                {
                  BEGIN <Update the duration with the current task information>
                    forecast-start-date = $3.val.uint;
                  END
                }
        | EARLIESTSTART '=' UNSIGNED            
                {
                  BEGIN <Update the duration with the current task information>
                    earliest-start-date = $3.val.uint;
                  END
                }
        | LATESTSTART '=' UNSIGNED              
                {
                  BEGIN <Update the duration with the current task information>
                    latest-start-date = $3.val.uint;
                  END
                }
        | PLANNEDEND '=' UNSIGNED               
                {
                  BEGIN <Update the duration with the current task information>
                    planned-end-date = $3.val.uint;
                  END
                }
        | ACTUALEND '=' UNSIGNED                
                {
                  BEGIN <Update the duration with the current task information>
                    actual-end-date = $3.val.uint;
                  END
                }
        | FORECASTEND '=' UNSIGNED              
                {
                  BEGIN <Update the duration with the current task information>
                    forecast-end-date = $3.val.uint;
                  END
                }
        | EARLIESTEND '=' UNSIGNED              
                {
                  BEGIN <Update the duration with the current task information>
                    earliest-end-date = $3.val.uint;
                  END
                }
        | LATESTEND '=' UNSIGNED                
                {
                  BEGIN <Update the duration with the current task information>
                    latest-end-date = $3.val.uint;
                  END
                }
        ;

booleanassign 
        : MILESTONE '=' boolean                 
                {
                  BEGIN <Check to see if the task is a milestone>
                    milestone = $3.val.uint;
                  END
                }
        | DELIVERABLE '=' boolean               
                {




                  BEGIN <Check to see if the task is a deliverable or not>
                    deliverable = $3.val.uint;
                  END
                }
        ;

boolean
        : TRUE                                  
                {
                  BEGIN <This value will be parsed up to the next level if true>
                    $$.val.uint = true;
                  END
                }
        | FALSE                                 
                {
                  BEGIN <This value will be parsed up to the next level if false>
                        $$.val.uint = false;
                  END
                }
        ;
END PROCEDURE yyparse


PROCEDURE yylex;
INTERFACES yyparse and the input file;

TYPE string-entry IS STRUCTURED DEFINED
   *string IS CHARACTER POINTER;
    keywords IS STRING LENGTH(NUM-KW) ,DATA ITEMS = 
   "actual-end", "actual-start", "begin", "deliverable", "dependencies",
   "description", "duration", "earliest-end", "earliest-start",
   "end", "false", "float", "forecast-end", "forecast-start", "latest-end",
   "latest-start", "milestone", "name", "parent", "planned-end", 
   "planned-start", "resources", "task", "tasks", "true";
END TYPE

TYPE keytoks IS INTEGER LENGTH(NUM-KW), DATA ITEMS = 
   ACTUALEND, ACTUALSTART, BEG, DELIVERABLE, DEPENDENCIES,
   DESCRIPTION, DURATION, EARLIESTEND, EARLIESTSTART,
   END, FALSE, FLOAT, FORECASTEND, FORECASTSTART, LATESTEND,
   LATESTSTART, MILESTONE, NAME, PARENT, PLANNEDEND,
   PLANNEDSTART, RESOURCES, TASK, TASKS, TRUE;

TYPE iskeyword(char *) IS INTEGER OF FUNCTION ;
TYPE compare(struct string-entry *, struct string-entry *) IS INTEGER
                                             OF PROCEDURE;
TYPE*filename IS CHARACTER POINTER;

 tok IS STATIC;
 checkbuf IS STRING LENGTH(20) OF STATIC;
 *tmp IS CHARACTER POINTER OF STATIC;
 indx IS INTEGER OF STATIC;
 count IS INTEGER OF STATIC;

 lineno IS INTEGER = 1;


DECLARE FLEX SCANNING FUNCTIONS

DIGIT    [0-9]
LETTER   [a-zA-Z]


{DIGIT}+
   {
   BEGIN <Get the token for a digit>
     yylval.token-code = UNSIGNED;
     yylval.val.uint = STRTOL( yytext, NULL, 10 );
     RETURN UNSIGNED;
   END
   }

\"([^\"])*\"
   {
   BEGIN <Get the value for a string constant>
     yylval.token-code = STRING;
     yylval.val.str = make node using malloc
     CALL strcpy PROCEDURE WITH yylval.val.str, yytext, yyleng-2;
     yylval.val.str[yyleng-1] = '\0';
     RETURN STRING;
   END
   }

=                                       { RETURN '='; }
;                                       { RETURN ';'; }
,                                       { RETURN ','; }
\.                                      { RETURN '.'; }

{LETTER}({LETTER}|{DIGIT}|-)*
   {
   BEGIN <Check to see if the key word is in the table>
     IF  tok = iskeyword( yytext )
        THEN
        yylval.token-code = tok;
        RETURN tok;
     ENDIF
   END
   }

[ \t]                                   { }

\n                                      { }

.                                       { }

END PROCEDURE yylex

PROCEDURE iskeyword
INTERFACE *lexeme

   indx IS INTEGER;
   *tmp IS STRUCT STRING ENTRY;
   *retval IS STRUCT STRING ENTRY;
   
   tmp.string = lexeme
   
   retval = node for string entry;
   CALL bsearch PROCEDURE WITH &tmp, keywords, NUM-KW, 
             SIZEOF(struct string-entry), compare
   
   IF retval == NULL
     THEN
       return 0;
   ENDIF
   
   indx =  retval-keywords/SIZEOF struct string-entry;
   
   RETURN keytoks[indx];

END PROCEDURE iskeyword;

PROCEDURE compare
INTERFACE STRUCTURE string-entry *s1, STRUCTURE string-entry *s2

   RETURN STRCMP(s1->string, s2->string);
END PROCEDURE compare

\end{verbatim}
%
% Include a description of the interfaces for this module.
% This should include a list of data elements passed between
% modules.  The data elements described here should either be
% described in the next subsection or in the relevant owner's
% data dictionary
%
\subsubsection{Internal Interfaces}
The read module encorporates an interface between the user and file.
The name of the file will be sent to this function. This
function will only pass the name of the file to yyin, which is the
file pointer that Flex and Bison use.

The interfaces for the yyparse function include the call to yylex,
the call to the various database functions, the calls to the stack functions
within this source file, and the referencing of the parse stack, from
Bison. The function yyparse is called from the function read-file.
There are no parameters sent to the function yyparse. It will use 
the global variables within the scanner and parser files. 
%
% Include a data dictionary for this module.  The format should be:
%  
% Name: (this is the name of the data item)
% Aliases: (this is a list of aliases, if any)
% Where Used/ How Used: (this is a paired list of where the item is
%     used and how it is used
% Description: (this is a demarco description of the data item)
%
\subsubsection{Data Dictionary}
\begin{enumerate}
\item
\begin{description}
\item[Name:] filename
\item[Where/How Used:] This is usen when the user has specified to
                       read in a file. It is used in the read-file,
                       yyparse and yylex modules. It will be assigned
                       the file pointer yyin and used globaly.
\item[Description] filename = *string length 60*
\end{description}

\item
\begin{description}
\item[Name:] name
   \item[Where/How Used:] This variable is used within the Bison file and
                       will be assigned to a string when the rule of the
		       grammer has come .
   \item[Description:] name = *Any string of length 60*
\end{description}

\item
\begin{description}
\item[Name:]: desc
\item[Where/How Used:] This is the description of the task from the
                       file. It will be stored into the database within a task
\item[Description:] desc = *Any string of length 300*
\end{description}

\item
\begin{description}
\item[Name:] duration
\item[Where/How Used:] This is the duration from within a task in the file.
                       It will be intered into the database and will consist
                       of the amount of days that this task will take.
\item[Description:] duration = *integer*
\end{description}

\item
\begin{description}
\item[Name:] planned-start-date
\item[Where/How Used:] This is the date that the user has planned to
                       start the task. This variable is read from the
                       file and put into the database.
\item[Description:] planned-start-date = *Julian date*
\end{description}

\item
\begin{description}
\item[Name:] planned-end-date
\item[Where/How Used:] This is the date that the user has planned to
                       end the task. This variable is read from the file
                       and put into the database.
\item[Description:] planned-end-date = *Julian date*
\end{description}

\item
\begin{description}
\item[Name:] actual-start-date
\item[Where/How Used:] This is the date that the task actually got started.
      		       This variable is read from the file and put into
 		       the database.
\item[Description:] actual-start-date = *Julian date*
\end{description}

\item
\begin{description}
\item[Name:] acdtual-end-date
\item[Where/How Used:] This is the date that the task will actually end.
      		       This variable is read from the file and put into
 		       the database.
\item[Description:] acdtual-end-date = *Julian date*
\end{description}

\item
\begin{description}
\item[Name:] forecast-start-date
\item[Where/How Used:] This is the date that the user has specified that
                       they think that the task will start. This
      		       variable is read from the file and put into
 		       the database.
\item[Description:] forecast-start-date = *Julian date*
\end{description}

\item
\begin{description}
\item[Name:] forecast-end-date
\item[Where/How Used:] This is the date that the user expects that the
                       task will end. This variable is read from the file
                       and put into the database.
\item[Description:] forecast-end-date = *Julian date*
\end{description}

\item
\begin{description}
\item[Name:] earliest-end-date
\item[Where/How Used:] This is the date that the user expects is
                       the earliest date that the task will start.
      		       This variable is read from the file and put into
 		       the database.
\item[Description:] earliest-end-date = *Julian date*
\end{description}

\item
\begin{description}
\item[Name:] earliest-end-date
\item[Where/How Used:] This is the earliest date that the task will
                       end. This variable is read from the file and put into
 		       the database.
\item[Description:] earliest-end-date = *Julian date*
\end{description}


\item
\begin{description}
\item[Name:] latest-start-date
\item[Where/How Used:] This is the latest date that the task will start.
      		       This variable is read from the file and put into
 		       the database.

\item[Description:] latest-start-date = *Julian date*
\end{description}

\item
\begin{description}
\item[Name:] latest-end-date
\item[Where/How Used:] This id the latest date that the task has to
                       be done by. This variable is read from the file
                       and put into the database.
\item[Description:] latest-end-date = *Julian date*
\end{description}

\item
\begin{description}
\item[Name:] float-time
\item[Where/How Used:] This variable will be read infrom the file and stored
                       inti the database. It allows more time for the task,
                       if it is permissible.
\item[Description:] float-time = *integer*
\end{description}

\item
\begin{description}
\item[Name:] resources
\item[Where/How Used:] This is a list read in from a file that represents
                       the resources of a particular task. This list
                       will be stored into the database as a list.
\item[Description:] resources = $\left\{\mbox{string}\right\}^{n}$
\end{description}

\item
\begin{description}
\item[Name:] milestone
\item[Where/How Used:] This is a boolean function that will tell if the
                       task is a milestone or not. It will be stored
     		       into the database.
\item[Description:] milestone = [true \verb+|+ false]
\end{description}

\item
\begin{description}
\item[Name:] deliverable
\item[Where/How Used:] This is a boolean function that will tell if the
                       task is a deliverable or not. It will be stored
     		       into the database.
\item[Description:] deliverable = [true \verb+|+ false]
\end{description}

\item
\begin{description}
\item[Name:] parent
\item[Where/How Used:] This is a pointer to the parent node and will
                       be used in all subtask within a task.
\item[Description:] parent = *node to parent or main task*
\end{description}

\item
\begin{description}
\item[Name:] dependencies
\item[Where/How Used:] This is a list of the tasks that this task depends
                        on.
\item[Description:] dependencies = $\left\{\mbox{string}\right\}^{n}$
\end{description}


\item
\begin{description}
\item[Name:] yyin
\item[Where/How Used:] This is a pointer to a file and is used in
                          the scanner. It will be assigned a pointer
                          to a file that is used as the input
                          file of the program.
\item[Description:] yyin = *pointer to a file*
\end{description}

\item
\begin{description}
\item[Name:] stack-t
\item[Aliases:] yylval, val
\item[Where/How Used:] This is the stack used by the Flex and Bison files to
                          scan and parse the input file.
\item[Description:] stack-t = [token-code \verb+|+ uint \verb+|+ str];
                 token-code = *integer*;
                 uint = *unsigned int*;
                 str = *character pointer*;
\end{description}
\end{enumerate}


@


1.8
log
@*** empty log message ***
@
text
@d821 1
a821 1
\item[Description:] dependencies = $\left\{\mbox{string}\right}^{n}$
@


1.7
log
@*** empty log message ***
@
text
@d64 1
a64 1
the string constant and an integer (which will be used to insert into
d70 1
a70 1
a task is parsed, a local variable or struct will be updated. Then
d787 1
a787 1
\item[Description:] resources = $\left\{\mbox{string}\right}^{n}$
d796 1
a796 1
\item[Description:] milestone = [true \| false]
d805 1
a805 1
\item[Description:] deliverable = [true \| false]
d841 1
a841 1
\item[Description:] stack-t = [token-code \| uint \| str];
@


1.6
log
@*** empty log message ***
@
text
@d130 2
a131 2
PROCEDURE read-file EXTERNAL REFERENCE
INTERFACE filename
d192 7
a198 7
	: tasklist				
		{ RETURN TO CALLER - read-file 
		}
	|					
		{ RETURN TO CALLER - read-file 
		}
	;
d201 3
a203 3
	: taskblock '.'
		{ 
		}
d213 1
a213 1
	: BEG TASKS
d223 2
a224 2
        : tasksublist END TASKS	
		{
d226 2
a227 2
		}
	;
d230 2
a231 2
	: atask tasksublist			
		{
d237 3
a239 3
		}
	| atask					
		{  
d243 2
a244 2
		}
	;
d247 2
a248 2
	: TASK '=' '{' alist '}'		
		{
d266 2
a267 2
		}
	;
d270 7
a276 7
	: assignment ';' alist			
		{ 
		}
	| assignment ';'			
		{ 
		}
	;
d279 19
a297 19
	: stringassign				
		{ print-rule(10); 
		}
	| dependencylist			
		{ print-rule(11); 
		}
	| resourcelist				
		{ print-rule(12); 
		}
	| numberassign				
		{ print-rule(13); 
		}
	| booleanassign				
		{ print-rule(14); 
		}
	| taskblock				
		{
		}
	;
d300 2
a301 2
	: NAME '=' STRING			
		{
d303 3
a305 3
		    CALL strncpy PROCEDURE WITH name, $3.val.str, MAXNAMELEN;
	            name[MAXNAMELEN] = '\0';
	            CALL free PROCEDURE WITH $3.val.str;
d307 3
a309 3
		}
	| DESCRIPTION '=' STRING		
		{ 
d311 3
a313 3
		    CALL strncpy PROCEDURE WITH desc, $3.val.str, MAXDESCLEN;
	            desc[MAXNAMELEN] = '\0';
	            CALL free PROCEDURE WITH $3.val.str;
d315 3
a317 3
		}
	| PARENT '=' STRING			
		{
d319 2
a320 2
	            parent = find-task FUNCTION WITH task-list, $3.val.str
		    CALL free PROCEDURE WITH $3.val.str
d322 2
a323 2
		}
	;
d326 4
a329 4
	: dependhead dependencytail		
		{ 
		}
	;
d332 4
a335 4
	: BEG DEPENDENCIES			
		{ 
		}
	;
d338 7
a344 7
	: dependency END DEPENDENCIES 		
		{  
		}
	| dependency ',' dependencytail		
		{  
		}
	;
d347 2
a348 2
	: STRING				
		{
d353 2
a354 2
		}
	;
d357 4
a360 4
	: resourcehead resourcetail		
		{ 
		}
	;
d363 4
a366 4
	: BEG RESOURCES				
		{
		}
	;
d369 7
a375 7
	: resource END RESOURCES 		
		{ 
		}
	| resource ',' resourcetail		
		{ 
		}
	;
d378 2
a379 2
	: STRING				
		{
d383 2
a384 2
 		}
	;
d387 2
a388 2
	: DURATION '=' UNSIGNED			
		{
d390 1
a390 1
	            duration = $3.val.uint;
d392 3
a394 3
		}
	| FLOAT '=' UNSIGNED			
		{
d396 1
a396 1
	            float-time = $3.val.uint;
d398 3
a400 3
		}
	| PLANNEDSTART '=' UNSIGNED		
		{
d402 1
a402 1
		    planned-start-date = $3.val.uint;
d404 3
a406 3
		} 
	| ACTUALSTART '=' UNSIGNED		
		{
d408 1
a408 1
		    actual-start-date = $3.val.uint;
d410 3
a412 3
		}
	| FORECASTSTART '=' UNSIGNED		
		{
d414 1
a414 1
		    forecast-start-date = $3.val.uint;
d416 3
a418 3
		}
	| EARLIESTSTART '=' UNSIGNED		
		{
d420 1
a420 1
		    earliest-start-date = $3.val.uint;
d422 3
a424 3
		}
	| LATESTSTART '=' UNSIGNED		
		{
d426 1
a426 1
		    latest-start-date = $3.val.uint;
d428 3
a430 3
		}
	| PLANNEDEND '=' UNSIGNED		
		{
d432 1
a432 1
		    planned-end-date = $3.val.uint;
d434 26
a459 26
		}
	| ACTUALEND '=' UNSIGNED		
		{
		  BEGIN <Update the duration with the current task information>
		    actual-end-date = $3.val.uint;
     		  END
		}
	| FORECASTEND '=' UNSIGNED		
		{
		  BEGIN <Update the duration with the current task information>
	            forecast-end-date = $3.val.uint;
		  END
		}
	| EARLIESTEND '=' UNSIGNED		
		{
		  BEGIN <Update the duration with the current task information>
		    earliest-end-date = $3.val.uint;
 		  END
		}
	| LATESTEND '=' UNSIGNED        	
		{
		  BEGIN <Update the duration with the current task information>
		    latest-end-date = $3.val.uint;
		  END
		}
	;
d462 2
a463 2
	: MILESTONE '=' boolean			
		{
d465 5
a469 5
	            milestone = $3.val.uint;
		  END
		}
	| DELIVERABLE '=' boolean		
		{
d474 5
a478 5
		  BEGIN <Check to see if the task is a deliverable or not>
		    deliverable = $3.val.uint;
		  END
		}
	;
d481 4
a484 4
	: TRUE                                  
		{
		  BEGIN <This value will be parsed up to the next level if true>
	            $$.val.uint = true;
d486 3
a488 3
		}
	| FALSE					
		{
d490 1
a490 1
			$$.val.uint = false;
d492 2
a493 2
		}
	;
d497 2
a498 2
PROCEDURE yylex
INTERFACES yyparse and the input file
d510 1
a510 1
 keytoks IS INTEGER LENGTH(NUM-KW), DATA ITEMS = 
d517 4
a520 3
 iskeyword(char *) IS INTEGER OF FUNCTION ;
 compare(struct string-entry *, struct string-entry *) IS INTEGER OF PROCEDURE;
 *filename IS CHARACTER POINTER;
d557 4
a560 4
=					{ RETURN '='; }
;					{ RETURN ';'; }
,					{ RETURN ','; }
\.					{ RETURN '.'; }
d573 1
a573 1
[ \t]					{ }
d575 1
a575 1
\n					{ }
d577 1
a577 1
.				        { }
d592 1
a592 1
	     SIZEOF(struct string-entry), compare
d620 2
a621 2
The read module will have an interface between from the user
interface. The name of the file will be sent to this function. This
d625 2
a626 2
The interfaces for the yyparse function include the call to yylex and
the call to the various database functions, the calls to the stack
d628 3
a630 3
Bison, stack-t. The function yyparse is called from the function read-file.
There is no parameters sent to the function yyparse. It will use the
the variables globaly within the scanner and parser files. 
d649 1
a649 1
\item[Description] filename = string for task file name
d675 1
a675 1
\item[Description:] duration = [1-32000]
d778 1
a778 1
\item[Description:] float-time = [1-32000]
d787 1
a787 1
\item[Description:] resources = [string+]
d796 1
a796 1
\item[Description:] milestone = [true | false]
d805 1
a805 1
\item[Description:] deliverable = [true | false]
d821 1
a821 1
\item[Description:] dependencies = [string+]
d841 1
a841 1
\item[Description:] stack-t = [token-code | uint | str];
d847 2
@


1.5
log
@*** empty log message ***
@
text
@d12 12
d28 11
@


1.4
log
@*** empty log message ***
@
text
@d22 1
a22 1
The tools Flex and Bison play an inportant part in reading a project
d31 1
a31 1
the bison file coorolates to the grammar that is used to read the
d42 1
a42 1
the database). The string used in scanning the file will initialy come
d82 2
a83 2
to the end of the list.  This process of adding a single task, allong
with all of its subtask lists, dependancies, and resources will
d138 1
a138 1
INTERFACE All variablex stored are global within the yyparse and yylex file
d753 1
a753 1
                       if it is permissiable.
d769 1
a769 1
\item[Where/How Used:] This ia a boolean function that will tell if the
d778 1
a778 1
\item[Where/How Used:] This ia a boolean function that will tell if the
d794 1
a794 1
\item[Name:] dependancies
d797 1
a797 1
\item[Description:] dependancies = [string+]
@


1.3
log
@*** empty log message ***
@
text
@d107 1
a107 1
PROCEDURE read_file EXTERNAL REFERENCE
d115 2
a116 2
TYPE stack_t IS STRUCTURED DEFINED 
  token_code IS LONG INTEGER;
d119 1
a119 1
END stack_t TYPE;
d121 1
a121 1
TYPE task_list_stack IS STRUCTURED DEFINED
d124 1
a124 1
END task_stack TYPE
d129 1
a129 1
END depend_stack TYPE;
d131 1
a131 1
TYPE rec_stack IS STRUCTURED DEFINED
d134 1
a134 1
END rec_stack TYPE
d142 11
a152 11
  planned_start_date IS INTEGER;
  planned_end_date IS INTEGER;
  actual_start_date IS INTEGER;
  actual_end_date IS INTEGER;
  forecast_start_date IS INTEGER;
  forecast_end_date IS INTEGER;
  earliest_start_date IS INTEGER;
  earliest_end_date IS INTEGER;
  latest_start_date IS INTEGER;
  latest_end_date IS INTEGER;
  float_time IS INTEGER;
d170 1
a170 1
		{ RETURN TO CALLER - read_file 
d173 1
a173 1
		{ RETURN TO CALLER - read_file 
d193 2
a194 2
                    IF TOP(task_list_stack) != NULL
                      CALL push PROCEDURE WITH subtask_node
d210 1
a210 1
                    CALL pop PROCEDURE WITH task_list_stack, gets the
d212 1
a212 1
                    CALL add_task_to_end PROCEDURE WITH atask , TOP task_list_stack;
d218 1
a218 1
                    CALL add_task_to_end PROCEDURE WITH atask , TOP task_list_stack;
d228 11
a238 6
                    CALL create_task_info PROCEDURE WITH name, description, duration,
                           planned_start_date, actual_start_date, actual_end_date,
                           forecast_end_date, forecaste_start_date, earliest_start_date,
                           earliest_end_date, latest_start_date, latest_end_date, float_time,
                           milestone, deliverable, resources, subtasks, parent, dependencies,
                           dependents, number_of_dependents,x,y,length
d240 2
a241 2
                    CALL create_task_node PROCEDURE WITH task_node
                    CALL push PROCEDURE WITH task_node
d257 1
a257 1
		{ print_rule(10); 
d260 1
a260 1
		{ print_rule(11); 
d263 1
a263 1
		{ print_rule(12); 
d266 1
a266 1
		{ print_rule(13); 
d269 1
a269 1
		{ print_rule(14); 
d296 1
a296 1
	            parent = find_task FUNCTION WITH task_list, $3.val.str
d327 2
a328 2
                    CALL create_task_node PROCEDURE WITH description_node
                    CALL add_task_to_end PROCEDURE WITH description_node
d358 1
a358 1
                    CALL create_resource_info PROCEDURE WITH resource;
d373 1
a373 1
	            float_time = $3.val.uint;
d379 1
a379 1
		    planned_start_date = $3.val.uint;
d385 1
a385 1
		    actual_start_date = $3.val.uint;
d391 1
a391 1
		    forecast_start_date = $3.val.uint;
d397 1
a397 1
		    earliest_start_date = $3.val.uint;
d403 1
a403 1
		    latest_start_date = $3.val.uint;
d409 1
a409 1
		    planned_end_date = $3.val.uint;
d415 1
a415 1
		    actual_end_date = $3.val.uint;
d421 1
a421 1
	            forecast_end_date = $3.val.uint;
d427 1
a427 1
		    earliest_end_date = $3.val.uint;
d433 1
a433 1
		    latest_end_date = $3.val.uint;
d477 1
a477 1
TYPE string_entry IS STRUCTURED DEFINED
d479 6
a484 6
    keywords IS STRING LENGTH(NUM_KW) ,DATA ITEMS = 
   "actual_end", "actual_start", "begin", "deliverable", "dependencies",
   "description", "duration", "earliest_end", "earliest_start",
   "end", "false", "float", "forecast_end", "forecast_start", "latest_end",
   "latest_start", "milestone", "name", "parent", "planned_end", 
   "planned_start", "resources", "task", "tasks", "true";
d487 1
a487 1
 keytoks IS INTEGER LENGTH(NUM_KW), DATA ITEMS = 
d495 1
a495 1
 compare(struct string_entry *, struct string_entry *) IS INTEGER OF PROCEDURE;
d516 1
a516 1
     yylval.token_code = UNSIGNED;
d525 1
a525 1
     yylval.token_code = STRING;
d538 1
a538 1
{LETTER}({LETTER}|{DIGIT}|_)*
d543 1
a543 1
        yylval.token_code = tok;
d567 2
a568 2
   CALL bsearch PROCEDURE WITH &tmp, keywords, NUM_KW, 
	     SIZEOF(struct string_entry), compare
d575 1
a575 1
   indx =  retval-keywords/SIZEOF struct string_entry;
d582 1
a582 1
INTERFACE STRUCTURE string_entry *s1, STRUCTURE string_entry *s2
d622 1
a622 1
                       read in a file. It is used in the read_file,
d625 2
a626 1
\item{description} filename = string for task file name
a630 1
   Aliases: none
d656 1
a656 1
\item[Name:] planned_start_date
d660 1
a660 1
\item[Description:] planned_start_date = *Julian date*
d665 1
a665 1
\item[Name:] planned_end_date
d669 1
a669 1
\item[Description:] planned_end_date = *Julian date*
d674 1
a674 1
\item[Name:] actual_start_date
d678 1
a678 1
\item[Description:] actual_start_date = *Julian date*
d683 1
a683 1
\item[Name:] acdtual_end_date
d687 1
a687 1
\item[Description:] acdtual_end_date = *Julian date*
d692 1
a692 1
\item[Name:] forecast_start_date
d697 1
a697 1
\item[Description:] forecast_start_date = *Julian date*
d702 1
a702 1
\item[Name:] forecast_end_date
d706 1
a706 1
\item[Description:] forecast_end_date = *Julian date*
d711 1
a711 1
\item[Name:] earliest_end_date
d716 1
a716 1
\item[Description:] earliest_end_date = *Julian date*
d721 1
a721 1
\item[Name:] earliest_end_date
d725 1
a725 1
\item[Description:] earliest_end_date = *Julian date*
d731 1
a731 1
\item[Name:] latest_start_date
d736 1
a736 1
\item[Description:] latest_start_date = *Julian date*
d741 1
a741 1
\item[Name:] latest_end_date
d745 1
a745 1
\item[Description:] latest_end_date = *Julian date*
d750 1
a750 1
\item[Name:] float_time
d754 1
a754 1
\item[Description:] float_time = [1-32000]
d813 2
a814 2
\item[Name:] stack_t
\item[Aliases:] YYSTYPE, yylval, val
d817 2
a818 2
\item[Description:] stack_t = [token_code | uint | str];
                 token_code = *integer*;
a822 11











@


1.2
log
@*** empty log message ***
@
text
@a0 5
%** Module for the main read routines *****************************************
% 
%      
% 
%*****************************************************************************
d6 1
a6 1
This section will contain information for the read_file function.
d20 1
d22 13
a34 12
The tools Flex and Bison play a big part in reading the file of tasks
for the program. The tool Flex will scan the file and look for
different tokens, that later are assigned to the database structure
that creates the task list. The Flex tool will create tables that are
used to look up the keywords that are used in the file. The tool
creates a file called lex.yy.c and will create a function called yylex().
Bison, on the other hand, is used to parse the file so that the
database can get the information that it needs to build the task list.
The set up of the bison file coorolates to the grammar that is used to
read the correct information from the file. Bison, like Flex, will
use the input file that parses the input. These files are called
<filename>.tab.c and <Filename>.tab.h. The function that is created
d38 1
a38 20
send the correct tokens to the parser from the input file. The
scanner, after it has recieved a valid token, will put the token
content on to a stack called yylval. The structure yylval will contain
a token (taken from the scanner), the string constant and an integer
(which will be used to insert into the database). The string used in
scanning the file will initialy come from the global variable created from the
scanner called yytext. From the scanner this variable will be placed
into the stack yylval. Bison will then use the information from the
stack to update the database. The file will be parsed in a bottom-up
manner, so when each element of a task is parsed, a local variable
or struct will be updated. Then when all of the variables of that
particular task have been parsed, a call will be made to insert the
task into the task list, thus by creating a list and a node that is
appended to the list. If the task has subtasks, a list will be created
under that main task, and the the subtasks will follow under it in a
list of itself. This process will take place for all of the task in
the file until the file has been totally read in. The grammar used in
Bison will know when all of the tasks for the file have been read in
and the control will be issued back to the read_file routine, which
will end this routine. The control will then return back to the user interface.
d40 60
d104 1
d106 1
d110 3
a112 2
     yyin = OPEN filename
     CALL yyparse PROCEDURE
a113 32
\end{verbatim}
%
% Include a description of the interfaces for this module.
% This should include a list of data elements passed between
% modules.  The data elements described here should either be
% described in the next subsection or in the relevant owner's
% data dictionary
%
\subsubsection{Internal Interfaces}
The read module will have an interface between from the user
interface. The name of the file will be sent to this function. This
function will only pass the name of the file to yyin, which is the
file pointer that Flex and Bison use.
%
% Include a data dictionary for this module.  The format should be:
%  
% Name: (this is the name of the data item)
% Aliases: (this is a list of aliases, if any)
% Where Used/ How Used: (this is a paired list of where the item is
%     used and how it is used
% Description: (this is a demarco description of the data item)
%
\subsubsection{Data Dictionary}
\begin{verbatim}
 Name: filename
 Aliases: The name of the file that the user has specified
 Where Used/ How Used: This is usen when the user has specified to
                       read in a file. It is used in the read_file,
                       yyparse and yylex modules. It will be assigned
                       the file pointer yyin and used globaly.
 Discription: filename = string for task file name 
\end{verbatim}
a114 23
\subsection{yyparse()}

% 
% Include a data flow diagram for this module
%
\subsubsection{Data Flow Diagram}
Please refer to the diagram from the File Read Module.
%
% Include a Structure Chart for this module
%
\subsubsection{Structure Chart}
Please refer to the Structure chart from the File Read Module.
%
% Include a processing narrative for this module
%
\subsubsection{Narrative}

%
% Include a PDL pseudocode description for this module
%
\subsubsection{PDL Description}
\begin{verbatim}

d121 1
a121 1
TYPE task_stack IS STRUCTURED DEFINED
d126 1
a126 1
TYPE depend_stack IS STRUCTURED DEFINED
d192 4
d202 1
a202 18
                 BEGIN <Store data in database>
                   CALL create_task_node PROCEDURE WITH all null parameters;
                   CALL create_task_list PROCEDURE WITH task node;
                   POP(taskl);
                   DO WHILE next item in stack is not bottom of stack
                     IF first time in loop
                       THEN
                       CALL create_task_node PROCEDURE WITH all null parameters
                       CALL create_task_list PROCEDURE WITH task node
                            for subtasks and taskl;
                     ELSE
                       CALL create_task_list PROCEDURE WITH pointer
                            from stack and taskl;
                       CALL add_task_to_end PROCEDURE WITH pointer;
                     ENDIF
                     POP(taskl);
                   ENDDO
                     
d208 6
a213 1
		{ print_rule(5); 
d216 4
a219 1
		{ print_rule(6); 
d225 13
a237 1
		{ print_rule(7); 
d243 1
a243 1
		{ print_rule(8); 
d246 1
a246 1
		{ print_rule(9); 
d267 1
a267 1
		{ print_rule(15); 
d273 6
a278 4
		{ print_rule(16);
			strncpy(name, $3.val.str, MAXNAMELEN);
			name[MAXNAMELEN] = '\0';
			free($3.val.str);
d281 6
a286 4
		{ print_rule(17);
			strncpy(desc, $3.val.str, MAXDESCLEN);
			desc[MAXDESCLEN] = '\0';
			free($3.val.str);
d289 5
a293 3
		{ print_rule(18);
/*			parent = find_task(task_list, $3.val.str);*/
			free($3.val.str);
d299 1
a299 1
		{ print_rule(19); 
d305 1
a305 1
		{ print_rule(20); 
d311 1
a311 1
		{ print_rule(21); 
d314 1
a314 1
		{ print_rule(22); 
d320 5
a324 1
		{ print_rule(23); 
d330 1
a330 1
		{ print_rule(24); 
d336 1
a336 1
		{ print_rule(25); 
d342 1
a342 1
		{ print_rule(26); 
d345 1
a345 1
		{ print_rule(27); 
d351 5
a355 2
		{ print_rule(28); 
		}
d360 4
a363 2
		{ print_rule(29);
			duration = $3.val.uint;
d366 4
a369 2
		{ print_rule(30);
			float_time = $3.val.uint;
d372 5
a376 3
		{ print_rule(31);
			planned_start_date = $3.val.uint;
		}
d378 4
a381 2
		{ print_rule(32);
			actual_start_date = $3.val.uint;
d384 4
a387 2
		{ print_rule(33); 
			forecast_start_date = $3.val.uint;
d390 4
a393 2
		{ print_rule(34);
			earliest_start_date = $3.val.uint;
d396 4
a399 2
		{ print_rule(35);
			latest_start_date = $3.val.uint;
d402 4
a405 2
		{ print_rule(36);
			planned_end_date = $3.val.uint;
d408 4
a411 2
		{ print_rule(37);
			actual_end_date = $3.val.uint;
d414 4
a417 2
		{ print_rule(38);
			forecast_end_date = $3.val.uint;
d420 4
a423 2
		{ print_rule(39);
			earliest_end_date = $3.val.uint;
d426 4
a429 2
		{ print_rule(40);
			latest_end_date = $3.val.uint;
d435 4
a438 2
		{ print_rule(41);
			milestone = $3.val.uint;
d441 8
a448 2
		{ print_rule(42);
			deliverable = $3.val.uint;
d454 4
a457 2
		{ print_rule(43);
			$$.val.uint = true;
d460 2
a461 1
		{ print_rule(44);
d463 1
d466 1
a466 8
%%
int yyerror( char *s)
{
}
print_rule(int num)
{
   printf("reduction %d\n", num);
}
a467 9
\end{verbatim}
%
% Include a description of the interfaces for this module.
% This should include a list of data elements passed between
% modules.  The data elements described here should either be
% described in the next subsection or in the relevant owner's
% data dictionary
%
\subsubsection{Internal Interfaces}
d469 2
a470 22
%
% Include a data dictionary for this module.  The format should be:
%  
% Name: (this is the name of the data item)
% Aliases: (this is a list of aliases, if any)
% Where Used/ How Used: (this is a paired list of where the item is
%     used and how it is used
% Description: (this is a demarco description of the data item)
%
\subsubsection{Data Dictionary}
%*****************************************************************************
% Remember, you need to be as detailed as possible in the description
% of the modules in order to facilitate the coding task. Do not leave any 
% room for ambiguity.
%*****************************************************************************
%
% For each module and major submodule complete the following
% section and subsections
%
\subsection{yylex()}
\begin{verbatim}
%{
d472 3
a474 16
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <math.h>
#include <search.h>
#include <string.h>
#include <limits.h>
#include <float.h>
#include "semantic_stack.h"
#include "parser.tab.h"

#define NUM_KW 25

struct string_entry {
   char *string;
} keywords[NUM_KW] = {
d479 2
a480 2
   "planned_start", "resources", "task", "tasks", "true"
};
d482 1
a482 2
/* tokens for our keywords */
int keytoks[NUM_KW] = {
d487 1
a487 2
   PLANNEDSTART, RESOURCES, TASK, TASKS, TRUE
};
d489 3
a491 3
/* prototypes */
int iskeyword(char *);
int compare(struct string_entry *, struct string_entry *);
d493 5
a497 1
extern char *filename;
d499 1
a499 5
static tok;
static char checkbuf[20];
static char *tmp;
static indx;
static count;
a500 5
/*strhashtable *scontbl_ptr;
strhashtable *idtbl_ptr;
realhashtable *rcontbl_ptr;
*/
int lineno=1;
d502 1
a502 1
%}
a506 1
%%
d508 8
a515 4
{DIGIT}+				{ /* decimal integer constant */
   /* call strtol to convert */
   yylval.token_code = UNSIGNED;
   yylval.val.uint = strtol( yytext, NULL, 10 );
d517 10
a526 2
   return UNSIGNED;
}
d528 4
a531 7
\"([^\"])*\"	{ /* string constant */
   yylval.token_code = STRING;
   yylval.val.str = (char *) malloc(yyleng-1);
   strncpy(yylval.val.str, yytext, yyleng-2);
   yylval.val.str[yyleng-1] = '\0';
   return STRING;
}
d533 9
a541 10
=					{ return '='; }
;					{ return ';'; }
,					{ return ','; }
\.					{ return '.'; }

{LETTER}({LETTER}|{DIGIT}|_)*		{ 
   if ( tok = iskeyword( yytext ) ) {
      yylval.token_code = tok;
      return tok;
   } else {
a542 1
}
d544 1
a544 1
[ \t]					{ /* whitespace */ }
d546 1
a546 1
\n					{ /* newline */ ++lineno; }
d548 1
a548 4
.					{ 
/* Any character that we do not expect */
	return yytext[0];
}
d550 1
a550 1
%%
d552 6
a557 10
/*
  Perform a binary search on the list of keywords to see if this
  word is present.  If it is, return the token value for it.  If not,
  just return 0, to tell the calling routine that this is an identifier.
  */
  iskeyword( char *lexeme )
{
   int indx;
   struct string_entry tmp;
   struct string_entry *retval;
d559 1
a559 1
   tmp.string = lexeme;
d561 3
a563 3
   retval = (struct string_entry *)
     bsearch((char *)&tmp, (char *)keywords, NUM_KW, 
	     sizeof(struct string_entry), compare);
d565 4
a568 1
   if ( retval == NULL ) return 0;
d570 1
a570 2
   indx =  ((int) retval- (int) keywords)/(sizeof(struct
						  string_entry));
d572 1
a572 2
   return keytoks[indx];
}
d574 1
a574 4
int compare(struct string_entry *s1, struct string_entry *s2)
{
   return strcmp(s1->string, s2->string);
}
d576 2
a577 1
\end{verbatim}
d579 2
d582 1
a582 2
% 
% Include a data flow diagram for this module
a583 18
\subsubsection{Data Flow Diagram}

%
% Include a Structure Chart for this module
%
\subsubsection{Structure Chart}

%
% Include a processing narrative for this module
%
\subsubsection{Narrative}

%
% Include a PDL pseudocode description for this module
%
\subsubsection{PDL Description}

%
d591 4
d596 6
d612 9
a620 10
%*****************************************************************************
% Remember, you need to be as detailed as possible in the description
% of the modules in order to facilitate the coding task. Do not leave any 
% room for ambiguity.
%*****************************************************************************
%
% For each module and major submodule complete the following
% section and subsections
%
\subsection{File Read Module}
d622 9
a630 4
% 
% Include a data flow diagram for this module
%
\subsubsection{Data Flow Diagram}
d632 7
a638 4
%
% Include a Structure Chart for this module
%
\subsubsection{Structure Chart}
d640 8
a647 4
%
% Include a processing narrative for this module
%
\subsubsection{Narrative}
d649 8
a656 4
%
% Include a PDL pseudocode description for this module
%
\subsubsection{PDL Description}
d658 8
a665 8
%
% Include a description of the interfaces for this module.
% This should include a list of data elements passed between
% modules.  The data elements described here should either be
% described in the next subsection or in the relevant owner's
% data dictionary
%
\subsubsection{Internal Interfaces}
d667 8
a674 20
%
% Include a data dictionary for this module.  The format should be:
%  
% Name: (this is the name of the data item)
% Aliases: (this is a list of aliases, if any)
% Where Used/ How Used: (this is a paired list of where the item is
%     used and how it is used
% Description: (this is a demarco description of the data item)
%
\subsubsection{Data Dictionary}
%*****************************************************************************
% Remember, you need to be as detailed as possible in the description
% of the modules in order to facilitate the coding task. Do not leave any 
% room for ambiguity.
%*****************************************************************************
%
% For each module and major submodule complete the following
% section and subsections
%
\subsection{File Read Module}
d676 8
a683 4
% 
% Include a data flow diagram for this module
%
\subsubsection{Data Flow Diagram}
d685 9
a693 4
%
% Include a Structure Chart for this module
%
\subsubsection{Structure Chart}
d695 8
a702 4
%
% Include a processing narrative for this module
%
\subsubsection{Narrative}
d704 9
a712 4
%
% Include a PDL pseudocode description for this module
%
\subsubsection{PDL Description}
d714 8
a721 8
%
% Include a description of the interfaces for this module.
% This should include a list of data elements passed between
% modules.  The data elements described here should either be
% described in the next subsection or in the relevant owner's
% data dictionary
%
\subsubsection{Internal Interfaces}
a722 20
%
% Include a data dictionary for this module.  The format should be:
%  
% Name: (this is the name of the data item)
% Aliases: (this is a list of aliases, if any)
% Where Used/ How Used: (this is a paired list of where the item is
%     used and how it is used
% Description: (this is a demarco description of the data item)
%
\subsubsection{Data Dictionary}
%*****************************************************************************
% Remember, you need to be as detailed as possible in the description
% of the modules in order to facilitate the coding task. Do not leave any 
% room for ambiguity.
%*****************************************************************************
%
% For each module and major submodule complete the following
% section and subsections
%
\subsection{File Read Module}
d724 6
a729 4
% 
% Include a data flow diagram for this module
%
\subsubsection{Data Flow Diagram}
d731 2
a732 4
%
% Include a Structure Chart for this module
%
\subsubsection{Structure Chart}
d734 8
a741 4
%
% Include a processing narrative for this module
%
\subsubsection{Narrative}
d743 8
a750 4
%
% Include a PDL pseudocode description for this module
%
\subsubsection{PDL Description}
d752 8
a759 8
%
% Include a description of the interfaces for this module.
% This should include a list of data elements passed between
% modules.  The data elements described here should either be
% described in the next subsection or in the relevant owner's
% data dictionary
%
\subsubsection{Internal Interfaces}
d761 66
a826 10
%
% Include a data dictionary for this module.  The format should be:
%  
% Name: (this is the name of the data item)
% Aliases: (this is a list of aliases, if any)
% Where Used/ How Used: (this is a paired list of where the item is
%     used and how it is used
% Description: (this is a demarco description of the data item)
%
\subsubsection{Data Dictionary}
@


1.1
log
@Initial revision
@
text
@d1 734
@
