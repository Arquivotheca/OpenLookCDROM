head	1.1;
access;
symbols;
locks; strict;
comment	@% @;


1.1
date	92.10.17.20.34.18;	author lacey;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@%%===========================================================================
%%---------------------------------------------------------------------------
%% SUBSECTION FOR FILE SUBSYSTEM
%%---------------------------------------------------------------------------
%%===========================================================================
\subsection{File Subsystem}

%%%---------------------------------------------------------------------------
%%% SUBSUBSECTION FOR PROCESSING NARRATIVE
%%%
%%% For the preliminary design, make the processing narrative
%%% only textual. In the Detailed design, you will provide a
%%% structural description.
%%%---------------------------------------------------------------------------
\subsubsection{Processing Narrative}

When the read/write function is invoked the user will specify the type
of processing that is to take place. A file that is to be read could
have been previously generated by the project planning tool, or could
be generated from another program or a person typing directly into an
ASCII file, provided that the file structure is correct.  When reading
the data, the control will come from the the database and into a
format function, then to the read function. The read is then invoked
from the directory and file specified by the user. The data is then
read, formatted, and inserted into the database. This process will be
done using the {\em flex} and {\em bison} tools. The code produced by
{\em flex} will recognize identifiers and other lexical entities, and
{\em bison} will parse them making sure that the file read in is in the
correct format.  Refer to Figure~\ref{file-rec} for an example of a
file record. 

When the write function is invoked, then database will send data to a
format function, where the data will be formatted in a way that will
be easy to read from the read function. Then the format function will
invoke the write function.  Here the file specified by the user,
whether a new or old file, will be created, and the formatted data
will put in.  The files will be read and written to in a sequential
manner.

%%%---------------------------------------------------------------------------
%%% SUBSUBSECTION FOR INTERFACE DESCRIPTION
%%%---------------------------------------------------------------------------
\subsubsection{Interface Description}

The user will be able to invoke the read only if the database is
empty.  If the database is not empty, then the read from a file
command will not work because this project will only allow one
database at a time. At this point the user will be warned of this
notion. The write command can also be invoked by the user from the
interface. At this point the user will be able to write over a
pre-existing file that has the same name or change the name. The user
will be able to use these commands from the main screen in the program
under the file button menu.

%%%
%%%	The following section will be filled in during the detailed design
%%%	phase. For now, it is commented out.
%%%
%%%	\subsection{Design Language Description}

%%%---------------------------------------------------------------------------
%%% SUBSUBSECTION FOR MODULES USED
%%%
%%% Identify the modules to be used by different modules
%%%---------------------------------------------------------------------------
%%%===========================================================================
\subsubsection{Modules Used}

The file subsystem will contain three modules.  For reading, a module
will be created that utilizes the output of {\em flex}\/ and {\em
bison}.  This module will have actions associated with each of the
production rules in the grammar, with most actions storing data into
an internal structure, and some actions adding structures to the list
of tasks.  For writing, there will be a module that controls the
writing of tasks by traversing task lists, and another module, called
by the former, which actually writes out the task information for a
single task in the proper format.

%%%---------------------------------------------------------------------------
%%% SUBSUBSECTION FOR DATA ORGANIZATION
%%%
%%% Describe the data structures to be used for the software.
%%% Give their organization.
%%%---------------------------------------------------------------------------
\subsubsection{Data Organization}

The data structures used within this subsystem will consist of an
internal structure that is the same format as that structure used
within the database subsystem.  For creation of a new task and
addition of a task to the database, the database subsystem itself will
be utilized.

%%%---------------------------------------------------------------------------
%%% SUBSUBSECTION FOR COMMENTS
%%%
%%% Create the skeleton for each of the modules by commenting
%%% the purpose of each.
%%%---------------------------------------------------------------------------
\subsubsection{Comments}

\begin{enumerate}
	\item {\bf write-data-to-file} \\
This module will call the write-format module once for each task in
the task list, and will provide it will the information needed for the
task.
        \item {\bf write-format} \\
This module takes the information passed to it and sends it out to a
file in the proper format.
        \item {\bf read-data-from-file} \\
This module has all of the actions that were specified for the
project file grammar productions, and actually reads the data from the
file.
\end{enumerate}
@
