head	1.7;
access;
symbols;
locks; strict;
comment	@ * @;


1.7
date	92.12.13.11.05.46;	author lacey;	state Exp;
branches;
next	1.6;

1.6
date	92.12.13.02.04.21;	author lacey;	state Exp;
branches;
next	1.5;

1.5
date	92.12.11.15.45.50;	author lacey;	state Exp;
branches;
next	1.4;

1.4
date	92.12.10.09.05.52;	author lacey;	state Exp;
branches;
next	1.3;

1.3
date	92.12.03.14.53.40;	author lacey;	state Exp;
branches;
next	1.2;

1.2
date	92.11.27.20.32.07;	author lacey;	state Exp;
branches;
next	1.1;

1.1
date	92.11.19.15.27.18;	author lacey;	state Exp;
branches;
next	;


desc
@@


1.7
log
@*** empty log message ***
@
text
@/* FILE main_stubs.c ****************************************
 *
 * xplan - project planning tool
 * Copyright (C) 1992 Brian Gaubert, Mark M. Lacey, Richard Malingkas,
 * and Mike Marlow.
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License (distributed with this program in the file
 * COPYING) for more details.
 * 
 * If you did not received a copy of the GNU General Public License
 * along with this program, write to the Free Software Foundation,
 * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 * 
 * Since this was a project for a one semester software engineering
 * course, the authors will not be offering support for the product
 * after its release.
 *
 * DESCRIPTION OF CONTENTS
 *
 * main_stubs.c - Notify and event callback function stubs.
 * This file was generated by `gxv' from `main.G'.
 */

#include <stdio.h>
#include <sys/param.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <xview/xview.h>
#include <xview/panel.h>
#include <xview/textsw.h>
#include <xview/xv_xrect.h>
#include <xview/notice.h>
#include "db.h"
#include "calc.h"
#include "xplan.h"

void	taskList_Notify(Panel_item, char *, Xv_opaque, Panel_list_op, Event *, int);

int selected=0, last_selected=0;
struct task_node *current_task=NULL;
extern char project_filename[256];
extern char export_filename[];
int load_save_flag;

/*
 * Menu handler for `fileMenu (Load...)'.
 *
 * Author: Mark M. Lacey
 *
 */
Menu_item
  main_fileMenu_item0_callback(Menu_item item, Menu_generate op)
{
   char wd[256];

	main_mainWindow_objects * ip = (main_mainWindow_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:
		/* make the main window and task window busy */
		xv_set(Main_mainWindow->mainWindow,
		       FRAME_BUSY, TRUE, NULL);
		xv_set(Taskinfo_taskinfoPopup->taskinfoPopup,
		       FRAME_BUSY, TRUE, NULL);

		/* set the flag to load */
		load_save_flag = LOAD;
		xv_set(File_filePopup->filePopup, FRAME_LABEL, 
		       "Load File", NULL);
		xv_set(File_filePopup->applyButton, PANEL_LABEL_STRING,
		       "Load", NULL);

		/* get working directory */
		getwd(wd);

		/* set directory in window field */
		xv_set(File_filePopup->directoryField, PANEL_VALUE,
		       wd, NULL);
		
		/* fill the file list */
		fill_filelist(wd);

		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		xv_set(File_filePopup->filePopup, FRAME_CMD_PUSHPIN_IN, TRUE, NULL);
		xv_set(File_filePopup->filePopup, XV_SHOW, TRUE, NULL);
		
		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Menu handler for `fileMenu (Save As...)'.
 *
 * Author: Mark M. Lacey
 *
 */
Menu_item
main_fileMenu_item3_callback(Menu_item item, Menu_generate op)
{
   char wd[256];

	main_mainWindow_objects * ip = (main_mainWindow_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:
		
		/* make the main window busy */
		xv_set(Main_mainWindow->mainWindow,
		       FRAME_BUSY, TRUE, NULL);
		xv_set(Taskinfo_taskinfoPopup->taskinfoPopup,
		       FRAME_BUSY, TRUE, NULL);

		/* set flag to save */
		load_save_flag = SAVE;
		xv_set(File_filePopup->filePopup, FRAME_LABEL, 
		       "Save File", NULL);
		xv_set(File_filePopup->applyButton, PANEL_LABEL_STRING,
		       "Save", NULL);
		
		/* get working directory */
		getwd(wd);

		/* set it in field */
		xv_set(File_filePopup->directoryField, PANEL_VALUE,
		       wd, NULL);
		
		/* fill the file list */
		fill_filelist(wd);

		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		xv_set(File_filePopup->filePopup, FRAME_CMD_PUSHPIN_IN, TRUE, NULL);
		xv_set(File_filePopup->filePopup, XV_SHOW, TRUE, NULL);
		
		/* gxv_end_connections */
		
		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Menu handler for `exportMenu (Options...)'.
 * 
 * Author: Mark M. Lacey
 *
 */
Menu_item
main_exportMenu_item3_callback(Menu_item item, Menu_generate op)
{
   char wd[256];

	main_mainWindow_objects * ip = (main_mainWindow_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:

		/* get directory */
		getwd(wd);
		
		/* set it in field */
		xv_set(Export_exportPopup->directory,
		       PANEL_VALUE, wd, NULL);

		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		xv_set(Export_exportPopup->exportPopup, FRAME_CMD_PUSHPIN_IN, TRUE, NULL);
		xv_set(Export_exportPopup->exportPopup, XV_SHOW, TRUE, NULL);
		
		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}


/*
 * Menu handler for `insertMenu (Before)'.
 *
 * Author: Mark M. Lacey
 *
 */
Menu_item
main_insertMenu_item0_callback(Menu_item item, Menu_generate op)
{
   struct task_list *temp_list;
   struct task_node *new_task_node;
   struct task_node *temp_task;
   char *temp_name;
   Xv_notice       notice;

	main_mainWindow_objects * ip = (main_mainWindow_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:

		/* if nothing has been selected, let them know */
		if (selected == -1) {
		   notice = xv_create(Main_mainWindow->mainWindow, NOTICE,
				      NOTICE_MESSAGE_STRINGS, 
				      "You must first select a task to add before", 
				      NULL,
				      NOTICE_BUTTON_YES, "Continue",
				      XV_SHOW, TRUE,
				      NULL);
		   xv_destroy_safe(notice);
		   return item;
		}
		
		/* if they inserted one earlier and haven't applied */
		/* changes to it yet, let them know */
		if (find_task(get_main_task_list(), "New Task")) {
		   
		   notice = xv_create(Main_mainWindow->mainWindow, NOTICE,
				      NOTICE_MESSAGE_STRINGS, "You must first rename the current task and select 'Apply'", NULL,
				      NOTICE_BUTTON_YES, "Continue",
				      XV_SHOW, TRUE,
				      NULL);
		   xv_destroy_safe(notice);
		   return;
		}

		/* create a new task */
		new_task_node = create_default_task();

		temp_list = get_main_task_list();

		/* find the name of the task we are adding before */
		temp_name = (char *) xv_get(ip->taskList,
					    PANEL_LIST_STRING,
					    selected, NULL);

		/* find a pointer to the task we are adding before */
		temp_task = find_task(temp_list, temp_name);
		/* add the new task before the existing one */
		add_task_before(temp_list, temp_task, new_task_node);

		/* modify the scrolling list to show what happened */
		xv_set(ip->taskList, PANEL_LIST_INSERT, selected,
		       PANEL_LIST_STRING, selected,
		       new_task_node->data->name,
		       PANEL_LIST_SELECT, selected, TRUE, NULL);

		/* update various displays along with global data */
		current_task = new_task_node;
		load_data_to_taskinfoPopup(new_task_node);
		fill_dependency_popup(new_task_node);
		fill_resource_popup(new_task_node);

		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		xv_set(Taskinfo_taskinfoPopup->taskinfoPopup, FRAME_CMD_PUSHPIN_IN, TRUE, NULL);
		xv_set(Taskinfo_taskinfoPopup->taskinfoPopup, XV_SHOW, TRUE, NULL);
		
		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Menu handler for `insertMenu (After)'.
 *
 * Author: Mark M. Lacey
 *
 */
Menu_item
main_insertMenu_item1_callback(Menu_item item, Menu_generate op)
{
   struct task_list *temp_list;
   struct task_node *new_task_node;
   struct task_node *temp_task;
   char *temp_name;
   Xv_notice       notice;


	main_mainWindow_objects * ip = (main_mainWindow_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:
		
		/* if nothing has been selected, let them know */
		if (selected == -1) {
		   notice = xv_create(Main_mainWindow->mainWindow, NOTICE,
				      NOTICE_MESSAGE_STRINGS, "You must first select a task to add after", NULL,
				      NOTICE_BUTTON_YES, "Continue",
				      XV_SHOW, TRUE,
				      NULL);
		   xv_destroy_safe(notice);
		   return;
		}

		/* if they created a new task and haven't applied */
		/* changes, let them know */
		if (find_task(get_main_task_list(), "New Task")) {
		   
		   notice = xv_create(Main_mainWindow->mainWindow, NOTICE,
				      NOTICE_MESSAGE_STRINGS, "You must first rename the current task and select 'Apply'", NULL,
				      NOTICE_BUTTON_YES, "Continue",
				      XV_SHOW, TRUE,
				      NULL);
		   xv_destroy_safe(notice);
		   return;
		}

		/* create a new task */
		new_task_node = create_default_task();

		temp_list = get_main_task_list();

		/* find the name of the one we are adding after */
		temp_name = (char *) xv_get(ip->taskList,
					    PANEL_LIST_STRING,
					    selected, NULL);

		/* find a pointer to it */
		temp_task = find_task(temp_list, temp_name);
		/* add after it */
		add_task_after(temp_list, temp_task, new_task_node);
		/* modify the selected field */
		selected = selected+1;

		/* highlight selected field */
		xv_set(ip->taskList, PANEL_LIST_INSERT, selected,
		       PANEL_LIST_STRING, selected,
		       new_task_node->data->name,
		       PANEL_LIST_SELECT, selected, TRUE, NULL);

		/* store global data and update displays */
		current_task = new_task_node;
		load_data_to_taskinfoPopup(new_task_node);
		fill_dependency_popup(new_task_node);
		fill_resource_popup(new_task_node);

		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		xv_set(Taskinfo_taskinfoPopup->taskinfoPopup, FRAME_CMD_PUSHPIN_IN, TRUE, NULL);
		xv_set(Taskinfo_taskinfoPopup->taskinfoPopup, XV_SHOW, TRUE, NULL);
		
		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Menu handler for `insertMenu (Top)'.
 *
 * Author: Mark M. Lacey
 *
 */
Menu_item
main_insertMenu_item2_callback(Menu_item item, Menu_generate op)
{
   struct task_list *temp_list;
   struct task_node *new_task_node;
   struct task_node *temp_task;
   Xv_notice       notice;


	main_mainWindow_objects * ip = (main_mainWindow_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:
		if (find_task(get_main_task_list(), "New Task")) {
		   
		   notice = xv_create(Main_mainWindow->mainWindow, NOTICE,
				      NOTICE_MESSAGE_STRINGS, "You must first rename the current task and select 'Apply'", NULL,
				      NOTICE_BUTTON_YES, "Continue",
				      XV_SHOW, TRUE,
				      NULL);
		   xv_destroy_safe(notice);
		   return;
		}

		new_task_node = create_default_task();

		temp_list = get_main_task_list();

		add_task_to_beginning(temp_list, new_task_node);
		selected = 0;
		xv_set(ip->taskList, PANEL_LIST_INSERT, selected,
		       PANEL_LIST_STRING, selected,
		       new_task_node->data->name,
		       PANEL_LIST_SELECT, selected, TRUE, NULL);

		current_task = new_task_node;
		load_data_to_taskinfoPopup(new_task_node);
		fill_dependency_popup(new_task_node);
		fill_resource_popup(new_task_node);

		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		xv_set(Taskinfo_taskinfoPopup->taskinfoPopup, FRAME_CMD_PUSHPIN_IN, TRUE, NULL);
		xv_set(Taskinfo_taskinfoPopup->taskinfoPopup, XV_SHOW, TRUE, NULL);
		
		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Menu handler for `insertMenu (Bottom)'.
 *
 * Author: Mark M. Lacey
 *
 */
Menu_item
main_insertMenu_item3_callback(Menu_item item, Menu_generate op)
{
   struct task_list *temp_list;
   struct task_node *new_task_node;
   struct task_node *temp_task;
   unsigned nrows;
   Xv_notice       notice;

	main_mainWindow_objects * ip = (main_mainWindow_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:
		
		if (find_task(get_main_task_list(), "New Task")) {
		   notice = xv_create(Main_mainWindow->mainWindow, NOTICE,
				      NOTICE_MESSAGE_STRINGS, "You must first rename the current task and select 'Apply'", NULL,
				      NOTICE_BUTTON_YES, "Continue",
				      XV_SHOW, TRUE,
				      NULL);
		   xv_destroy_safe(notice);
		   return;
		}

		new_task_node = create_default_task();

		temp_list = get_main_task_list();

		add_task_to_end(temp_list, new_task_node);
		
		nrows = (unsigned) xv_get(ip->taskList,
					  PANEL_LIST_NROWS,
					  NULL);
		selected = nrows;
		xv_set(ip->taskList, PANEL_LIST_INSERT, selected,
		       PANEL_LIST_STRING, selected,
		       new_task_node->data->name,
		       PANEL_LIST_SELECT, selected, TRUE, NULL);

		current_task = new_task_node;
		load_data_to_taskinfoPopup(new_task_node);
		fill_dependency_popup(new_task_node);
		fill_resource_popup(new_task_node);


		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		xv_set(Taskinfo_taskinfoPopup->taskinfoPopup, FRAME_CMD_PUSHPIN_IN, TRUE, NULL);
		xv_set(Taskinfo_taskinfoPopup->taskinfoPopup, XV_SHOW, TRUE, NULL);
		
		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Notify callback function for `taskList'.
 *
 * Author: Mark M. Lacey
 *
 */
int
main_mainWindow_taskList_notify_callback(Panel_item item, char *string, Xv_opaque client_data, Panel_list_op op, Event *event, int row)
{
	main_mainWindow_objects *ip = (main_mainWindow_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch(op) {
	case PANEL_LIST_OP_DESELECT:

	   /* set up global data */
	   last_selected = selected;
	   selected = -1;
		break;

	case PANEL_LIST_OP_SELECT:
		
	   /* find the current task that was selected */
	   current_task = find_task(get_main_task_list(), string);
	   /* update windows */
	   load_data_to_taskinfoPopup(current_task);
	   fill_dependency_popup(current_task);
	   fill_resource_popup(current_task);
	   /* store which row it was in */
	   selected = row;
		
	   xv_set(Taskinfo_taskinfoPopup->taskinfoPopup,
		  FRAME_CMD_PUSHPIN_IN, TRUE, XV_SHOW, TRUE,
		  NULL);


		break;

	case PANEL_LIST_OP_VALIDATE:
		break;

	case PANEL_LIST_OP_DELETE:
		break;
	}
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	taskList_Notify(item, string, client_data, op, event, row);
	
	/* gxv_end_connections */

	return XV_OK;
}

/*
 * User-defined action for `taskList'.
 */
void
taskList_Notify(Panel_item item, char *string, Xv_opaque client_data, Panel_list_op op, Event *event, int row)
{

}

/*
 * Menu handler for `chartMenu (PERT)'.
 */
Menu_item
display_pert_callback(Menu_item item, Menu_generate op)
{
   Xv_notice notice;
   char buffer[100];

	main_mainWindow_objects * ip = (main_mainWindow_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:
		/* set up the formatting information and check for a */
		/* dependency loop */
		traverse_task_list();

		if (loop_found) {
		   sprintf(buffer, "A dependency loop was found at "
			   "task %s", loop_pointer->data->name);
		   notice = xv_create(Main_mainWindow->mainWindow, NOTICE,
				      NOTICE_MESSAGE_STRINGS, 
				      buffer, NULL,
				      NOTICE_BUTTON_YES, "Continue",
				      XV_SHOW, TRUE,
				      NULL);
		   xv_destroy_safe(notice);
		   return;
		}

		/* calculate the critical path */
		calc_critical();

		/* pop up the window */

		xv_set(PERT_pertPopup->pertPopup,
		       FRAME_CMD_PUSHPIN_IN, TRUE, NULL);

		xv_set(PERT_pertPopup->pertPopup, XV_SHOW, TRUE, NULL);
		
		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Menu handler for `chartMenu (Gantt)'.
 *
 * Author: Mark M. Lacey
 *
 */
Menu_item
display_gantt_callback(Menu_item item, Menu_generate op)
{
	main_mainWindow_objects * ip = (main_mainWindow_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:

		/* pop up the window */

		xv_set(Gantt_ganttPopup->ganttPopup,
		       FRAME_CMD_PUSHPIN_IN, TRUE, NULL);

		xv_set(Gantt_ganttPopup->ganttPopup, XV_SHOW, TRUE, NULL);
		
		
		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Menu handler for `analyzeMenu (Find Critical Path)'.
 */
Menu_item
find_critical_path_callback(Menu_item item, Menu_generate op)
{
   Xv_notice notice;

	main_mainWindow_objects * ip = (main_mainWindow_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:

		/* find the critical path */
		calc_critical();
		notice = xv_create(Main_mainWindow->mainWindow, NOTICE,
				   NOTICE_MESSAGE_STRINGS, 
				   "Critical path calculated and stored",
				   NULL,
				   NOTICE_BUTTON_YES, "Continue",
				   XV_SHOW, TRUE,
				      NULL);
		xv_destroy_safe(notice);
		return;

		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Menu handler for `analyzeMenu (Check Dependencies)'.
 *
 * Author: Mark M. Lacey
 *
 */
Menu_item
check_dependencies_callback(Menu_item item, Menu_generate op)
{
   Xv_notice notice;
   char buffer[200];
   struct task_node *loop_pointer;

	main_mainWindow_objects * ip = (main_mainWindow_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:

		/* check for dependency loop */
		traverse_task_list();

		if (loop_found) {
		   sprintf(buffer, "A dependency loop was found at "
			   "task %s", loop_pointer->data->name);
		   notice = xv_create(Main_mainWindow->mainWindow, NOTICE,
				      NOTICE_MESSAGE_STRINGS, 
				      buffer, NULL,
				      NOTICE_BUTTON_YES, "Continue",
				      XV_SHOW, TRUE,
				      NULL);
		   xv_destroy_safe(notice);
		   return item;
		} else {
		   notice = xv_create(Main_mainWindow->mainWindow,
				      NOTICE,
				      NOTICE_MESSAGE_STRINGS,
				      "The dependencies are acceptable",
				      NULL,
				      NOTICE_BUTTON_YES, "Continue",
				      XV_SHOW, TRUE,
				      NULL);
		   xv_destroy_safe(notice);
		   return item;
		}

		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Notify callback function for `deleteButton'.
 *
 * Author: Mark M. Lacey
 *
 */
void
main_deleteButton_callback(Panel_item item, Event *event)
{
   int
     nrows;
   char
     *string;
   struct task_node
     *t1, /* nodes to traverse lists */
     *t2;
   Xv_notice       notice;
   struct task_node *temp_task;

	main_mainWindow_objects *ip = (main_mainWindow_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
   /* if nothing has been selected, quit */
   if (selected == -1) {
      notice = xv_create(Main_mainWindow->mainWindow, NOTICE,
			 NOTICE_MESSAGE_STRINGS, "You must first select a task to delete", NULL,
			 NOTICE_BUTTON_YES, "Continue",
			 XV_SHOW, TRUE,
			 NULL);
      xv_destroy_safe(notice);
      return;
   }

   string = (char *) xv_get(ip->taskList, PANEL_LIST_STRING, selected);
   temp_task = find_task(get_main_task_list(), string);

   if (!temp_task) return;

   /* first remove ourself from our dependency list, if we are there */
   t1 = find_task(temp_task->data->dependencies, temp_task->data->name);
   while (t1) {
      remove_task_node(temp_task->data->dependencies, t1);
      t1 = find_task(temp_task->data->dependencies, 
		     temp_task->data->name);
   }

   /* now remove ourself from all dependents lists */
   t1 = temp_task->data->dependencies->head;
   while (t1) {
      t2 = find_task(t1->data->dependents, temp_task->data->name);
      while (t2) {
	 remove_task_node(t1->data->dependents, t2);
	 t2 = find_task(t1->data->dependents, temp_task->data->name);
      }
      t1 = t1->next;
   }

   /* first remove ourself from our dependents list, if we are there */
   t1 = find_task(temp_task->data->dependents, temp_task->data->name);
   while (t1) {
      remove_task_node(temp_task->data->dependents, t1);
      t1 = find_task(temp_task->data->dependents, temp_task->data->name);
   }

   /* now remove ourself from all dependency lists */
   t1 = temp_task->data->dependents->head;
   while (t1) {
      t2 = find_task(t1->data->dependencies, temp_task->data->name);
      while (t2) {
	 remove_task_node(t1->data->dependencies, t2);
	 t2 = find_task(t1->data->dependencies, temp_task->data->name);
      }
      t1 = t1->next;
   }

   destroy_task_node(get_main_task_list(), temp_task);
   current_task = list_current(get_main_task_list());
   xv_set(ip->taskList, PANEL_LIST_DELETE, selected, NULL);

   nrows = (unsigned) xv_get(ip->taskList, PANEL_LIST_NROWS, NULL);

   if (nrows == 0) {
      xv_set(Taskinfo_taskinfoPopup->taskinfoPopup,
	     FRAME_CMD_PUSHPIN_IN, FALSE, NULL);
      xv_set(Taskinfo_taskinfoPopup->taskinfoPopup, XV_SHOW, FALSE,
	     NULL);
      xv_set(Dependencies_dependenciesPopup->dependenciesPopup,
	     FRAME_CMD_PUSHPIN_IN, FALSE, NULL);
      xv_set(Dependencies_dependenciesPopup->dependenciesPopup, 
	     XV_SHOW, FALSE, NULL);
      return;
   }

   if (selected == nrows) selected = selected - 1;

   xv_set(ip->taskList, PANEL_LIST_SELECT, selected, TRUE, NULL);

   /* load the data for the new current item in the list */
   load_data_to_taskinfoPopup(current_task);
   fill_dependency_popup(current_task);
   fill_resource_popup(current_task);

	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

}

/*
 * Menu handler for `fileMenu (New Project)'.
 *
 * Author: Mark M. Lacey
 *
 */
Menu_item
new_project_callback(Menu_item item, Menu_generate op)
{
   int nrows;

	main_mainWindow_objects * ip = (main_mainWindow_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:
		strcpy(project_filename, "untitled.prj");
		strcpy(export_filename, "untitled.tex");

		destroy_task_list(get_main_task_list());
		/* find the number of rows currently in the list, and */
		/* delete them */
		nrows = (int) xv_get(Main_mainWindow->taskList, PANEL_LIST_NROWS);
		xv_set(Main_mainWindow->taskList, PANEL_LIST_DELETE_ROWS, 0, nrows,
		       NULL);
		/* pop down the task info and dependencies popups */
		xv_set(Taskinfo_taskinfoPopup->taskinfoPopup, 
		       FRAME_CMD_PUSHPIN_IN, FALSE, NULL);
		xv_set(Taskinfo_taskinfoPopup->taskinfoPopup, 
		       XV_SHOW, FALSE, NULL);

		xv_set(Dependencies_dependenciesPopup->dependenciesPopup, 
		       FRAME_CMD_PUSHPIN_IN, FALSE, NULL);
		xv_set(Dependencies_dependenciesPopup->dependenciesPopup, 
		       XV_SHOW, FALSE, NULL);

		xv_set(Resources_resourcesPopup->resourcesPopup, 
		       FRAME_CMD_PUSHPIN_IN, FALSE, NULL);
		xv_set(Resources_resourcesPopup->resourcesPopup, 
		       XV_SHOW, FALSE, NULL);
		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Menu handler for `fileMenu (Save)'.
 *
 * Author: Mark M. Lacey
 *
 */
Menu_item
save_callback(Menu_item item, Menu_generate op)
{
   Xv_notice notice;
   int status;
   char wd[256];
   struct stat     s_buf;	/* points to file stat structure */

   
   main_mainWindow_objects * ip = (main_mainWindow_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
   
   switch (op) {
    case MENU_DISPLAY:
      break;
      
    case MENU_DISPLAY_DONE:
      break;
      
    case MENU_NOTIFY:

      if (writefile_init(project_filename)==1) {
	 notice = xv_create(File_filePopup->filePopup, NOTICE,
			    NOTICE_MESSAGE_STRINGS, 
			    "Permission denied on file write", NULL,
			    NOTICE_BUTTON_YES, "Continue",
			    XV_SHOW, TRUE,
			    NULL);
	 xv_destroy_safe(notice);
      } 
      return item;
      break;
      
    case MENU_NOTIFY_DONE:
      break;
   }
   
		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		/* gxv_end_connections */
}

/*
 * Menu handler for `analyzeMenu (Date Calculation)'.
 *
 * Author: Mark M. Lacey
 *
 */
Menu_item
calc_early_start_date(Menu_item item, Menu_generate op)
{
   Xv_notice notice;

	main_mainWindow_objects * ip = (main_mainWindow_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:
		calc_dates();
		load_data_to_taskinfoPopup(current_task);
		fill_dependency_popup(current_task);
		fill_resource_popup(current_task);
		notice = xv_create(Main_mainWindow->mainWindow, NOTICE,
				   NOTICE_MESSAGE_STRINGS, 
				   "Dates calculated and stored", NULL,
				   NOTICE_BUTTON_YES, "Continue",
				   XV_SHOW, TRUE,
				   NULL);
		xv_destroy_safe(notice);
		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Menu handler for `exportMenu (Generate Task Sheet)'.
 *
 * Author: Mark M. Lacey
 *
 */
Menu_item
task_list_callback(Menu_item item, Menu_generate op)
{
   Xv_notice notice;

	main_mainWindow_objects * ip = (main_mainWindow_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:

		latex_task_list();
		notice = xv_create(File_filePopup->filePopup, NOTICE,
				   NOTICE_MESSAGE_STRINGS, 
				   "LaTeX task sheet generated", NULL,
				   NOTICE_BUTTON_YES, "Continue",
				   XV_SHOW, TRUE,
				   NULL);
		xv_destroy_safe(notice);
		

		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Menu handler for `exportMenu (Generate PERT Chart)'.
 *
 * Author: Mark M. Lacey
 *
 */
Menu_item
latex_pert_callback(Menu_item item, Menu_generate op)
{
   Xv_notice notice;

	main_mainWindow_objects * ip = (main_mainWindow_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:
		generate_latex_pert_pages();
		notice = xv_create(File_filePopup->filePopup, NOTICE,
				   NOTICE_MESSAGE_STRINGS, 
				   "LaTeX PERT chart generated", NULL,
				   NOTICE_BUTTON_YES, "Continue",
				   XV_SHOW, TRUE,
				   NULL);
		xv_destroy_safe(notice);

		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Menu handler for `exportMenu (Generate Gantt Chart)'.
 *
 * Author: Mark M. Lacey
 *
 */
Menu_item
latex_gantt_callback(Menu_item item, Menu_generate op)
{
   Xv_notice notice;

	main_mainWindow_objects * ip = (main_mainWindow_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:
		generate_gantt_charts();

		notice = xv_create(File_filePopup->filePopup, NOTICE,
				   NOTICE_MESSAGE_STRINGS, 
				   "LaTeX Gantt chart generated", NULL,
				   NOTICE_BUTTON_YES, "Continue",
				   XV_SHOW, TRUE,
				   NULL);
		xv_destroy_safe(notice);

		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}
@


1.6
log
@*** empty log message ***
@
text
@d1 26
a26 1
/*
d54 3
d73 1
d79 1
d86 1
d89 1
d93 1
d113 3
d133 1
d139 1
d146 1
d149 1
d153 1
d173 3
d192 2
a193 1
		
d196 1
d218 3
d241 2
a242 1
		
d255 2
d268 1
d273 1
d278 1
d280 1
d283 1
d289 1
d312 3
d337 1
d348 2
d361 1
d366 1
d371 1
d373 1
d375 1
d378 1
d384 1
d407 3
d474 3
d546 3
d558 1
d565 1
d567 1
d571 1
d625 2
d642 1
d645 2
d666 3
d683 3
a685 1
		
d723 1
d749 3
d771 1
d773 1
d784 1
a784 1
		   return;
d795 1
a795 1
		   return;
d812 3
d919 3
d976 3
d1023 3
d1067 3
d1111 3
d1153 3
@


1.5
log
@The file we did our final demo with.
@
text
@d592 6
@


1.4
log
@*** empty log message ***
@
text
@d25 1
d529 1
d542 1
d544 2
d548 1
a548 2
				      "A dependency loop was found at "
				      "task !!!",
d556 5
a560 1
		xv_set(PERT_pertPopup->pertPopup, FRAME_CMD_PUSHPIN_IN, TRUE, NULL);
a593 3
		xv_set(Gantt_ganttPopup->ganttPopup, FRAME_CMD_PUSHPIN_IN, TRUE, NULL);
		xv_set(Gantt_ganttPopup->ganttPopup, XV_SHOW, TRUE, NULL);
		
d624 6
a629 8
/*		traverse_task_list();
		if (loop_found) {
		   notice = xv_create(Main_mainWindow->mainWindow, NOTICE,
				      NOTICE_MESSAGE_STRINGS, 
				      "A dependency loop was found at "
				      "task !!!",
				      NOTICE_BUTTON_YES, "Continue",
				      XV_SHOW, TRUE,
d631 3
a633 4
		   xv_destroy_safe(notice);
		   return;
		}
*/
d653 2
d669 2
d673 1
a673 2
				      "A dependency loop was found at "
				      "task !!!",
d679 11
d736 2
d826 2
a827 2
		project_filename[0] = '\0';
		export_filename[0]='\0';
d845 5
d885 10
a894 44
      /* if there is no project file name */
      if (project_filename[0]=='\0') {
	 xv_set(Main_mainWindow->mainWindow,
		FRAME_BUSY, TRUE, NULL);
	 xv_set(Taskinfo_taskinfoPopup->taskinfoPopup,
		FRAME_BUSY, TRUE, NULL);
	 
	 load_save_flag = SAVE;
	 xv_set(File_filePopup->filePopup, FRAME_LABEL, 
		"Save File", NULL);
	 xv_set(File_filePopup->applyButton, PANEL_LABEL_STRING,
		"Save", NULL);
	 
	 getwd(wd);
	 
	 xv_set(File_filePopup->directoryField, PANEL_VALUE,
		wd, NULL);
	 
	 fill_filelist(wd);
      } else {
	 if (stat(project_filename, &s_buf) == 0) {
	    if (writefile_init(project_filename)==1) {
	       notice = xv_create(File_filePopup->filePopup, NOTICE,
				  NOTICE_MESSAGE_STRINGS, 
				  "Permission denied on file write", NULL,
				  NOTICE_BUTTON_YES, "Continue",
				  XV_SHOW, TRUE,
				  NULL);
		  xv_destroy_safe(notice);
	    } 
	    return item;
	 } else {
	    if (writefile_init(project_filename)==1) {
	       notice = xv_create(File_filePopup->filePopup, NOTICE,
				  NOTICE_MESSAGE_STRINGS, 
				  "Permission denied on file write", NULL,
				  NOTICE_BUTTON_YES, "Continue",
				  XV_SHOW, TRUE,
			       NULL);
	       xv_destroy_safe(notice);
	    } 
	 return item;
	 }
      }
d912 2
d925 10
d953 2
d967 8
d994 2
d1007 8
a1014 1
		
d1033 2
d1046 8
@


1.3
log
@Revisions prior to practice demo
@
text
@d9 1
a14 1
#include "xplan.h"
d17 1
d21 2
a22 2
int selected, last_selected;
struct task_node *current_task;
d24 1
d95 1
d130 1
a130 1
 * Menu handler for `chartMenu (PERT)'.
d133 1
a133 1
main_chartMenu_item0_callback(Menu_item item, Menu_generate op)
d135 1
a135 5
	main_mainWindow_objects * ip = (main_mainWindow_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;
a136 22
	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:
		
		/* gxv_start_connections DO NOT EDIT THIS SECTION */
		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Menu handler for `chartMenu (Gantt)'.
 */
Menu_item
main_chartMenu_item1_callback(Menu_item item, Menu_generate op)
{
d148 4
a151 2
		/* gxv_start_connections DO NOT EDIT THIS SECTION */
		/* gxv_end_connections */
a152 25
		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Menu handler for `exportMenu (Options...)'.
 */
Menu_item
main_exportMenu_item3_callback(Menu_item item, Menu_generate op)
{
	main_mainWindow_objects * ip = (main_mainWindow_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:
		
d233 2
d315 2
d372 1
a372 1
		xv_set(ip->taskList, PANEL_LIST_INSERT, 0,
d379 2
a420 1
		   
d440 1
a440 1
		xv_set(ip->taskList, PANEL_LIST_INSERT, nrows,
d447 2
d485 2
d489 3
a491 3
		xv_set(Taskinfo_taskinfoPopup->taskinfoPopup,
		       FRAME_CMD_PUSHPIN_IN, TRUE, XV_SHOW, TRUE,
		       NULL);
d527 2
d539 12
a550 2
		
		/* gxv_start_connections DO NOT EDIT THIS SECTION */
d555 2
d605 2
d618 2
a619 1
		traverse_task_list();
d621 9
a629 1
		   puts("There was a loop found.\n");
d631 1
a631 1

d650 2
d665 9
a673 1
		   puts("There was a loop found.\n");
d698 3
d720 37
d768 4
d781 2
d808 3
d817 10
a826 2
		
		
d846 3
d850 73
d933 61
a993 8
		if (writefile_init(project_filename)==1) {
		   notice = xv_create(Main_mainWindow->mainWindow, NOTICE,
				      NOTICE_MESSAGE_STRINGS, "Permission denied on file write", NULL,
				      NOTICE_BUTTON_YES, "Continue",
				      XV_SHOW, TRUE,
				      NULL);
		   xv_destroy_safe(notice);
		}
d995 30
@


1.2
log
@*** empty log message ***
@
text
@d13 1
d20 3
a22 2
unsigned last_insert = -1;
extern int Today;
d28 1
a28 1
main_fileMenu_item0_callback(Menu_item item, Menu_generate op)
d30 2
d42 4
a45 7
		fputs("xplan: main_fileMenu_item0_callback: MENU_NOTIFY\n", stderr);
		puts("Calling readfile...\n");
		if (readfile("testfile")) {
		   puts("Error reading file!!!\n");
		} else {
		   puts("All is well...\n");
		}
d47 10
d58 2
d81 2
d93 18
a110 2
		fputs("xplan: main_fileMenu_item3_callback: MENU_NOTIFY\n", stderr);
		writefile_init("newtestfile");
d117 1
a117 1

a141 1
		fputs("xplan: main_chartMenu_item0_callback: MENU_NOTIFY\n", stderr);
a169 1
		fputs("xplan: main_chartMenu_item1_callback: MENU_NOTIFY\n", stderr);
a197 1
		fputs("xplan: main_exportMenu_item3_callback: MENU_NOTIFY\n", stderr);
a220 2
   int selected_item;
   struct task_info *current_task;
d225 1
a236 1
		fputs("xplan: main_insertMenu_item0_callback: MENU_NOTIFY\n", stderr);
d238 9
a246 1
		if (last_insert == -1) {
d249 11
d261 1
a261 2
		selected_item = (int) xv_get(ip->taskList,
					     PANEL_LIST_FIRST_SELECTED);
a262 21
		if (selected_item != -1)
		  xv_set(ip->taskList, PANEL_LIST_OP_DESELECT,
			 selected_item, NULL);

		/* make the main window busy */
		xv_set(ip->mainWindow, FRAME_BUSY, TRUE, NULL);

		current_task = create_task_info("New Task",
						"",
						0, 
						Today, Today, Today, 
						Today, Today, Today, 
						0, 0, 0, 0,
						0, 0, 0, NULL, NULL,
						NULL, NULL, NULL, 0,
						0, 0, 0, 0, 0);
		
		new_task_node = create_task_node(current_task,
						 NULL,
						 NULL);
		
d267 1
a267 1
					    last_insert, NULL);
d270 1
a270 1
		add_task_after(temp_list, temp_task, new_task_node);
d272 4
a275 4
		xv_set(ip->taskList, PANEL_LIST_INSERT, last_insert,
		       PANEL_LIST_STRING, last_insert,
		       list_current(get_main_task_list())->data->name,
		       NULL);
d277 2
a278 1
		/* don't need to update last_insert */
a279 2
		load_data_to_taskinfoPopup(current_task);
		
a300 2
   int selected_item;
   struct task_info *current_task;
d305 1
a317 1
		fputs("xplan: main_insertMenu_item1_callback: MENU_NOTIFY\n", stderr);
d319 8
a326 2
		if (last_insert == -1) {
		   return item;
d329 10
a338 2
		selected_item = (int) xv_get(ip->taskList,
					     PANEL_LIST_FIRST_SELECTED);
d340 1
a340 3
		if (selected_item != -1)
		  xv_set(ip->taskList, PANEL_LIST_OP_DESELECT,
			 selected_item, NULL);
a341 17
		   /* make the main window busy */
		xv_set(ip->mainWindow, FRAME_BUSY, TRUE, NULL);

		current_task = create_task_info("New Task",
						"",
						0, 
						Today, Today, Today, 
						Today, Today, Today, 
						0, 0, 0, 0,
						0, 0, 0, NULL, NULL,
						NULL, NULL, NULL, 0,
						0, 0, 0, 0, 0);

		new_task_node = create_task_node(current_task,
						 NULL,
						 NULL);
		
d346 1
a346 1
					    last_insert+1, NULL);
d349 2
a350 1
		add_task_before(temp_list, temp_task, new_task_node);
d352 4
a355 4
		xv_set(ip->taskList, PANEL_LIST_INSERT, last_insert+1,
		       PANEL_LIST_STRING, last_insert+1,
		       list_current(get_main_task_list())->data->name,
		       NULL);
d357 2
a358 1
		last_insert = last_insert + 1;
a359 2
		load_data_to_taskinfoPopup(current_task);
		
a380 2
   int selected_item;
   struct task_info *current_task;
d384 1
d397 10
a406 4
		fputs("xplan: main_insertMenu_item2_callback: MENU_NOTIFY\n", stderr);
		
		selected_item = (int) xv_get(ip->taskList,
					     PANEL_LIST_FIRST_SELECTED);
d408 1
a408 3
		if (selected_item != -1)
		  xv_set(ip->taskList, PANEL_LIST_OP_DESELECT,
			 selected_item, NULL);
a409 17
		/* make the main window busy */
		xv_set(ip->mainWindow, FRAME_BUSY, TRUE, NULL);

		current_task = create_task_info("New Task",
						"",
						0, 
						Today, Today, Today, 
						Today, Today, Today, 
						0, 0, 0, 0,
						0, 0, 0, NULL, NULL,
						NULL, NULL, NULL, 0,
						0, 0, 0, 0, 0);
		
		new_task_node = create_task_node(current_task,
						 NULL,
						 NULL);
		
d413 1
a413 1

d415 3
a417 4
		       PANEL_LIST_STRING, 0,
		       list_current(get_main_task_list())->data->name,
		       NULL);
		last_insert = 0;
d419 3
a421 2
		load_data_to_taskinfoPopup(current_task);
		
a442 2
   int selected_item;
   struct task_info *current_task;
d447 1
a448 1

a458 1
		fputs("xplan: main_insertMenu_item3_callback: MENU_NOTIFY\n", stderr);
d460 10
a469 2
		selected_item = (int) xv_get(ip->taskList,
					     PANEL_LIST_FIRST_SELECTED);
d471 1
a471 3
		if (selected_item != -1)
		  xv_set(ip->taskList, PANEL_LIST_OP_DESELECT,
			 selected_item, NULL);
a472 17
		/* make the main window busy */
		xv_set(ip->mainWindow, FRAME_BUSY, TRUE, NULL);

		current_task = create_task_info("New Task",
						"",
						0, 
						Today, Today, Today, 
						Today, Today, Today, 
						0, 0, 0, 0,
						0, 0, 0, NULL, NULL,
						NULL, NULL, NULL, 0,
						0, 0, 0, 0, 0);
		
		new_task_node = create_task_node(current_task,
						 NULL,
						 NULL);
		
d480 1
a480 1

d482 3
a484 3
		       PANEL_LIST_STRING, nrows,
		       list_current(get_main_task_list())->data->name,
		       NULL);
d486 2
a487 1
		last_insert = nrows;
d489 1
a489 2
		load_data_to_taskinfoPopup(current_task);
		
a510 1
   struct task_node *temp_task;
d516 2
a517 2

		fprintf(stderr, "xplan: main_mainWindow_taskList_notify_callback: PANEL_LIST_OP_DESELECT: %s\n",string);
d522 3
a524 1
		last_insert = row;
a525 4
		temp_task = find_task(get_main_task_list(), string);
		
		load_data_to_taskinfoPopup(temp_task);
		
d527 4
a530 16
		       FRAME_CMD_PUSHPIN_IN, TRUE, NULL);
		
		xv_set(Taskinfo_taskinfoPopup->taskinfoPopup, XV_SHOW,
		       TRUE, NULL);
		
		temp_task = find_task(get_main_task_list(), string);
		
		load_data_to_taskinfoPopup(temp_task);
		
		xv_set(Taskinfo_taskinfoPopup->taskinfoPopup,
		       FRAME_CMD_PUSHPIN_IN, TRUE, NULL);
		
		xv_set(Taskinfo_taskinfoPopup->taskinfoPopup, XV_SHOW,
		       TRUE, NULL);
		
		fprintf(stderr, "xplan: main_mainWindow_taskList_notify_callback: PANEL_LIST_OP_SELECT: %s\n",string);
a533 1
		fprintf(stderr, "xplan: main_mainWindow_taskList_notify_callback: PANEL_LIST_OP_VALIDATE: %s\n",string);
a536 1
		fprintf(stderr, "xplan: main_mainWindow_taskList_notify_callback: PANEL_LIST_OP_DELETE: %s\n",string);
d555 1
a555 1
	fputs("xplan: taskList_Notify\n", stderr);
a573 1
		fputs("xplan: display_pert_callback: MENU_NOTIFY\n", stderr);
a605 1
		fputs("xplan: display_gantt_callback: MENU_NOTIFY\n", stderr);
d638 1
a638 1
		fputs("xplan: find_critical_path_callback: MENU_NOTIFY\n", stderr);
d672 1
a672 1
		fputs("xplan: check_dependencies_callback: MENU_NOTIFY\n", stderr);
d678 133
@


1.1
log
@Initial revision
@
text
@d15 1
d20 1
d39 7
d79 1
a79 1
		
a113 4

		xv_set(PERT_pertPopup->pertPopup, FRAME_CMD_PUSHPIN_IN, TRUE, NULL);
		xv_set(PERT_pertPopup->pertPopup, XV_SHOW, TRUE, NULL);
		
a142 3

		xv_set(Gantt_ganttPopup->ganttPopup, XV_SHOW, TRUE, NULL);
		
d228 5
a232 3
						0, 0, 0, 0, 0,
						0, 0, 0, 0, 0, 0, 0,
						0, 0, NULL, NULL,
d315 5
a319 3
						0, 0, 0, 0, 0,
						0, 0, 0, 0, 0, 0, 0,
						0, 0, NULL, NULL,
d322 1
a322 1
		
d397 5
a401 3
						0, 0, 0, 0, 0,
						0, 0, 0, 0, 0, 0, 0,
						0, 0, NULL, NULL,
d474 5
a478 3
						0, 0, 0, 0, 0,
						0, 0, 0, 0, 0, 0, 0,
						0, 0, NULL, NULL,
d586 134
@
