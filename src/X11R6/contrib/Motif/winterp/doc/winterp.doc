-*-Outline-*-





			     =================
			     = W I N T E R P =
			     =================

       T H E   O S F / M O T I F _W_I D G E T _I_N_T_E_R_P_R E T E R

	  An interactive object-oriented user interface language for
	  rapid prototyping, development and delivery of extensible
	  applications with Motif GUIs and Xtango graphics/animation.


			       Version 2.01


			       June 8, 1994


				    by
			      Niels P. Mayer




			Mailing Address:
			     Enterprise Integration Technologies
			     800 El Camino Real, Fourth Floor
			     Menlo Park, CA 94025
			     
			E-Mail Address:
			     mayer@netcom.com or mayer@eit.com

			URL:
			     http://www.eit.com/people/mayer.html




















$Header: /disk3/npm/src/winterp/doc/RCS/winterp.doc,v 2.12 1994/06/09 01:46:21 npm Exp $


* Acknowledgements:

** Many Thanks to 

***	Allan Kuchinsky, Allan Shepherd, Martin Griss at Hewlett-Packard
	Laboratories, Palo Alto, for their support and management
	throughout my career at Hewlett-Packard Laboratories. Special
	thanks to Allan Kuchinsky for loaning me an HP9000s380 workstation
	used to develop much of	WINTERP 2.0, and for letting me work on
	WINTERP while employed at HP.

***	Jay Glicksman, Glenn Kramer, and J. Marty Tenenbaum at Enterprise
	Integration Technologies for their support and interest in WINTERP.

***	David Betz, Tom Almy and other comp.lang.lisp.x contributors for XLISP
	and XLISP-PLUS.

***	John Stasko and Doug Hayes for the Xtango animation/graphics library.

***	Luis Miguel and Doug Young for the XmGraph widget.

***	David Harrison, Martin Brunecky, and Kee Hinckley for the Table widget.

***	Don Libes, for the expect library.

***	Alfred Kayser, John Bradley and Patrick J. Naughton for GIF code.



Copyright (C) 1994, Enterprise Integration Technologies Corp. and Niels Mayer.
WINTERP 1.15-1.99, Copyright (c) 1993, Niels P. Mayer.
WINTERP 1.0-1.14, Copyright (c) 1989-1992 Hewlett-Packard Co. and Niels Mayer.

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation, and that the name of Enterprise Integration Technologies,
Hewlett-Packard Company, or Niels Mayer not be used in advertising or
publicity pertaining to distribution of the software without specific,
written prior permission. Enterprise Integration Technologies, Hewlett-Packard
Company, and Niels Mayer makes no representations about the suitability of
this software for any purpose.  It is provided "as is" without express or
implied warranty.

ENTERPRISE INTEGRATION TECHNOLOGIES, HEWLETT-PACKARD COMPANY AND NIELS MAYER
DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE AND DOCUMENTATION,
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
EVENT SHALL ENTERPRISE INTEGRATION TECHNOLOGIES, HEWLETT-PACKARD COMPANY OR
NIELS MAYER BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE AND
DOCUMENTATION


* Introduction

** Why a Widget INTERPreter?

WINTERP is an interpretive, interactive environment for rapid prototyping
applications using the OSF Motif UI Toolkit. The name "WINTERP" stands for
Widget INTERPreter, and that's exactly what WINTERP is -- an interpretive
language that allows programmers to interactively create interfaces using
the capabilities of the Motif widgets and the X11 toolkit intrinsics.
Widgets in the Xtoolkit are dynamic and "interpretive" by nature of their
object-oriented, message passing style of design; they become maximally
useful when driven by an interactive environment like WINTERP.

Neither traditional C Xtoolkit applications, nor UIL applications really
take advantage of the interpretive nature of the Xtoolkit. When programming
in C, one is forced to go through tedious compile+edit+test cycles even for
making a trivial change. X and the Xtoolkit provide a fancy widget resource
manager that allow you to shorten the compile+edit+test cycle -- the
Xtoolkit "reinterprets" its resource settings as a whole each time the
application is brought up; compile+edit+test is shortened to edit+test.
UIL extends the level of data-interpretation a little bit further by
allowing the system to read a structured description of the widget
hierarchy and resources. UIL claims this will allow applications to be
written in such a way that the interface can be drastically altered by
changing the description file. In reality, only the most trivial sorts of
layout changes are possible with UIL because it is not a programming
language, and thus cannot allow you alter the program semantics that are
invariably intertwined with the semantics of the user interface.
Furthermore, UIL still uses compilation, rather than interpretation, which
means application prototyping is still as tedious as ever.  WINTERP
provides both an interpretive interface to the Xtoolkit widgets, and a real
programming language -- this makes it ideal for prototyping and/or
customizing the layout, look, AND functionality of an application.

WINTERP's interpreter is based on David Betz's popular XLISP, a small,
fast, C-implemented interpreter with Common Lisp syntax and extensions for
object oriented programming. Full-blown Lisp systems such as Common Lisp
have proven to be very effective prototyping environments and are commonly
used as platforms for building User-Interface Management Systems (UIMS).
WINTERP attempts to deliver the advantages of Lisp to those that cannot
afford the expenses, both monetary and computational, of large systems like
Common Lisp.

Lisp is traditionally associated with unwieldy, large, slow and expensive
systems -- Lisp's flexibility has its costs. One solution to these
problems has been to create special operating systems and hardware to
better support Lisp: The Lisp Machine -- a very expensive, and very
specialized system.  Lisp Machines are losing ground to the general purpose
workstation running UN*X: such machines can be built at relatively low cost
with enough compatibility between vendors that a growing number of UN*X
applications can be run on a variety of hardware vendor platforms.
Unfortunately, attempts at building Lisp-based applications that are good
citizens on UN*X workstations have generally failed because systems such as
Common Lisp (CL) create huge, resource-hungry processes that swap/thrash
out all other applications -- not acceptable if you are trying to create an
application that works alongside other applications running in a
multiprocessing system like UN*X.  While CL platforms will continue to make
excellent prototyping platforms, delivery of applications embedded in a CL
environment is unacceptable. Attempts at recoding CL prototypes under a
delivery platform (e.g. just using UN*X & C) is time consuming, and changes
the feel and the flexibility of an application: applications prototyped
with Common Lisp assume and make use of the underlying features of the Lisp
system; these assumptions must be removed from the design or be recoded in
the delivery language.

Fortunately, another class of Lisp application has been successful in a
general purpose computational environment -- a hybrid architecture of Lisp
and C giving the flexibility of a Lisp system while allowing delivery of a
relatively small and efficient process. Under UN*X, Richard Stallman has
created a highly-customizable editor-based programming environment called
GNUEMACS -- this is a system that delivers to the UN*X user a text editor
oriented UI that is the foundation of the Lisp Machine programming
environment. Similarly, under MSD*S successful programs like AUTOCAD
contain a Lisp customization language embedded in a CAD program.  The
approach taken by such hybrid applications is that a small mini-Lisp
interpreter serves to "glue" together efficient C-implemented primitives
that make up an application.  User-customization and prototyping under such
a hybrid system amounts to using the Lisp interpreter to reconfigure
C-implemented building blocks in order to change, modify, or improve the
functionality of the system. Such an application architecture follows the
"80/20 heuristics" for program execution -- low level routines that take up
most of the computational resources are coded in C, and are therefore fast,
and efficient in memory use (no garbage collections caused by low-level
code). The Lisp interpreter is relatively slow in comparison to a compiled
C program, but it only serves to flexibly glue together components of the
"outer loop" of a program.

WINTERP was written as a platform for building such hybrid Lisp/C systems;
XLISP makes this possible because, unlike large Common Lisp systems,
integrating arbitrary C-implemented functionality with the Lisp interpreter
is easy.  WINTERP itself is an example of the feasibility of hybrid
programming techniques -- WINTERP's X/Motif functionality is achieved
through XLISP interfaces to the C-implemented Motif toolkit. WINTERP is
thus aimed at the class of application that cannot afford to carry along
all the excesses of Common Lisp, but does require an embedded programming
language for user-customization.

WINTERP supports an evolutionary program lifecycle: WINTERP application
writers will rapidly prototype new functionality by using the mini-Lisp
interpreter to interactively refine the layout, looks, and functionality of
the user interface.  Once functionality has stabilized, a programmer will
be able to improve the application's efficiency by reimplementing the
functionality in C while maintaining the same Lisp programmatic interface
to the rest of the system. These new primitives will then serve as the
building blocks for the next layer of prototyping and customization... The
end result, if designed carefully, is a relatively small and fast
application that provides the right set of building blocks and hooks to
permit end-users to customize the look and feel of the application.

WINTERP is also useful for rapid prototyping applications that do not need
to be delivered with an embedded customization language. Systems with such
delivery goals may still use the aforementioned application lifecycle. As
the application matures and Lisp prototype code stabilizes, the program can
gradually be recoded entirely into C, eventually allowing a "normal" C
program to be delivered.


** Why I built WINTERP:

I originally built WINTERP as a platform for designing, building, and
evaluating Computer Supported Cooperative Work (CSCW) and Collaborative
Multimedia Systems. The usefulness of such systems can rarely be
demonstrated by demoing "laboratory curiosity" applications; evaluating
such technologies requires applications be delivered to early adopters of
the technology with a minimum of extraneous overhead (e.g. runtime
licenses, huge systems) and that the delivered application be customizable
so that it can be integrated into the environment of a particular
workgroup.

One example of such a system using WINTERP as platform is the STRUDEL
extensible e-mail-based groupware system described in:
        Allan Shepherd, Niels Mayer, and Allan Kuchinsky.  STRUDEL: An
        Extensible Electronic Conversation Toolkit. In David Marca and
        Geoffrey Bock, editors, GROUPWARE: Software for Computer-Supported
        Cooperative Work, IEEE Computer Society Press, 1992, pp. 505-518.
        (originally, in proceedings Conference on Computer-Supported
        Cooperative Work, Los Angeles, October 1990, pp.  93-104.)

In STRUDEL, WINTERP's Lisp interpreter and Motif U.I. primitives provide
the language for creating and processing active/graphical e-mail
forms. Such forms can be sent (as textual programs) through standard e-mail
channels, and the receiving STRUDEL system will interpret the WINTERP-Lisp
forms description language and display a form letter containing a user
interface built from arbitrary combinations of widgets, bitmaps, and
text. Users choose from a library of email forms that are designed to track
specific types of conversations -- scheduling meetings and resources,
software defect tracking, fleshing out design issues, etc.  Workgroups can
extend the library of forms to help capture and manage recurrent
conversations that are not covered by STRUDEL's standard forms library.

Currently a small team of EIT engineers including myself are using WINTERP
to create a multimedia authoring environment for creating World Wide Web
(e.g.  Mosaic) documents. The system provides an internet publishing system
for people wanting to do on-line catalogs, on-line information services,
and shared design notebooks as required by the members of the EIT's
CommerceNet joint venture. It provides "two-view" ("WYSIWYG" and
structure/outline) editing of HTML documents, and makes use of SGI
IndigoMagic desktop drag and drop for composing multimedia elements.

For details, see the upcoming publication:
	Jay Glicksman, Glenn Kramer, and Niels Mayer. "Internet Publishing
	via the World Wide Web". In proceedings Groupware '94,
	August 1994. San Jose, CA.



** Why XLISP?

I implemented WINTERP on top of XLISP because it is reliable, small, and
free, thus allowing delivery of applications such as STRUDEL (see above)
with a minimum of overhead (licenses, slow systems requiring specialized
hardware) to potential early adopters of groupware technologies. XLISP has
been around since 1985, and has evolved considerably since it first
appeared publicly; because it has been in use for some time it has also
had most bugs shaken out of the system through widespread use. Furthermore,
the newsgroup comp.lang.Lisp.x has been an effective channel for exchanging
information and patches to XLISP. XLISP was designed to be run on PC's;
because it was designed with a limited environment in mind, it has turned
out to be quite fast and memory-efficient while remaining portable across
a variety of architectures ranging from 16 bit PC's to workstations.  And
of course, XLISP's simple object system has enabled an elegant interface to
the object oriented structure of the Xtoolkit and the Motif widgets.
Finally, XLISP is free, thanks to the generosity of David Betz.

Many people have asked "Why not scheme?", or "why not emacs-Lisp?"... the
above paragraph should answer that. David Betz's XSCHEME might be a good
choice nowadays, but when I was developing WINTERP it was still under
development, and would not be a good choice as a stable platform. Even now,
XSCHEME does not (yet) have the debugging capabilities of XLISP.  Other
Scheme implementations were too large, and too complicated to work with
given the sorts of changes I needed to make. GNUEMACS' emacs-Lisp fit the
bill in many ways, but unfortunately the code is very intertwined with
GNUEMACS' editor functionality, and the Free Software Foundation's Copyleft
is far too restrictive to be used in potential products built from
WINTERP's technology.

"Professional" Common-Lisp systems have many nice features, but
unfortunately, they are big, slow, expensive, and make bad delivery
platforms.  Most CL systems do not come with source code, which makes it
difficult to alter the way these systems work in significant ways (as I
have done with XLISP in WINTERP). Even with source code, CL impedes the use
of hybrid programming techniques mentioned above -- CL systems are often
only implemented in C at the lowest levels, thus making it difficult to
patch in high-level C-implemented functionality that can be used
transparently from Lisp. Finally, "professional" Common Lisp programs
cannot be distributed for free -- this means that potential early adopters
of new technologies would have to pay CL license fees, attach codeword
modules to their computers (to ensure that license fees have been paid),
and other such "hassles". People eager to try out new technologies may have
second thoughts about becoming "early adopters" if they have to spend money
and time (convincing their management to give them the money and time ...)
in order to try out "heavyweight" experimental software.


** Interactive GUI programming with WINTERP -- the XLISP eval server.

When running a Winterp-Lisp application "script", the WINTERP program runs
just like a normal C and Motif program under X windows. The advantage
WINTERP has over other user-interface pseudo-languages (like Motif's UIL or
Brunecky&Smythe's WCL) is that you can interactively create or modify user
interfaces while one's application is up and running. This is essential for
rapid prototyping; this is the reason why WINTERP is a rapid prototyping
environment and UIL and WCL aren't.

Many other UI languages including many Lisp interfaces to X (CLX, Garnet,
etc), have separate "modes" for when they are responding to X and
evaluating language input. The problems with such systems is that they do
not allow for interactive prototyping -- when X is active, programmatic
changes cannot be made, and when the language-evaluator is active,
programmatic changes cannot be visualized. WINTERP allows for interactive X
programming because its language-input is implemented via a server socket;
programmatic input is treated as an event that is dispatched from the X
event loop.  The clients of WINTERP's evaluation server are
editors/programming-environments such as GNUEMACS, or any other program
running on other UN*X machines on a network.  Such capabilities are
extremely useful in allowing "remote procedure calls" (RPC) to a
WINTERP-based application.

The GNUEMACS editor provides a very elegant and useful environment for
editing Lisp programs and interacting with WINTERP's Lisp eval-server.
Emacs' Lisp-mode will automatically indent your code
(Control-Meta-Q == indent-sexp) and help you catch unmatched
parentheses. The file ./../src-client/winterp.el extends Emacs' Lisp-mode
by providing a command that allows you to send the current Lisp form you
are editing off to WINTERP for evaluation. This allows truly interactive
programming because you need not exit the editor to see the results of your
"program"; with WINTERP's emacs interface, each fragment of Winterp-Lisp
code written into the editor can, at the touch of a button, be evaluated;
programmatic changes affecting the user-interface can be visualized
immediately. Note that WINTERP is architecturally separate from the
GNUEMACS editor -- interfaces to other editors are possible, but are not
provided in the standard WINTERP distribution.

(I strongly recommend that those that don't know how to use Gnu-Emacs
should learn how -- you'll never be sorry, and besides, Emacs is really the
only editor appropriate for doing Lisp programming. Even commercial Common
Lisp vendors tend to use Gnu-Emacs as the preferred editing environment for
their products, simply because Gnu-Emacs is the best Emacs implementation
running on Unix. Another big advantage to gnu-emacs is that it runs under
Xwindows directly, which means that you can select the Winterp-Lisp
expression you want to evaluate by pointing at it with the mouse...  For
those that do not have Gnu-Emacs on their systems, or who do not want to
learn Gnu-Emacs to use WINTERP, a rudimentary alternative is provided: see
the Winterp-Lisp file ./../examples/w_ctrlpnl.lsp as well as the
descriptipon of the WINTERP Control Panel Below.)

The WINTERP distribution contains a simple client program 'wl' (in
./../src-client/wl) which sends the Lisp s-expression given on its command
line to the Lisp server for evaluation. 'wl' may be embedded in other
programs that need to talk to WINTERP-based applications. 'wl' can also be
called (e.g., via system(2)) from such programs -- that is essentially how
WINTERP gets gnuemacs to talk to it when using the Emacs-Lisp interface
./../src-client/winterp.el.

WINTERP's RPC capabilities can enable better tool integration: different
tools in one's environment can easily communicate with an application built
upon WINTERP. Furthermore, multiple WINTERP applications across a network
may intercommunicate with each other, exchange data, etc using these
facilities (see 'wl-tcpip').


* Prerequisites and Assumptions.

This documentation assumes that you understand object oriented programming
concepts, understand the rudiments of Lisp programming, and know how to
make application user-interfaces using the Xtoolkit.  If not, you should be
able to learn things quite easily by studying and interactively evaluating
the various bits of Winterp-Lisp code in the ./../examples directory.

For documentation on XLISP features see the files ./../doc/xlisp.doc,
./../doc/XlispRef.doc and ./../doc/XlispOOP.doc .

This guide assumes that you already have documentation on Motif and the
Xtoolkit. A good overview of programming with widgets is Doug Young's "X
Window Systems: Programming and Applications with Xt."  I also expect that
you have the Motif programming guide, the Motif manual pages, etc.  This
document will hopefully allow you to understand how to translate the
examples and topics discussed in those programming guides into
WINTERP-Lisp.

Names in Xtoolkit and Motif contain mixed case. Since XLISP symbols are
case-insensitive, all the Motif/Xtoolkit names in WINTERP contain an
underscore in place of a lowercase-to-uppercase transition in the name, eg,
xmPushButtonWidgetClass becomes XM_PUSH_BUTTON_WIDGET_CLASS, and the
resource XmNinput becomes :XMN_INPUT. All the Xtoolkit/Motif C names are
listed in close proximity to the Winterp-Lisp names for equivalent
functions. Therefore, to look up the Xtoolkit name "XtFoo", use your editor
to search (in Gnu-Emacs, use i-search) for occurences of "XtFoo" in this
document. This document is written in plain-text so as to make it easier to
use on-line -- if you are viewing it in emacs, you will find some of the
outline-mode commands useful.

WINTERP version 2.0 Supports OSF/Motif 1.2.3, OSF/Motif 1.1, and 1.1.3.  It
might still support Motif 1.0, but I haven't tested it. Different features
in these versions of Motif are enabled via #ifdefs in the source code.
This document is also "#ifdef'd" so as to indicate which names and
functionality apply to Motif 1.0, and to indicate new functionality brought
on by Motif 1.1, 1.2, etc. Descriptions in this document that apply only to
Motif 1.1 (and Motif 1.1.1) are bracketed by "#ifdef MOTIF_1.1" and "#endif
/* MOTIF_1.1 */".  Description pertaining only to Motif 1.0 are bracketed
by "#ifdef MOTIF_1.0" and "#endif /* MOTIF_1.0 */". Additionally, other
optional functionality is switched by other #ifdefs in the source.  This
documentation reflects those #ifdefs as well, so that you can know what
features of WINTERP correspond to the features compiled into your WINTERP.
For example, the following #ifdefs are used in this document
SGI_DROP_POCKET_WIDGET, WINTERP_TABLE_WIDGET, WINTERP_XTANGO_WIDGET,
HP_GRAPH_WIDGET, WINTERP_EXPECT_SUBPROCESS.

==============================================================================

* Setting up and running WINTERP:

** Install the 'WINTERP' distribution:

	Pick up the latest WINTERP distribution via anonymous ftp from
	host ftp.x.org. do "cd /contrib/devel_tools" and "binary"
	and retrieve ('get') the latest WINTERP distribution, which will be
	available as file winterp-2.xx.tar.Z and/or winterp-2.xx.tar.gz.
	Back on your system, as root cd to /usr/local and do
		zcat winterp-2.xx.tar.Z | tar xvf -
	or if you got a .gz (Gnu Zip) file, do:
		gunzip -c winterp-2.xx.tar.gz | tar xvf -

	The preferred default location for installing the entire
	WINTERP distribution is in /usr/local/winterp. If you can,
	please install the WINTERP distribution in that location (that is,
	uncompress/untar the tar file while cd'd to /usr/local/).

	There are some settings in the configuration of WINTERP
	which assume you've put the distribution in /usr/local/winterp;
	in particular, you should at least install the following
	directories from the WINTERP distribution:
		/usr/local/winterp/examples/*.lsp
		/usr/local/winterp/examples/interactive/*.lsp
		/usr/local/winterp/examples/lib-utils/*.lsp
		/usr/local/winterp/examples/lib-widgets/*.lsp
		/usr/local/winterp/examples/xlisp-2.1d/*.lsp
		/usr/local/winterp/examples/xtango/*.lsp
		/usr/local/winterp/doc/*
		/usr/local/winterp/src-client/*

	If you decide you must install WINTERP elsewhere, you must
	at least tell WINTERP where the "examples" directory is
	located. Assuming <winterp-top-dir> is the location for
	the top-level of the WINTERP distribution, you must
	set resource
		"Winterp.lispLibDir: <winterp-top-dir>/examples/"
	Alternately, you may specify the command-line argument
		"-lib_dir <winterp-top-dir>/examples/"
	each time you run 'winterp'.

	Note that the ".lispLibDir" resource is set to
	/usr/local/winterp/examples/ in the application default
	file <winterp-top-dir>/src-server/Winterp.ad. If you install that
	application default file and your <winterp-top-dir> is not
	/usr/local/winterp then you *MUST* edit the application-default file,
	setting the ".lispLibDir" resource to the appropriate value. See
	<<Set up X resources and application defaults files>> for details.

** Compiling and installing WINTERP via Imakefile and 'xmkmf':

*** Compiling:

	If your system is set up appropriately, has Motif headers and
	libraries (version 1.1 or 1.2, preferably >= 1.1.4, or >= 1.2.3),
	and has xmkmf/imake configured correctly for Motif, you should be
	able to build a working WINTERP with the following:
		cd <winterp-top-dir>
		xmkmf
		make World
	(note, after doing "make World" you may do further compilations
	without remaking the makefiles by just doing "make")

*** Install 'winterp' and 'wl' executables, manual pages, app-defaults:

	If compilation was successful, do
		make install
		make intall.man
	to install the 'wl' 'winterp' binaries, the Winterp.ad application
	defaults file, and the 'winterp' 'wl' and 'wl-tcpip' manual pages.
	The places where the software is installed is dependent on your
	imake/xmkmf configuration.

	******************************************************************* *
	* IMPORTANT NOTE: IF <winterp-top-dir> IS NOT INSTALLED IN          *  
	* /usr/local/winterp, THEN YOU MUST SET RESOURCE Winterp.lispLibDir *
	* IN THE WINTERP APPLICATION DEFAULTS FILE THAT WAS INSTALLED ABOVE *
	* VIA 'make install'. SEE <<Install the 'WINTERP' distribution:>>   *
	* FOR DETAILS.                                                      *
	*********************************************************************

*** Forcing Imake to work with Motif:

	Some manufacturers actually provide complete working systems!  SGI's
	Irix 5.2 'mmkmf' (Motif 'xmkmf') and DEC's OSF1 'xmkmf' will actually
	build Motif programs like WINTERP without requiring any configuration
	edits whatsoever.

	Other manufacturers will require you to either update your xmkmf/imake
	system to include Motif header and library file paths.  Some systems
	(HP) don't provide xmkmf/imake at all, and this may force you to use
	the X Consortium xmkmf/imake, which doesn't know anything about
	Motif. Finally, some systems (e.g.  Sun, prior to Solaris 2.3) don't
	include Motif, forcing you to install Motif separately from the rest
	of your X -- this again may mean that your imake won't know where your
	Motif is installed.

	If your system places Motif headers and libraries in locations other
	than your compiler/linker's default search paths, then you will need
	to (1) update your imake configuration files to handle paths to Motif
	libraries and headers; or (2) modify some of the 'Imakefile's in
	WINTERP, specifying:
	    SYS_LIBRARIES -- specify Motif libraries and compatible X Xt libs.
	    INCLUDES      -- paths to Motif/X/Xt headers.

	See WINTERP's Imakefiles for examples of how this is handled.  For
	example, HPUX places Motif in unusual locations. To handle that, note
	the sections in the Imakefiles within "#ifdef HPArchitecture".
	<winterp-top-dir>/src-server/Imakefile sets SYS_LIBRARIES specially if
	it notices you're compiling on HPUX. All the other Imakefiles also
	contain "#ifdef HPArchitecture" sections to special case the setting
	of the include search path via "INCLUDES":
		<winterp-top-dir>/src-server/Imakefile
		<winterp-top-dir>/src-server/widgets/Imakefile
		<winterp-top-dir>/src-server/xlisp/Imakefile
		<winterp-top-dir>/src-server/xtango/Imakefile

	Please see <<Porting to other systems:>> and <<Compilation problems?>>
	for further details on compilation.

*** Compilation options:

	To add/remove WINTERP compilation options, you should edit
	<winterp-top-dir>/src-server/Imakefile and then redo everything:
		cd <winterp-top-dir>
		xmkmf
		make World
	Propagation of your compilation option settings in Imakefile will only
	take place if you do the complete 'xmkmf' and 'make World' sequence.

	The compilation options are documented directly in the Imakefile.
	See the comments (XCOMM) in <winterp-top-dir>/src-server/Imakefile
	for further information on the following compilation options:
		WANT_DROP_POCKET_WIDGET		= -DSGI_DROP_POCKET_WIDGET
		WANT_TABLE_WIDGET		= -DWINTERP_TABLE_WIDGET
		WANT_XTANGO_WIDGET		= -DWINTERP_XTANGO_WIDGET
		WANT_XMGRAPH_WIDGET		= -DHP_GRAPH_WIDGET
		WANT_EXPECT_SUBPROCESS		= -DWINTERP_EXPECT_SUBPROCESS
		WANT_INET_SERVER		= -DWINTERP_WANT_INET_SERVER
		WANT_UNIX_SERVER		= -DWINTERP_WANT_UNIX_SERVER
		WANT_STDIN_SERVER		= -DWINTERP_WANT_STDIN_SERVER
	

** Compiling and installing WINTERP via Makefile.* and 'make':

*** Compiling:

	To compile WINTERP, go to directory <winterp-top-dir> and execute
		'make -f Makefile.<arch>'
	where Makefile.<arch> represents a machine-specific makefile:

	Makefile.solar -- Sun4 running Solaris 2.3 with 2.3 SDK (C compiler,
			  X11, and Motif-1.2 development environment)
	Makefile.sun4  -- Sun4 running SunOS 4.1.3 and Sun's 'cc' (Note:
			  since SunOS doesn't include Motif nor a standard
			  X11, you'll need to install Motif/X11r5 and 
			  modify these makefiles, setting INCLUDES
			  and LIBS appropriately for your installation of
			  Motif and X11.)
	Makefile.sungc -- Sun4 running SunOS 4.1.3 and GNU 'gcc'. (Note:
			  since SunOS doesn't include Motif nor a standard
			  X11, you'll need to install Motif/X11r5 and 
			  modify these makefiles, setting INCLUDES
			  and LIBS appropriately for your installation of
			  Motif and X11.)
	Makefile.irix5 -- SGI running Irix 5.2 w/ Iris Development Option 5.2
			  (SGI's X/Motif-1.2/cc environment).
	Makefile.osf1  -- DEC Alpha running OSF1 v 2.0 with DEC's X/Motif (1.2)
			  and C development environment.
	Makefile.Ultrx -- DEC DECStation running Ultrix 4.3 and DEC's
			  X/Motif (1.1) and C development environment.
	Makefile.NeXT  -- NeXT-Step 3.0 running Pencom's Co-Xist X/Motif
			  (1.2) environment.
	Makefile.hpux9 -- HP 9000-s[378]00 running HPUX 9.X and HP's
			  X/Motif (1.2) and C development environment.
	Makefile.hpux8 -- HP 9000-s[378]00 running HPUX 8.X and HP's
			  X/Motif (1.1) and C development environment.

*** Install 'winterp' and 'wl' executables:

	Install the 'winterp' and 'wl' binaries somewhere on your UN*X
	execution path ($PATH). For example, if /usr/local/bin/ is on your
	$PATH, you can do the following:
		cd <winterp-top-dir>/src-server
		make -f Makefile.<arch> install ##or "cp winterp /usr/local/bin"
		cd <winterp-top-dir>/src-client
		make -f Makefile.<arch> install ##or "cp wl /usr/local/bin"

	You may want to install the manual pages in the appropriate man-page
	directory on your system. WINTERP includes the following manual
	pages in <winterp-top-dir>/doc/:
		winterp.man, wl.man, wl-tcpip.man, libexpect.man, XmGraph.man,
		XmArc.man.
	(xmkmf/imake "make install" installs winterp.man, wl.man, and
	 wl-tcpip.man  by default).

	See <<Set up X resources and application defaults files:>> for hints
	on installing the WINTERP application default file located at
	<winterp-top-dir>/src-server/Winterp.ad. Xmkmf/imake compilation
	"make install" installs Winterp.ad appropriately.

*** Porting to other systems:

	WINTERP should compile on any Unix system that supports X, Motif,
	and sockets. Previous versions of WINTERP have been reported to
	run on 
		** HPUX, for s3xx, s4xx, s7xx, and s8xx architectures
		** SGI Irix 5.X.
		** AIX 3.X
		** Ultrix.
		** SunOS 4.1 on Sun 4 or Sun 3 architecture.
		** Solaris.
		** NeXT.
		** Data General AViiON (m88k, DG/UX 4.30, GNU C 1.37.23)
		** Intel System V3.2
		** Apollo Domain
		** Harris Nighthawk, etc.

	To attempt compilation on systems other than the systems for which a
	Makefile.<arch> exists, you should use the aforementioned
	Makefile.<arch> as a "template" for constructing a new makefile
	apprpriate for your system.  Alternately, you may have better luck by
	using xmkmf/imake as discussed in
	<<Compiling and installing WINTERP via Imakefile and 'xmkmf':>>.

	Pick machine type as a prototype for your template -- for example
	Makefile.solar might be a good starting point for a SYSVR4 system,
	whereas Makefile.sunos might be a good starting point for a BSD
	based system. Lets call that template file Makefile.<org>
	and the Makefile for the new system you're porting to Makefile.<new>.

	First, copy the following files:
	<winterp-top-dir>/Makefile.<org>
		to <winterp-top-dir>/Makefile.<new>
	<winterp-top-dir>/src-client/Makefile.<org>
		to <winterp-top-dir>/src-client/Makefile.<new>
	<winterp-top-dir>/src-server/Makefile.<org>
		to <winterp-top-dir>/src-server/Makefile.<new>
	<winterp-top-dir>/src-server/expect/Makefile.<org>
		to <winterp-top-dir>/src-server/expect/Makefile.<new>
	<winterp-top-dir>/src-server/widgets/Makefile.<org>
		to <winterp-top-dir>/src-server/widgets/Makefile.<new>
	<winterp-top-dir>/src-server/xlisp/Makefile.<org>
		to <winterp-top-dir>/src-server/xlisp/Makefile.<new>
	<winterp-top-dir>/src-server/xtango/Makefile.<org>
		to <winterp-top-dir>/src-server/xtango/Makefile.<new>

	In each Make-file you will have to modify the Make variable MAKEFILE,
	changing "Makefile.<org>" to "Makefile.<new>". Additionally, you may
	have to modify the Make variables OSDEP_CFLAGS, INCLUDES, and for
	<winterp-top-dir>/src-server/Makefile.<new> you'll also need to set
	LIBS. See comments in the makefiles for details on those variables.

	If your system can run in a SYSV versus BSD "world" you should compile
	assuming BSD, due to WINTERP's useage of sockets. You might want to
	do this for Apollo Domain, MIPS, or AIX. For example, AIX 3.1 requires
	that you add "-D_BSD" to OSDEP_FLAGS, and add -lbsd to "LIBS".

	If you've tested/run WINTERP on a new architecture/os and have a new
	set of Makefiles for that architecure/machine, please mail your
	makefiles to the WINTERP mailing list at winterp@netcom.com.

*** Compilation problems?

	If you have problems compiling WINTERP on your machine, please send
	your queries to the WINTERP mailing list at winterp@netcom.com.
	
	In your mail, you should include prcise details regarding the problem,
	or failing that, at least contains a copy of the error-output from
	compilation, link, or runtime. And be sure to tell exactly what kind
	of hardware and operating system platform you are using, as well as
	the Motif version and patchlevel, etc.
	
	I've received a lot of mail from people whose problems stemmed from
	the fact that they had never compiled Motif applications on their
	machine before.  Please do not send me (or the WINTERP mailing list)
	mail asking how to build your first Motif program because (1) I don't
	have the time to be a free Motif consultant; (2) My schedule is such
	that I may not be able to get back to you within a timeframe that you
	might consider "soon enough." Please remember that this is free
	software -- I try to support it as best I can, but you should look at
	it as unsupported, or at least erratically supported software.
	
	If you have a compilation problem, please, at least, make sure that
	Motif libraries (version 1.1, or 1.2) are installed on your machine.
	Beyond that, at least take some time to verify that the errors you are
	seeing are not a result of mis-compilation. Typical problems include
	
		* Using the wrong X or Motif headers;
		* Having incompatible versions of the Xtoolkit and Motif
		  headers/libraries. (see Make-file variable LIBS and
		  INCLUDES);
		* Having incorrect values for C pre-processor symbols
		  (see Make-file variable OSDEP_CFLAGS);
		* Having incorrect C compiler flags (see OSDEP_CFLAGS).
	
	If you have not compiled a Motif program on your system, then you
	should try compiling an existing, known-working 10-50 line Motif C
	program.  You should be able to at least find a few Motif C examples
	in your vendor's distribution of Motif -- these can be especially
	useful because the Makefiles will tell you which Makefile variables
	need to be customized for your particular vendor's hardware and
	software., e.g.  OSDEP_CFLAGS, INCLUDES, and LIBS.
	
	If you are using Motif source straight from OSF (rather than a
	vendor-supplied library), you should find such example programs in the
	Motif distribution. Alternately, take a look at the Imake
	configuration files to figure out which OSDEP_CFLAGS, INCLUDES, and
	LIBS need to be set in WINTERP's Makefiles.

*** Compilation options:

	To add/remove WINTERP compilation options, you should edit
	the appropriate	<winterp-top-dir>/src-server/Makefile.<arch> and then
	'make' again.

	The compilation options are documented directly in the Makefile.<arch>.
	See the comments <winterp-top-dir>/src-server/Makefile.<arch>
	for further information on the following compilation options:
		WANT_DROP_POCKET_WIDGET		= -DSGI_DROP_POCKET_WIDGET
		WANT_TABLE_WIDGET		= -DWINTERP_TABLE_WIDGET
		WANT_XTANGO_WIDGET		= -DWINTERP_XTANGO_WIDGET
		WANT_XMGRAPH_WIDGET		= -DHP_GRAPH_WIDGET
		WANT_EXPECT_SUBPROCESS		= -DWINTERP_EXPECT_SUBPROCESS
		WANT_INET_SERVER		= -DWINTERP_WANT_INET_SERVER
		WANT_UNIX_SERVER		= -DWINTERP_WANT_UNIX_SERVER
		WANT_STDIN_SERVER		= -DWINTERP_WANT_STDIN_SERVER

** Set up X resources and application defaults files:

	To get the author's preferred set of Motif resources, install the file
	<winterp-top-dir>/src-server/Winterp.ad into <app-defaults-dir>/Winterp
	where <winterp-top-dir> is typically /usr/local/winterp, and 
	<app-defaults-dir> is typically /usr/lib/X11/app-defaults. This
	installation is done by default if you've used xmkmf/imake and done a
	'make install' -- for details, see
	<<Compiling and installing WINTERP via Imakefile and 'xmkmf':>>.

	Alternately, you may just set up a private application-resource	file 
	for WINTERP by copying file 'Winterp.ad' to 'Winterp' and placing it
	somewhere on the path described by UN*X environment variable
	XUSERFILESEARCHPATH (See X(1) for details).

	NOTE: file Winterp.ad contains a full set of resource
	bindings for the Motif widget set, as preferred by the
	author. These settings include pointer focus (see
	"*keyboardFocusPolicy"), "emacs-like" bindings for the Text
	widgets, font settings (see *fontList ...), color settings (see
	"*background", "*foreground"), etc. Users of B&W X displays will
	definitely want to remove all the color settings in this
	file. Since only the "Winterp.*" bindings are Winterp-Specific, you
	may want to comment out all other bindings if your tastes in
	default Motif bindings are significantly different from mine...

	The following resources are critical for correct operation of WINTERP
	and must at least be set correctly in some resource file loaded by
	WINTERP (e.g. /usr/lib/X11/app-defaults/Winterp, ~/Winterp,
	~/.Xdefaults, etc) or through WINTERP's associated command-line settings
	(-lib_dir and -enable_unix_server).
	
	!! Note: change /usr/local/winterp/examples/ if you did not install
	!! the WINTERP distribution in the default location
	!! <winterp-top-dir>/ == /usr/local/winterp/
	Winterp.lispLibDir: /usr/local/winterp/examples/
	
	!! Default: Winterp.enableUnixServer: false
	!! You need to set this to true if you intend to use 'wl' or the GNU
	!! Emacs interface in <winterp-top-dir>/src-client/winterp.el
	Winterp.enableUnixServer: true

** ~/.winterp -- WINTERP session startup file: 

	To set up a default WINTERP session startup file, do:
		'cp <winterp-top-dir>/examples/00.winterp.lsp ~/.winterp'
	and edit and uncomment any variable values or environment setttings
	that you deem necessary. See comments in the file for details.	

	A user will have a ~/.winterp file if he/she has personal
	preferences or special environment settings differing from
	the default. Examples include the need to set system-wide
	variables, such as directories where important system files
	are kept, customizations and variable settings for any
	applications loaded into WINTERP, etc. As a minimum, this
	file should contain *AT* *LEAST*
		'(REQUIRE "lib-utils/initialize")'
	since that provides the expected default settings for WINTERP's
	XLISP environment.

	This file is loaded each time WINTERP is started up,
	setting up the user's default environment for WINTERP, for both the
	case of "standalone" and "interactive" operation. (WINTERP's modes
	of operation are described in <<Running WINTERP -- useage,
	command-line flags, application resources.>>, sections <Standalone
	mode:>> and <<Interactive mode:>>).

	If the user omits the ~/.winterp file (or that file causes an XLISP
	error) then WINTERP will load
	<winterp-top-dir>/lib-utils/initialize.lsp, which sets up a
	default WINTERP/XLISP environment. A warning message is issued
	for cases when ~/.winterp cannot be loaded, however, the system
	does not require this file to be present.
	

** ~/.winterpapp -- WINTERP development session startup file.

	To set up a default WINTERP development session startup file, do:
		'cp <winterp-top-dir>/examples/01.winterp.lsp ~/.winterpapp'
	and edit and uncomment/comment-out any variable values or
	environment setttings deemed necessary. See comments in the file for
	details.	

	~/.winterpapp contains the default development environment. This file
	is loaded each time WINTERP is started up without an initialization
	file as specified by X resource 'Winterp.lispInitFile' or command line
	argument '-init_file'; typically, when WINTERP is running
	without an initialization file, it means that it is being used as a
	development/prototyping environment (see <<Interactive mode:>> below). 

	The default ~/.winterpapp (<winterp-top-dir>/examples/01.winterp.lsp)
	loads the following files which are useful for WINTERP application
	development as well as general interactive use of WINTERP as an 
	application exectution environment:

		(require "lib-utils/redir-err")
		(require "lib-utils/err-hook")
		(require "w_ctrlpnl")

	"w_ctrlpnl" is a simple control panel for WINTERP providing a file
	browser for loading/editing/saving Winterp-Lisp files, and an editor
	allowing interactive evaluation of the s-expression under the editor
	cursor. Other editor commands include traversing forwards/backwards
	through s-expressions, and formatting your code. Other XLISP commands
	include control over the XLISP debugger and WINTERP/XLISP evaluation
	error dialogues. For details, see
	<<Interacting with WINTERP via the "WINTERP Control Panel":>>.

	"lib-utils/redir-err" pops up a dialog box any time error output
	gets sent to stderr. Typically, WINTERP runs under a terminal emulator,
	and any error output would appear there, potentially never
	to be seen by the user. Loading "lib-utils/redir-err"
	causes any such output to be immediately apparent to the user.
	This notification is especially useful when running subprocesses
	under WINTERP -- their stderr output is noticed by WINTERP.
	
	"lib-utils/err-hook" pops up a dialog box any time an XLISP evaluation
	error occurs. The dialog box contains an XLISP "trace back" (see
	baktrace command) allowing one to see where an evaluation error
	occurs.

	If the user omits the ~/.winterpapp file, WINTERP will issue a warning
	message, but will otherwise continue to run normally. Note that
	~/.winterp is loaded prior to loading ~/.winterpapp, thereby
	allowing any system-wide environment or variable settings to be made
	prior to loading any development environment application files.	
	(See <<~/.winterp -- WINTERP session startup file:>> for details.)

** Run WINTERP!:

	Assuming you've successfully compiled and installed WINTERP and also
	have set up WINTERP's configuration files correctly, as per
	<<Set up X resources and application defaults files:>>,
	<<~/.winterp -- WINTERP session startup file:>> and
	<<~/.winterpapp -- WINTERP development session startup file.>>
	you are now ready to run WINTERP. In particular, the following assumes
	that you've installed ~/.winterpapp so that WINTERP loads the
	"WINTERP Control Panel" (w_ctrlpnl) on startup.

	(1) Go to the WINTERP examples directory, which should be installed
	at /usr/local/winterp/examples -- "cd <winterp-top-dir>/examples"

	(2) go to a terminal emulator and type "winterp" to the shell.
	(Assumes that WINTERP has been installed and is on your directory
	search path $PATH). A startup message should be displayed, and
	the WINTERP control panel should pop up (assuming you've set up
	~/.winterpapp correctly).

	(3) In the "WINTERP Control Panel" file selection box, select a
	file, e.g. "fake-app1.lsp", via single left click on that item.

	(4) Click "Load File" button. The application's window should pop
	up shortly.

	(5) Continue selecting files in the file browser, then load them
	with "Load File" button. Some other interesting examples include:
		* <winterp-top-dir>/examples/bitmap-br.lsp:
		   Select a directory in the file browser and click "Browse Dir"
		   to get a browser of the selected directory of X bitmaps.
		   programmatically, one can create bitmap browsers by evaling
			(BROWSE-BITMAP-DIRECTORY <bitmap_directory_path>).
		* bitmap-br2.lsp: Similar to bitmap-br.lsp, except that simply
		   loading this file will bring up a browser of the bitmaps in
		   directory /usr/include/X11/bitmaps/*. Unlike bitmap-br.lsp,
		   this file contains comments on what is happening in this
		   simple application..
		* <winterp-top-dir>/examples/calculator.lsp: a simple
		   calculator. The layout on this example leaves much to be
		   desired. Shows a use of widget subclassing.
		* <winterp-top-dir>/examples/calendar.lsp:
		   Browser interface to unix 'cal' -- display a calendar.
		* <winterp-top-dir>/examples/dircmp.lsp:
		   A directory comparison browser. Select a directory in each
		   file selection box (must double-click on "Directories" list
		   entry on type in a new path into "Filter" and hit <return>.
		   Then click on "Compare Dirs." button. A list of files only
		   in directory-1, only in directory-2, and a list of different
		   files will appear. Double-click on an entry in "different
		   files" and a "diff" listing will appear in "Differences. 
		   Then double click on an entry in "Differences" and the
		   differing files will appear in the two text display areas,
		   with the difference line highlighted.
		* <winterp-top-dir>/examples/grep-br.lsp:
		   A file-search browser application that uses the unix
		   grep(1) program to search through files. Type the
		   string or regular expression for searching into the
		   XmText widget labeled "Search for string"; type the
		   set of wildcarded set of files into the XmText widget
		   labeled "From Files". After clicking on the "DO
		   SEARCH" push-button. The matching lines output by grep
		   will appear in the XmList widget. Double clicking on a
		   line in the XmList widget will display the file in the
		   XmText view-area widget, with the matching line
		   highlighted. In addition to being a useful, yet
		   simple, application, grep-br.lsp is also a good
		   example of subclassing Motif widgets inside WINTERP.
		   For example setting "Search Regexp" to "^(def" and
		   "Wildcarded Files" to "*.lsp" will return all lines
		   beginning with "(def" in the Winterp-Lisp files
		   specified by *.lsp (in the current directory).
		* <winterp-top-dir>/examples/helloworld.lsp:
		   10 lines of Winterp-Lisp code is all that is needed to
		   produce the canonical "Hello World" program in WINTERP.
		* <winterp-top-dir>/examples/mail-br.lsp:
		   Assuming you have the MH mailer installed and on your search
		   paths ("scan" in particular) and have mail in MH format
		   this application gives you a browser of the last 30 messages
		   in your MH +inbox. Double clicking on an entry in the list
		   will display the associated mail message in the text display
		   area.

** Some useful WINTERP development tools:

*** <winterp-top-dir>/examples/grph-whier.lsp:

	Load this file to display/inspect widget hierarchies created
	in WINTERP.  The name grph-whier.lsp stands for graphical
	widget hierarchy. After you bring up the application, click the
	"Show Widget Hierarchy Of..." button.  The cursor will become a
	cross-hair, indicating that you should click on some other
	WINTERP-generated window.  A tree of the widget hierarchy will
	subsequently be ppresented.  By clicking on the elements in the tree,
	one is given useful information on that widget, including:
		-- fully qualified X-resource name
		-- the associated widget-ID and parent widget-ID
		-- the widget's class and superclass
		-- dimensions of the widget
		-- instance variables on the widget (for inspecting
		   subclassed widgets).
		-- class variables on the widget.
		-- a list of methods available on the widget's class.
		   (doesn't list the superclass methods).

*** <winterp-top-dir>/examples/identifier2.lsp:

	Load this file to bring up a simple "Widget operations" panel. 
		* click on "Identify Selected Widget" then click the cross-hair
		  cursor on some WINTERP-generated widget. Information about
		  the selected widget will be printed to stdout, including
		  a fully qualified resource name that may subsequently be
		  used in setting up X-resource files for the selected
		  application.
		* Click on "Destroy Selected Widget" then click the cross-hair
		  cursor on some WINTERP-generated widget. The widget will
		  be destroyed. Use at your own risk -- using this could
		  potentially render some WINTERP-generated applications
		  useless.
		* Click on "Display Translations of Sel. Widget" then click the
		  cross-hair cursor on some WINTERP-generated widget.
		  Information on the translation tables of the selected widget
		  will be printed to stdout. This is useful for finding out
		  what bindings are available on a particular widget.
		* Click on "Display Accelerators of Sel. Widget" then click the
		  cross-hair cursor on some WINTERP-generated widget. This will
		  display the list of accelerators bound on the selected widget,
		  if any.
		* Type a string name of a color into "Set Foreground Color
		  of Selected Widget" or "Set Background Color of Selected
		  Widget" in order to change the colors on the selected widget.
		  After typing the color in, hit <return> and click the
		  cross-hair cursor on the desired WINTERP-generated widget
		  whose colors you want to alter.

*** <winterp-top-dir>/examples/grph-sexpr.lsp:

	Click on "graph methods of selected widget" then click the cross-hair
	on the widget whose methods you want to inspect. A tree display of
	each method's code on that widget is presented. This is only
	interesting on widgets containing Winterp-Lisp methods, e.g.
	click on the text editor widget in the WINTERP Control Panel.
	Can you say hack?

*** <winterp-top-dir>/examples/colorsetr.lsp:

	Each time you load this file, it will bring up a window containing a
	single slider for red, green, and blue colors.  You can use the
	sliders to create colors interactively, then click the button "Set
	Color On Selected Widget", followed by clicking on the widget whose
	color you want to set.  Once the color on a widget has been set, you
	may move the sliders to change that color value without having to
	reselect the widget.  By bringing up multiple instances of the
	colorsetr.lsp application you can set multiple color planes in other
	winterp widgets...  Note that this uses XM_GET_COLORS to generate
	top/bottom/shadow colors based on the background color you've dialed
	in. Unless you have a lot of planes on your display, this can cause
	you to run out of colors quickly. Note that this works only on Motif
	1.1 or later.

==============================================================================

* Running WINTERP -- useage, command-line flags, application resources.

	WINTERP can be run either in "standalone" or "interactive" modes.

** Standalone mode:

	When running standalone, WINTERP interprets a "script" describing
	a particular UI/application, but otherwise behaves just like a
	traditional C/Motif program. WINTERP may be run "standalone"
	by setting command-line flags -no_unix_server -no_inet_server
	-no_stdin_server or setting the following X resources to false:
	.enableUnixServer .enableInetServer and .enableStdinServer .

	In some cases, one may want to specify the following additional
	command-line arguments when running "standalone" to force WINTERP
	to behave more like a traditional C/Motif application:
	-no_init_msgs, -no_xterr_brk, -no_xtwarn_brk, and -no_xerr_brk. The
	same effect may also be achieved by setting the associated X
	resources to false: .enableInitMsgs, .enableXtErrorBreak,
	.enableXtWarningBreak, and .enableXErrorBreak .

	In order to run a Winterp-Lisp program <file.lsp> standalone, you
	need to set the command-line argument "-init_file <file.lsp>", or
	set resource .lispInitFile. To have an application come up
	"standalone" with its own set of resources, you may use the
	command-line argument "-class <Application>" to tell WINTERP to
	load resources from the application defaults file <Application>; on most
	systems, this file would be /usr/lib/X11/app-defaults/<Application>.
	An app-defaults	file may be placed in other directories specified by
	UN*X environment variable XUSERFILESEARCHPATH (see X(1) for details,
	and see also environment variables XAPPLRESDIR and XFILESEARCHPATH).

	Some of the applications in /usr/local/winterp/examples/*.lsp
	contain code which checks for the existence of environment variable
	WINTERP_STANDALONE_APP. If these applications find this environment
	variable then they know they are running as standalone applications
	under WINTERP. When this environment variable is set, and a WINTERP
	standalone application is terminated either explicitly, or through
	a "window manager quit" (e.g. mwm's f.kill action) WINTERP itself
	will terminate. If the UN*X environment variable WINTERP_STANDALONE_APP
	is not set, quitting these applications will just delete the
	windows associated with the application, but continue to leave
	WINTERP running (so that any other applications it is running
	continue). If you run a "standalone" application without setting
	environment variable WINTERP_STANDALONE_APP, then the windows
	associated with the application will disappear when you quit the
	application but a non-interactive 'winterp' will continue to run and
	will need to be explicitly terminated via kill(1).

	The following Winterp-Lisp applications check for WINTERP_STANDALONE_APP
	/usr/local/winterp/examples/{calendar.lsp, dircmp.lsp, grep-br.lsp, 
	/man-br.lsp, timesheet.lsp, xbiff.lsp, modem-dialer.lsp, and
	tk-challenge/Application.lsp. Directory /usr/local/winterp/bin
	contains some scripts to run some of the aforementioned
	applications: win-dialer, win-dircmp, win-grep, win-man-br, win-xbiff,
	and win-calendar. 

	The following is an example of the 'win-grep' script, which loads
	"grep-br.lsp" as a standalone application. 

	| #!/bin/sh
	|
	| WINTERP_STANDALONE_APP=TRUE
	| export WINTERP_STANDALONE_APP
	|
	| exec /usr/local/bin/winterp -init_file grep-br.lsp \
	|                             -lib_dir /usr/local/winterp/examples/ \
	|			      -no_stdin_serv -no_unix_serv -no_inet_serv \
	|			      -no_init_msgs $* &

** Interactive mode:
	
	WINTERP may be interactively programmed via the built-in Xlisp
	evaluator; WINTERP thus provides a development and execution
	environment for designing, building, debugging, integrating and
	extending GUI-based applications. In "interactive" mode, WINTERP's
	Xlisp evaluator may be accessed through a terminal, or through the
	INET- or UNIX- domain sockets. Interactive access to WINTERP is
	controlled by the command line arguments -no_stdin_server,
	-enable_stdin_server, -no_inet_server, -enable_inet_server,
	-no_unix_server and -enable_unix_server. Resources
	.enableStdinServer, .enableInetServer, and .enableUnixServer
	also control interactive access to WINTERP.

	A variety of means of interacting with WINTERP is described below in
	sections: <<Interacting with WINTERP via the terminal>>;
	<<Interacting with WINTERP via UN*X Domain Sockets, and the 'wl' client>>;
	<<Interacting with WINTERP via INET Domain Sockets, and the 'wl-tcpip' client>>;
	<<Interacting with WINTERP via the "WINTERP Control Panel>>;
	<<Interacting with WINTERP via GNU Emacs' "winterp" mode>>,
	and <<Interacting with WINTERP via GNU Emacs' "inferior lisp" mode>>.

** Interacting with WINTERP via the terminal:

	Typically, when developing applications with WINTERP, one runs it under
	a terminal emulator, e.g. xterm(1); the "stdin eval server" in WINTERP
	listens to "stdin" from the terminal and evaluates any expressions
	entered by the user; results of evaluation are printed on stdout
	and unless one has done '(require "lib-utils/redir-err")', error
	messages will also print to the terminal.

	The "stdin eval server" is a new feature of WINTERP 2.0. It is
	enabled by default, but may need to be disabled on a very few
	machines or operating sytems. If you experience trouble with
	WINTERP's "stdin eval server", you may disable it via
	command-line argument -enable_stdin_serv, or by setting resource
	.enableStdinServer to false. (Note that the author has not has any
	trouble running the "stdin eval server" on all the Unix machines
	that WINTERP was tested on -- however, it is known that the
	XtAppAddInput() call upon which this functionality is predicated
	does not behave well on some systems (SCO??) when told to listen
	for new input on the file descriptor associated with "stdin").

	One reason to use the "stdin eval server" in WINTERP is that it
	operates seamlessly with the XLISP "break loop", which is a special
	read/eval/print loop which is invoked by XLISP when an error occurs,
	allowing easier debugging of Winterp-Lisp programs. In order to
	prevent re-entrancy bugs, X events are not processed while in the
	XLISP "break loop" which means that you cannot use the UN*X domain
	or INET domain servers, nor the GNU Emacs interface (winterp.el),
	nor the "WINTERP Control Panel" to interact with WINTERP.

	The "break loop" is a special read/eval/print loop allowing users
	to examine the state of the interpreter in the context of the
	error. This loop differs from the normal top-level
        read/eval/print loop in that if the user invokes the function
	'continue', XLISP will continue from a correctable error --
	for example if get an undefined function error, then define
	the function and 'continue' XLISP will continue execution from
	the point where the error occurred. If the user invokes the
	function 'clean-up' (or types Control-D), XLISP will abort the
	break loop and return to the top level or the next lower
	numbered break loop. When in the "break loop", the standard
	WINTERP "X> " prompt is replaced with one of "1> ", "2> ",
	... "n> " where n represents the "breaklevel", the nesting
	level of the "break loops", each level corresponding to a single
	error occurrence.

	IMPORTANT NOTE ON BREAK LOOP: In WINTERP, controlling the "break
	loop" can only be done via the terminal under which WINTERP is
	running. WINTERP does not respond or process any X events while in
	the XLISP "break loop". In other words, if an error occurs while
	"Error Break-Loop" or "Error Trace-Back" radio buttons are set,
	the "WINTERP Control Panel" will not be responsive to the mouse
	or keyboard. To exit the break loop and regain X interactivity,
	the use must invoke function 'top-level' or type Control-C into
	the controlling terminal.

	For more information on the XLISP "break loop" see
	<winterp-top-dir>/doc/xlisp.doc section "BREAK COMMAND LOOP",
	functions 'clean-up', 'top-level', and 'continue', and variables
	*BREAKENABLE*, *TRACENABLE*, and *TRACELIMIT*. Note that the
	"break loop" and read/eval/print key-bindings listed in
	<winterp-top-dir>/doc/xlisp.doc do not apply to WINTERP. The only
	keybindings that work are:
		* the standard tty editing commands, e.g.
		  Control-H, Control-U, etc. See stty(1) for details.
		* Control-C -- equivalent to calling function 'top-level'
		* Control-D -- equivalent to calling function 'clean-up'

	Note also that unlike XLISP, entering Control-D into the
	standard read-eval-print loop of WINTERP will not exit the
	evaluator. however it will disable the "stdin eval
	server". This is done so that WINTERP can be run in a
	pipeline, evaluating input on stdin. When an EOF occurs,
	XtAppAddInput() infinite-loops, so WINTERP catches this and
	disables the infinite loop.

	The simplest way to invoke a "break loop" upon error is to select
	the "Error Break-Loop" or "Error Trace-Back" radio buttons in the
	"WINTERP Control Panel". For details, see the section below
	<<Interacting with WINTERP via the "WINTERP Control Panel":>>
	especially sections <<"Error Break-Loop" radio button:>> and
	<<"Error Trace-Back" radio button:>>.

	--------------------

	Although the "stdin eval server" is a convenient and quick way of
	interacting with the XLISP interpreter, it may not be the best way
	of developing programs in WINTERP -- it is far easier to develop
	one's code in a text editor and use commands to interactively and
	incrementally send individual expressions to WINTERP. Although editor-
	based interaction with WINTERP is useful for developing programs, it is
	often easiest to use the "stdin eval server" to load, test, debug, and
	experiment with programs you've developed within an editor.

	The WINTERP distribution contains three different means of
	interacting with the interpreter directly from a text editor.
	The "WINTERP Control Panel" allowing interactive development of
	programs using simple Motif-based text editor and various other
	Motif widgetry for controlling WINTERP. For details, see the section
	<<Interacting with WINTERP via the "WINTERP Control Panel">>.
	For GNU Emacs users, this distribution also includes two
	Emacs-Lisp files providing for two different ways of programming
	WINTERP via GNU Emacs (for details, see the sections
	<<Interacting with WINTERP via GNU Emacs' "winterp" mode>> and
	<<Interacting with WINTERP via GNU Emacs' "inferior lisp" mode>>).

** Interacting with WINTERP via the "WINTERP Control Panel":

	The Winterp-Lisp file ./../examples/w_ctrlpnl.lsp is a simple
	control panel for WINTERP providing a file browser for
	loading/editing/saving Winterp-Lisp files, and an editor allowing
	interactive evaluation of the s-expression under the editor cursor.
	Other editor commands include traversing forwards/backwards through
	s-expressions, and formatting your code. Other XLISP commands include
	control over the XLISP debugger and WINTERP/XLISP evaluation error
	dialogues.

	The "WINTERP Control Panel" is entirely written in Winterp-Lisp; it
	is typically loaded from your ~/.winterpapp file, which is
	automatically loaded by WINTERP when it is started without
	a -init_file command-line argument or .lispInitFile resource.
	(see <<~/.winterpapp -- WINTERP development session startup file.>>
	for details).

***	Directory Selection:
		Double click on an item in the "Directories" XmList widget,
		or enter a wildcarded filename
		(e.g. /usr/local/winterp/examples/*.lsp) in the "Filter"
		XmText widget and hit <return>. If the directory is valid
		and has files in it, then the files in that direcory will appear
		in the "Files" XmList widget.

***	File Selection:
		To select a file in the "Files" XmList widget, single click
		on it. Alternately you may set the file selection by entering
		a fully qualified pathname to the file in the "Selection"
		XmText widget. The "Edit($EDITOR)", "Load File", "Show File",
		and "Save File" perform their function on the selected file.
		Double clicking an item in the "Files" XmList widget is
		equivalent to selecting a file and clicking "Show File", 
		causing the file to be displayed in the XmText editor widget.
	

***	"Edit($EDITOR)" button:
		The selected file gets edited by the editor set in
		environment variable $EDITOR. You may override $EDITOR by
		setting variable *SYSTEM-EDITOR* in your ~/.winterp file.

		In the XmText editor widget, Control-Meta-E calls this function.

***	"Load File" button:
		The selected file gets loaded into XLISP/WINTERP. This function
		allows the "WINTERP Control Panel" to start up other WINTERP
		applications, set up the environment, or load libraries.
		WINTERP expects the selected file to be a Winterp-Lisp file;
		unknown results will occur if the file is of the wrong type,
		typically, Lisp evaluation or reader errors.
		
		In the XmText editor widget, Control-Meta-L calls this function.

***	"Show File" button:
		The selected file is presented in the XmText editor widget.
		The user may then edit the file, or interactively evaluate
		Winterp-Lisp s-expressions with "Eval(<-->)". 

		Double clicking on a file in the "Files" XmList widget does the
		equivalent of "Show File", displaying the file in the XmText
		widget.

***	"Save File" button:
		Saves the contents of the XmText editor widget; a File
		Selection Box dialog is popped up allowing the user to
		enter the filename; the default filepath for saving is that of
		the current file listed under "Selection" in the
		"WINTERP Control Panel". 

		In the XmText editor widget, Control-Meta-S calls this function.

***	"Eval(<-->)" button:
		Evaluates the s-expression at the current cursor position in
		the XmText editor widget. This command searches backwards
		and forwards for the matching parentheses surrounding the
		current position of the cursor and sends that expression off to
		XLISP's reader and evaluator. The results of the evaluation gets
		printed to stdout and is visible in the terminal emulator
		running WINTERP. For best results, place the cursor on the
		opening parenthesis

		If an error occurs in searching for the matching
		parentheses surrounding the XmText curor, the program will
		beep, without evaluating any Winterp-Lisp expressions.

		In the XmText editor widget, Control-Meta-X calls this function.
		(the same binding is used in Gnu-Emacs).

		BUG: if an evaluation error occurs, the error backtrace
		(which occurs wnen "Error Dialog" or "Error Trace-Back" radio
		buttons are selected) will contain some spurious function call
		frames from the WINTERP Control Panel itself -- you should
		ignore all the call frames printed below the following:
			"Function: #<Subr-READ_EVAL_PRINT: #10064be0>"

***	"(<---" button:
		Moves the XmText cursor back from the current position to
		the opening parenthesis at the current level of parentheses. This 
		command is useful for moving back through Winterp-Lisp
		s-expressions one expression at a time.

		If an error occurs in searching for the matching
		parentheses surrounding the XmText curor, the program will
		beep, without moving the cursor.

		In the XmText editor widget, Control-Meta-B calls this function.
		(the same binding as used in Gnu-Emacs).

***	"--->)" button:
		Moves the XmText cursor forward from the current position to
		the opening parenthesis at the current level of parentheses.
		This command is useful for moving forwards through Winterp-Lisp
		s-expressions one expression at a time.

		If an error occurs in searching for the matching
		parentheses surrounding the XmText curor, the program will
		beep, without moving the cursor.

		In the XmText editor widget, Control-Meta-F calls this function.
		(the same binding as used in Gnu-Emacs).

***	"Format(<-->)" button:
		Formats the text within the s-expression at the XmText
		widget's cursor position by running it through an XLISP
		"pretty printer". This function uses the same
		mechanism/rules for determining the extent of the current
		s-expression as used by "Eval(<-->)".

		If an error occurs in searching for the matching
		parentheses surrounding the XmText curor, the program will
		beep, without moving the cursor.

		In the XmText editor widget, Control-Meta-Q calls this function.
		(the same binding as used in Gnu-Emacs).

		BUG: Calling "Format" converts all Winterp-Lisp symbols to
		uppercase (XLISP symbols are case insensitive, so case
		information is lost when text is read/parsed by XLISP. Note
		that case for data is preserved (e.g. CHAR, STRING, etc).

***	"Debug Off" radio button:
		When this debug option is selected, XLISP global variable
		*BREAKENABLE*, and WINTERP global variable *ERRHOOK* are both
		set to NIL. When an XLISP evaluation error occurs, or a
		WINTERP, Motif, or X11 error happens, processing of the
		current function/method terminates and an error message is
		printed on the terminal.

***	"Error Dialog" radio button:
		When this debug option is selected, XLISP global variable
		*BREAKENABLE* is set to NIL, and WINTERP global variable
		*ERRHOOK* is bound to the error hook dialog function from
		<winterp-top-dir>/examples/lib-utils/err-hook.lsp. When an
		XLISP evaluation error occurs, or a WINTERP, Motif, or X11
		error happens, processing of the current function/method
		terminates, an error message is printed on the terminal, and
		a dialog box pops up listing the error message and printing the
		stack trace from the error-causing function/method all the way
		up to the top-level invocation that caused the error.

		The error dialog button "Close Window" can be clicked to remove
		the dialog (since "Close Window" is the default button, you
		can also just hit <return> in the dialog window. The error
		dialog button "Save Backtrace" will save the stack trace to a
		file entered by the user into a file selection dialog box.
		Button "Exit Application" will terminate WINTERP -- typically
		this is only for cases where severe errors have occurred.

***	"Error Break-Loop" radio button:
		When this debug option is selected, XLISP global variable
		*BREAKENABLE* is set to T, XLISP global variable *TRACENABLE*
		is set to NIL, and WINTERP global variable *ERRHOOK* is set
		to NIL. When an XLISP evaluation error occurs, or a
		WINTERP, Motif, or X11 error happens, processing of the
		current function/method terminates, an error message is
		printed and the XLISP "break loop" is entered.

		For more information on the "break loop" see section above
		<<Interacting with WINTERP via the terminal:>>, it is
		especially important that you read the portion titled
		<<IMPORTANT NOTE ON BREAK LOOP>> if you're wondering
		why X windows from WINTERP no longer respond to X when
		you're in the break loop.

***	"Error Trace-Back" radio button:
		When this debug option is selected, XLISP global variable
		*BREAKENABLE* is set to T, XLISP global variable *TRACENABLE*
		is set to T, and WINTERP global variable *ERRHOOK* is set
		to NIL. When an XLISP evaluation error occurs, or a
		WINTERP, Motif, or X11 error happens, processing of the
		current function/method terminates, an error message is
		printed, a stack-trace is printed, and the XLISP "break loop"
		is entered.

		The stack trace printed in this case is just like the stack
		trace that pops up when "Error Dialog" is selected (see above).
		It lists the call to the error-causing function/method all the
		way up to the top-level invocation that caused the error.

		For more information on the "break loop" see section above
		<<Interacting with WINTERP via the terminal:>>, it is
		especially important that you read the portion titled
		<<IMPORTANT NOTE ON BREAK LOOP>> if you're wondering
		why X windows from WINTERP no longer respond to X when
		you're in the break loop.

***	Function 'debug':

		Evaluating '(debug)' will set *BREAKENABLE*, subsequent XLISP
		evaluation errors will cause the XLISP "break loop" to be
		entered. This function from w_ctrlpnl.lsp overrides the one in
		lib-utils/initialize.lsp, causing the "WINTERP Control Panel"
		radiobuttons to indicate the state of the debugger.

***	Function 'nodebug':

		Evaluating '(nodebug)' will clear *BREAKENABLE* and
		*ERRHOOK*, such that XLISP evaluation or WINTERP/Motif/X11
		errors will not invoke the "break loop" nor the
		"Error Dialog" box warning of errors. This function from
		w_ctrlpnl.lsp overrides the one in lib-utils/initialize.lsp, 
		causing the "WINTERP Control Panel" radiobuttons to indicate
		the state of the debugger.

***	Function 'ctrlpnl':

		Evaluating '(ctrlpnl)' will deiconize or raise the "WINTERP
		Control Panel" window. Useful for cases when one is
		interacting with WINTERP via the "stdin eval server" and
		one wants to pop up an interface for evaluating or loading
		Winterp-Lisp files.

** Interacting with WINTERP via GNU Emacs' "winterp" mode:

	The gnuemacs interface to WINTERP makes the following assumptions:
	(1) You're using GNUEMACS version 18.54 or later (I've used
	winterp.el with versions of gnuemacs as old as 18.44, but you may
	need to load a >18.54 version of lisp/shell.el).
	(2) You've installed the WINTERP-Lisp client program 'wl' somewhere
	on your	UX*X search path (see $PATH).
	(3) You are running WINTERP on the same host
	as GNU Emacs, and you've enabled WINTERP's unix
	domain socket by setting resource <<Winterp.enableUnixServer>> to
	'true' or by adding <<[-enable_unix_server]:>> to the command-line.
	(4) The WINTERP-server ('winterp') is running and sending stderr and
	stdout to a reasonable place such as a terminal emulator.

	To use WINTERP's GNUEMACS interface, you must first load the file
	./../src-client/winterp.el into gnuemacs. You may do this
	manually by using the command 'M-X load-file<return>' specifying the
	file 'winterp.el' with the appropriate path information prepended.
	Alternately, you may include the form '(load "<path>winterp")' in
	your $HOME/.emacs file, where <path> is the appropriate path to the
	file ./../src-client/winterp.el.

	Once winterp.el is loaded, you should visit a WINTERP-Lisp file
	using GNUEMACS command 'M-X find-file<return>' (C-x C-f). A file with
	suffix '.lsp' denotes a XLISP or WINTERP-Lisp file, and these will
	automatically put the associated editor buffer "Lisp mode" -- the
	GNUEMACS mode line will indicate the mode as '(Lisp)'. Within a
	Lisp-mode buffer, the following additional commands and keybindings
	are defined:

***	winterp-send-defun (Control-Meta-X):

		The Lisp s-expression at the "point" (cursor) is sent to the
		WINTERP-server for evaluation.

***	winterp-send-buffer:

		The current buffer is sent to the WINTERP-server for evaluation.

***	winterp-send-exit: (C-c C-d):

		Sends a Control-D == EOF to XLISP, which exists the
		current breaklevel. If XLISP is not at a breaklevel,
		then this command will exit XLISP and cause the WINTERP-server
		to terminate.

	Additional commands that are useful in GNUEMACS' Lisp-mode:

***	indent-sexp (Control-Meta-Q):

		Formats and indents the s-expression under the "point"
		(cursor).

***	indent-for-comment (M-;):

		Will place a Lisp comment character at the appropriate column
		in your Lisp-source. If a comment already exists on the current
		line, this will reindent the comment.

***	forward-list: (Control-Meta-N):

		Moves the "point" forward across a balanced group of
		parentheses. This is useful for moving the cursor to the next
		form.

***	backward-list: (Control-Meta-P):

		Moves the "point" backward across a balanced group of
		parentheses. This is useful for moving the cursor to the
		previous form.

***	forward-sexp: (Control-Meta-F):

		Moves the "point" forward across one balanced expression.
			

***	backward-sexp (Control-Meta-B):

		Moves the "point" backward across one balanced expression.
		

***	NOTE: The author has found it useful to bind commands backward-list,
	forward-list, and winterp-send-buffer to "function" keys F6, F7,
	and F8, respectively, because these commands are used often when
	using GNUEMACS to interface with WINTERP.

***	DEBUGGING-TIP:

	If you are using WINTERP's GNUEMACS interface and
	functions such as winterp-send-defun are not working correctly, 
	you should check the GNUEMACS buffer *winterp-client-shell* for
	error output from the program 'wl'. WINTERP's GNUEMACS interface
	requires that the winterp client program 'wl' works correctly --
	see the documentation on 'wl' above for information.

** Interacting with WINTERP via GNU Emacs' "inferior lisp" mode.

	<winterp-top-dir>/src-client/win-cmulisp.el provides code
	to have WINTERP run as a GNU Emacs subprocess, with Emacs'
	Lisp mode providing Emacs' standard means of interaction
	with a Lisp system. Although this is the standard way of interacting
	with a lisp subprocess through emacs, the author prefers
	the old way of interacting with WINTERP, which is described in 
	<<Interacting with WINTERP via GNU Emacs' "winterp" mode:>>

	Those preferring to use GNU Emacs 18's "comint/cmulisp" package,
	or GNU Emacs 19 standard inferior lisp interface should
	add the following to their ~/.emacs:
		(load "<winterp-top-dir>/src-client/win-cmulisp")
	(Where <winterp-top-dir> is typically /usr/local/winterp.).

	Following the load of 'win-cmulisp', one may start up WINTERP as an
	emacs subprocess, by doing "M-X run-winterp". This will
	create a buffer in emacs in which WINTERP's "stdin eval server"
	receives and displays input/output. In emacs 18, this
	buffer is named "*cmulisp*"; in Emacs 19, the buffer is named
	*inferior-lisp*. In addition to displaying the results of
	WINTERP evaluations, this buffer can also be used to edit and send
	lisp expressions to the WINTERP subprocess of emacs.

	The following commands are available in the *cmulisp*/*inferior-lisp*
	buffer:
		m-p	Cycle backwards in input history
		m-n	Cycle forwards
		m-c-r   Search backwards in input history
		return  Send input to inferior lisp
		c-a     Beginning of line; skip prompt.
		c-d	Delete char unless at end of buff.
		c-c c-u ^u
		c-c c-w ^w
		c-c c-c ^c
		c-c c-z ^z
		c-c c-\ ^\
		c-c c-o Delete last batch of process output
		c-c c-r Show last batch of process output

	If you are using GNU Emacs to edit Winterp-Lisp files, one
	may interactively edit and evaluate code via GNU Emacs'
	lisp mode, which provides the following useful bindings:

		c-m-x    This binding is a gnu convention.
		c-c c-e  Send the current defun to Lisp process.
		c-x c-e  Send the previous sexp to Lisp process.
		c-c c-r  Send the current region to Lisp process.
		c-c c-z  Switch to the Lisp process buffer.
		c-c c-l  Prompt for a buffer to load, default to current.

** Interacting with WINTERP via UN*X Domain Sockets, and the 'wl' client:

	The WINTERP client program 'wl' (stands for Winterp-Lisp) sends the
	XLISP expression given on its command line to the WINTERP server.
	'wl' hangs until WINTERP has evaluated the s-expression given on
	'wl's command-line. After the s-expression is successfully
	evaluated by WINTERP, 'wl' prints to stdout the results of
	the evaluation, and sets exit status 0. If an evaluation error
	occurs, an error messsage is output to stderr, and exit status
	gets set to 127.

	In contrast to the TCP/IP socket (see 'wl-tcpip'), the Unix Domain
	Socket is secure. People on other workstations cannot access a Unix
	domain socket via the netoork. Since the Unix Domain socket is a UN*X
	file, security on multi-user machines is achieved via traditional
	file-protection techniques -- WINTERP creates the file
	unreadable/unwritable by others.

	By default, WINTERP compiles with the Unix-Domain eval
	server enabled. If for some reason your machine or OS does
	not support Unix Domain Sockets, you may turn off
	compilation of these features. Do this by (1) removing
	"-DWINTERP_WANT_UNIX_SERVER" in the associated
	<winterp-top-dir>/src-server/Makefile.* makefile; or (2) make
	equivalent change to the Imakefile or its generated Makefile in
	that directory; or (3) edit <winterp-top-dir>/src-server/config.h...

	The Unix Domain Socket can also be enabled/disabled via X resource
	<<Winterp.enableUnixServer:>>, or via command-line arguments
	<<-no_unix_server>> or <<-enable_unix_server>>. 

** Interacting with WINTERP via INET Domain Sockets, and the 'wl-tcpip' client:

	The WINTERP client program 'wl-tcpip' (stands for Winterp-Lisp) sends
	the XLISP expression given on its command line to the WINTERP
	inet-domain server. 'wl-tcpip' hangs until WINTERP has
	evaluated the s-expression given on 'wl-tcpip's command-line. After
	the s-expression is successfully evaluated by WINTERP, 'wl-tcpip'
	prints to stdout the results of the evaluation, and sets exit status 0.
	If an evaluation error occurs, an error messsage is output to stderr,
	and exit status gets set to 127.

	By default, WINTERP compiles without the INET-Domain eval
	server capability. One may enable the TCP/IP socket capability by
	recompiling WINTERP with the line "#define WINTERP_WANT_INET_SERVER"
	added to ../src-server/config.h, or by setting 
	"WANT_INET_SERVER= -DWINTERP_WANT_INET_SERVER" in the appropriate
	makefiles. Even when WINTERP is compiled with this option, the TCP/IP
	socket will not be enabled by default. This socket may be
	enabled/disabled via a command line options <<-no_inet_server>>
	<<-enable_inet_server>> or by setting X resource
	<<Winterp.enableInetServer>>. Note that the TCP/IP client program,
	'wl-tcpip', is not compiled by default because most WINTERP
	installations don't need it.

	The reason for disabling the TCP/IP socket is due to reasons of
	security. If you run WINTERP on a known port number, without any
	security precautions (see inetd.sec(4)), you are giving people 
	open access to your account -- for example, others users will be
	able to execute programs on your account through the SYSTEM, 
	POPEN, EXP_SPAWN, and EXP_POPEN primitives.

	By default, the program 'wl-tcpip' attempts to connect to the
	WINTERP server through your machine's loopback address, which it
	assumes is 127.0.0.1. If that is not your loopback address (isn't
	that IP address standard??), then you may have to specify
	'localhost' or the hostname of your machine. 'wl-tcpip' will be
	able to connect to the WINTERP server more quickly if it can get an
	IP address without having to do a gethostbyname(). That's why I
	hardcoded the loopback address into wl-tcpip.c... (If this lookup
	is too slow, and you are running 'winterp' and 'wl-tcpip' locally,
	you may prefer using the Unix Domain Socket server mentioned
	below.)

** Compilation options -- 'stdin eval server', UN*X and INET domain sockets:

	WINTERP has a number of compilation and run-time options
	configuring how the eval-server is set up. Options
	can be enabled/disabled by editing
	<winterp-top-dir>src-server/Imakefile and then doing

		cd <winterp-top-dir>
		xmkmf
		make World

	Alternately, one may also just edit the above variable
	settings in the makefile approrpriate for your machine
	and OS (<winterp-top-dir>src-server/Makefile.*), followed
	by recompilation.

	Options are enabled when the variables below are set:
		WANT_INET_SERVER= -DWINTERP_WANT_INET_SERVER
		WANT_UNIX_SERVER= -DWINTERP_WANT_UNIX_SERVER
		WANT_STDIN_SERVER= -DWINTERP_WANT_STDIN_SERVER
	Options are disabled when the variables are set to ""

	The default compilation of WINTERP enables only 'stdin eval
	server' and UN*X domain socket eval server. To add 
	'inet eval server' edit the appropriate makefile and
	recompile as outlined above.

** WINTERP Resources (~/.Xdefaults):

	WINTERP is a standard Xtoolkit program. Any widgets you create will
	be affected by resource-manager settings just like they would in a
	normal program. 

	In addition to resources for individual widgets, the following
	set up WINTERP's global application-resources. The default values
	are listed inside '[' and ']'.

***	Winterp.lispInitFile: [~/.winterpapp]

	By default, ~/.winterpapp is the XLISP initialization file
	that WINTERP attempts to load when it starts up. Setting resource
	.lispInitFile overrides that default and loads the file
	given by the resource value. The file is loaded using the
	same search paths as primitives LOAD and REQUIRE -- see
	<<Function REQUIRE:>> and <<Function LOAD:>>.

	Note: For delivering applications that know how to load their own
	lisp files, I suggest writing a script that does whatever you need
	it to and then executes "winterp -class <Application>". The command
	line argument -class causes WINTERP to use application-default file
	/usr/lib/X11/app-defaults/<Application>. That file in turn contains
	any resources needed by <Application>, with the resource
	Winterp.lispInitFile set to <Application>'s initialization
	file. That file in turn loads the application itself.

***	Winterp.lispLibDir: [./]

	This resource sets the path to the default directory used by the
	LOAD and REQUIRE primitive. If you give an unqualified filename <file>
	to LOAD/REQUIRE it will attempt to load <lispLibDir>/<file>.lsp . By
	default, this directory is WINTERP's current working directory `pwd`.
	
	I suggest that you set this resource to "<path>/winterp/examples/"
	, where <path> is the fully qualified pathname to the WINTERP
	distribution files.

***	Winterp.lispLoadPath: <:-separated-list-of-paths-to-load-dir>

	This resource sets the search-path used by the LOAD and REQUIRE
	primitives. The value of environment variable XLPATH overrides this
	resource. If you give an unqualified filename <file> to LOAD/REQUIRE,
	they will attempt to load <path>/<file>.lsp , where <path> is
	one of the paths in <:-separated-list-of-paths-to-load-dir>. If no
	match occurs, then  <<Winterp.lispLibDir>> is searched, and finally
	`pwd`...

***	Winterp.lispTranscriptFile: [<none>]

	If you set this, XLISP will use the DRIBBLE primitive to write out
	a transcript of your interactions with the Lisp interpreter. By
	default, this is not done.

***	Winterp.enableInitMsgs: [true]

	By default, this resource is set to "true", causing WINTERP to send
	its initialization messages to the standard output.  WINTERP-based
	applications may want to put an application specific initialization
	message; for such cases WINTERP's initialization messages may be
	disabled by setting this resource to "false".

***	Winterp.initMessageString: [<string>]

	By default, this resource is set to a dynamic-generated
	string based on argv[0], -class, etc. The string value of this
	resource represents  the message displayed by WINTERP's default
	window at startup time.

***	Winterp.enableXtErrorBreak: [true]

	By default, WINTERP will signal an XLISP break when the Xtoolkit
	signals an error (via XtError()). When this resource is "true",
	Xtoolkit errors will print an error message and signal a Lisp error
	-- the Lisp call-sequence (or callback) that caused the error will
	terminate, however WINTERP will be able to execute other callbacks,
	input from the XLISP eval-server, etc.

	Setting the resource to "false" will cause WINTERP not to signal an
	XLISP break when the Xtoolkit signals an error (via XtError());
	when this argument is specified, Xtoolkit errors will print an
	error message on stderr and cause WINTERP to exit.

***	Winterp.enableXtWarningBreak: [false]

	By default, this resource is "FALSE", meaning that WINTERP
	will not signal an XLISP break when the Xtoolkit gives a
	warning (via XtWarning()) -- the error message will appear
	on stderr and execution will continue.
	
	When this resource is "TRUE", Xtoolkit warnings will print
	an error message and signal a Lisp error -- the Lisp
	call-sequence (or callback) that caused the warning will
	terminate, however WINTERP will be able to execute other
	callbacks, input from the XLISP eval-server, etc.
	
	Note that I've seen problems when setting 
	enableXtWarningBreak: TRUE, thus the default value of FALSE.
	This is done because some XtWarnings were not meant to be
	broken out-of and can leave Motif in a weird state, causing
	possible subsequent strange behavior, core-dumps, etc.
	
	An example of this problem is associated with a Motif 1.1
	popup menu bug. When a shell associated with a popup menu
	is destroyed, the following spurious warning is printed
		error: X Toolkit Warning:
		        Attempt to remove non-existant passive grab
	When enableXtWarningBreak is set to TRUE, and the above
	warning occurs, subsequent attempts to close a window
	through the window manager will result in the error:
		XIO:  fatal IO error 32 (Broken pipe) on X server...

***	Winterp.enableXErrorBreak: [true]

	By default, WINTERP will signal an an XLISP break when the X server
	or X library signals an error (via XError()).  When this resource
	is "true", X errors will print an error message and signal a Lisp
	error -- the Lisp call-sequence (or callback) that caused the error
	will terminate, however WINTERP will be able to execute other
	callbacks, input from the XLISP eval-server, etc.
	
	Setting the resource to "false" will cause WINTERP not to signal an
	XLISP break when the X library/server signals an error (via
	XError()); when this argument is specified, X errors will print an
	error message on stderr and cause WINTERP to exit.

***	Winterp.enableStdinServer: [true]

	By default, this resource is set to "true", meaning that WINTERP
	listens for input on stdin, doing a read-eval-print for every
	s-expression entered. Setting this resource to "false" will
	disable the stdin eval server. Disabling the stdin server
	might be desired for standalone WINTERP-based applications, or
	to prevent errors on systems that don't support XtAppAddInput()
	on stdin. Note that this resource is only available on WINTERPs
	compiled with "-DWINTERP_WANT_STDIN_SERVER"

***	Winterp.enableUnixServer: [true]
		
	By default, this resource is set to "true", meaning that WINTERP
	will set up a Unix Domain Socket for input to WINTERP's
	eval-server. Setting this resource to "false" will disable the
	eval-server. Note that this resource is only available on WINTERPs
	compiled "-DWINTERP_WANT_UNIX_SERVER"

***	Winterp.unixSocketFilepath: [/tmp/.winterp_serv]

	This resource sets the pathname for the Unix Domain Socket
	eval-server. By default, ".unixSocketFilepath" is
	"/tmp/.winterp_serv", you may want to specify a different
	".unixSocketFilepath" if multiple 'winterp' applications are
	running. Alternately, you may want to hide the Unix Domain
	Socket from other users if you are on a multi-user machine.
	Note that specifying environment variable
	WINTERP_UNIX_SOCKET_FILEPATH overrides ".unixSocketFilepath".
	
	Note that this resource is only available on
	WINTERPs compiled with "#define WINTERP_WANT_UNIX_SERVER"
	in file	"./../src-server/config.h" or if WINTERP was compiled
	with "WANT_UNIX_SERVER= -DWINTERP_WANT_UNIX_SERVER" in the makefiles.
	-DWINTERP_WANT_UNIX_SERVER is defined by default in WINTERP.	

***	Winterp.enableInetServer: [false]

	By default, this resource is set to "false", meaning that WINTERP
	will not set up a TCP/IP socket for input to WINTERP's
	eval-server. Setting this resource to "true" will enable the TCP/IP
	eval-server.  Note that this resource is only available on WINTERPs
	compiled with "#define WINTERP_WANT_INET_SERVER" in file
	"./../src-server/config.h" or if WINTERP was compiled with
	"WANT_INET_SERVER= -DWINTERP_WANT_INET_SERVER" in the makefiles.

***	Winterp.servicePort: [23751]

	23751 is the default port number of the TCP/IP server.  If you
	change this, you'll also have to change the port number that the
	winterp client 'wl-tcp' uses to connect with WINTERP -- see the
	'-p' option of 'wl-tcpip'. Resource ".servicePort" in 'winterp' as
	well as the service-port used by 'wl-tcpip' may be set via
	environment variable WINTERP_INET_PORTNUM.  Note that this resource
	is only available on WINTERPs compiled with "#define
	WINTERP_WANT_INET_SERVER" in file "./../src-server/config.h"
	or if WINTERP was compiled with
	"WANT_INET_SERVER= -DWINTERP_WANT_INET_SERVER" in the makefiles.

***	Winterp.serviceName: [widget_interp]

	"widget_interp" is the default service name for WINTERP's TCP/IP
	server if ".servicePort" is set to 0. This resource specifies the
	service name used by the TCP/IP server.  Note that this resource is
	only available on WINTERPs compiled with 
	"#define WINTERP_WANT_INET_SERVER" in file "./../src-server/config.h"
	or if WINTERP was compiled with
	"WANT_INET_SERVER= -DWINTERP_WANT_INET_SERVER" in the makefiles.

	

** Usage: The WINTERP Lisp server (./../src-server/winterp):

	Calling the 'winterp' executable with appropriate arguments will invoke
	the WINTERP program itself and set up the eval-server according to
	the arguments described below. If invoked with no eval-servers
	enabled, WINTERP is running "standalone", running the Winterp-Lisp
	application described in the file argument to '-init_file' on the
	command-line (or equiv. resource). A 'stdin', 'unix-domain' and
	'inet-domain' eval-server can be set up via resources or X
	defaults.

	WINTERP handles some UN*X signals: While evaluating, if a Control-C
	(SIGINT) is entered on WINTERP's controlling terminal, XLISP will
	abort back up to the top-level evaluator. This is useful for
	interrupting infinite loops, infinite recursions, and other errors
	where WINTERP may hang. If WINTERP is terminated with a SIGTERM or
	SIGHUP, it will clean-up after itself and exit. Other signals, such as
	SIGKILL, SIGQUIT are not handled, their receipt terminates WINTERP
	without cleaning up it's Unix-domain socket, etc.
	
	When WINTERP terminates, its exit status indicates the
	reason for termination:
		0     -- normal termination
		128   -- XLISP fatal error.
		1-127 -- WINTERP killed by SIGNAL, the exit status number
			 represents the signal number

***	usage: winterp	[-class <classname>]
			[-init_file <file.lsp>]
			[-transcript_file <file.out>]
			[-lib_dir <path-to-load-dir>]
			[-load_path <:-separated-list-of-paths-to-load-dir>]
			[-no_init_msgs] [-enable_init_msgs]
			[-init_message <string>]
			[-no_xterr_brk] [-enable_xterr_brk]
			[-no_xtwarn_brk] [-enable_xtwarn_brk]
			[-no_xerr_brk] [-enable_xerr_brk]
		     #ifdef WINTERP_WANT_STDIN_SERVER
			[-no_stdin_server]
			[-enable_stdin_server]
		     #endif /* WINTERP_WANT_STDIN_SERVER */
		     #ifdef WINTERP_WANT_INET_SERVER
			[-serv_port <portnum>]
			[-serv_name <servname>]
			[-no_inet_server] [-enable_inet_server]
		     #endif /* WINTERP_WANT_INET_SERVER */
		     #ifdef WINTERP_WANT_UNIX_SERVER
			[-no_unix_server] [-enable_unix_server]
			[-unix_socket_file <socket-filepath>]
		    #endif /* WINTERP_WANT_UNIX_SERVER */
			[... Xtoolkit options ...]

		NOTE: the #ifdef/#endif bracketed portions above refer to
		options	that are optionally built-in when WINTERP is
		compiled. By default, the WINTERP_WANT_INET_SERVER portions
		are not compiled in with WINTERP, but the
		WINTERP_WANT_UNIX_SERVER are. This is explained in more
		detail above in the section <<WINTERP Resources (~/.Xdefaults):>>
		above.

***	[-class <classname>]:

	This optional argument pair must occur first in the list of
	command-line arguments. This argument pair tells winterp the name
	of the application defaults file to use (e.g.
	/usr/lib/X11/app-defaults/<Classname>, and also sets the default
	class for all WINTERP top level shells. Note that <classname>
	should begin with a capital letter. If no [-class <classname>]
	parameter is given, the application 'winterp' will default to class
	"Winterp" and will look for an application-default file in
	/usr/lib/X11/app-defaults/Winterp.

***	[... Xtoolkit options ...]:

	'winterp' works just like a standard Xtoolkit/Motif application,
	and handles all the command line options allowed by the Xtoolkit,
	e.g. -bg, -fg, -font -display, -geometry, -iconic, -title, -name,
	-xrm, etc...  For more information on these options, see the X11r4
	document "X Toolkit Intrinsics -- C Language Interface" chapter 2.3
	"Parsing the Command Line". Alternately, see the appropriate
	watered down documentation provided in the Motif users guide.

***	[-init_file <file.lsp>]:

	this optional argument tells WINTERP to load the Winterp-Lisp file
	<file.lsp> upon startup. Setting this argument pair does the same
	thing as supplying the resource "Winterp.lispInitFile: <file.lsp>"
	(see <<WINTERP Resources (~/.Xdefaults):>> above for details).

***	[-lib_dir <path-to-load-dir>]:

	this optional argument pair sets the default path used by the Xlisp
	LOAD and REQUIRE primitive for loading files that are not qualified by
	a directory path.  Setting this argument pair does the same thing as
	supplying the resource "Winterp.lispLibDir: <path-to-load-dir>"
	(see <<WINTERP Resources (~/.Xdefaults):>> above for details).

***	[-load_path <:-separated-list-of-paths-to-load-dir>]:

	this optional argument pair sets the search path used by 
	LOAD and REQUIRE primitive for loading files without fully
	qualified pathnames.  Setting this argument pair does the same thing
	as supplying the resource
		"Winterp.lispLoadPath: <:-separated-list-of-paths-to-load-dir>"
	(see <<WINTERP Resources (~/.Xdefaults):>> above for details).

***	[-transcript_file <file.out>]:

	this optional argument sets the file used by the Xlisp DRIBBLE
	primitive. Setting this argument pair does the same thing as
	supplying the resource "Winterp.lispTranscriptFile: <file.out>"
	(see <<WINTERP Resources (~/.Xdefaults):>> above for details).

***	[-no_init_msgs]:

	specifying this argument prevents WINTERP from printing
	initialization messages to the standard output.  Setting this
	argument does the same thing as supplying the resource
	"Winterp.enableInitMsgs: false" (see 
	<<WINTERP Resources (~/.Xdefaults):>> above for details).

***	[-enable_init_msgs]:

	specifying this argument enables printing of initialization
	messages from WINTERP -- this is enabled by default.  Setting this
	argument does the same thing as supplying the resource
	"Winterp.enableInitMsgs: true" (see
	<<WINTERP Resources (~/.Xdefaults):>> above for details).

***	[-init_message <string>]:

	Specifies the string displayed in the WINTERP "default
	window" which flashes on the screen when WINTERP start up.
	Setting this argument does the same thing as supplying the resource
	<<Winterp.initMessageString: <string>>> (see 
	<<WINTERP Resources (~/.Xdefaults):>> above for details).

	NOTE: display of initialization message-box is is not disabled by
	"enableInitMsgs: FALSE"

***	[-no_xterr_brk]:

	specifying this argument will cause WINTERP not to call an XLISP
	break when the Xtoolkit signals an error (via XtError()); when this
	argument is specified, Xtoolkit errors will print an error message
	on stderr and cause WINTERP to exit. Setting this argument does the
	same thing as supplying the resource "Winterp.enableXtErrorBreak:
	false" (see <<WINTERP Resources (~/.Xdefaults):>> above for details).

***	[-enable_xterr_brk]:

	specifying this argument will cause WINTERP to call an XLISP break
	when the Xtoolkit signals an error (via XtError()) -- this is
	enabled by default. When this argument is specified, Xtoolkit
	errors will print an error message and signal a Lisp error -- the
	Lisp call-sequence (or callback) that caused the error will
	terminate, however WINTERP will be able to execute other callbacks,
	input from the XLISP eval-server, etc. Setting this argument does
	the same thing as supplying the resource
	"Winterp.enableXtErrorBreak: true" (see 
	<<WINTERP Resources (~/.Xdefaults):>> above for details).

***	[-no_xtwarn_brk]:

	specifying this argument will cause WINTERP not to call an XLISP
	break when the Xtoolkit gives a warning (via XtWarning()); when
	this argument is specified, Xtoolkit warnings will print an error
	message on stderr and continue executing. Setting this argument
	does the same thing as supplying the resource
	"Winterp.enableXtWarningBreak: false" (see
	<<WINTERP Resources (~/.Xdefaults):>> above for details).

***	[-enable_xtwarn_brk]:

	specifying this argument will cause WINTERP to call an XLISP break
	when the Xtoolkit gives a warning (via XtWarning()) -- this is
	enabled by default. When this argument is specified, Xtoolkit
	warnings will print an error message and signal a Lisp error -- the
	Lisp call-sequence (or callback) that caused the error will
	terminate, however WINTERP will be able to execute other callbacks,
	input from the XLISP eval-server, etc. Setting this argument does
	the same thing as supplying the resource
	"Winterp.enableXtWarningBreak: true" (see
	<<WINTERP Resources (~/.Xdefaults):>> above for details).

***	[-no_xerr_brk]:

	specifying this argument will cause WINTERP not to call an XLISP
	break when the X library/server signals an error (via XError());
	when this argument is specified, X errors will print an error
	message on stderr and cause WINTERP to exit. Setting this argument
	does the same thing as supplying the resource
	"Winterp.enableXErrorBreak: false" (see
	<<WINTERP Resources (~/.Xdefaults):>> above for details).

***	[-enable_xerr_brk]:

	specifying this argument will cause WINTERP to call an XLISP break
	when the X signals an error (via XError()) -- this is enabled by
	default. When this argument is specified, X errors will print an
	error message and signal a Lisp error -- the Lisp call-sequence (or
	callback) that caused the error will terminate, however WINTERP
	will be able to execute other callbacks, input from the XLISP
	eval-server, etc. Setting this argument does the same thing as
	supplying the resource "Winterp.enableXErrorBreak: true" (see
	<<WINTERP Resources (~/.Xdefaults):>> above for details).

   NOTE: The following command line options are only available if WINTERP
   was compiled with "#define WINTERP_WANT_STDIN_SERVER" in file
   "./../src-server/config.h" or if WINTERP was compiled with
   "WANT_STDIN_SERVER= -DWINTERP_WANT_STDIN_SERVER" in the makefiles. By
   default, WINTERP compiles with the Unix Domain Socket server enabled, so
   these arguments will be available in the default WINTERP.

***	[-no_stdin_server]:
	specifying this argument disables WINTERP's stdin eval-server. 
	Setting this argument does the same thing as supplying the resource
	"Winterp.enableStdinServer: false" (see
	<<WINTERP Resources (~/.Xdefaults):>> above for details).
	Disabling the stdin server might be desired for standalone 
	WINTERP-based applications, or to prevent errors on systems that
	don't support XtAppAddInput() on stdin.

***	[-enable_stdin_server]:
	specifying this argument enables WINTERP's stdin eval-server,
	which means that WINTERP/XLISP will attempt to interactively evaluate
	s-expressions typed into WINTERP's controlling terminal. Setting this
	argument does the same thing as supplying the resource
	"Winterp.enableStdinServer: true" (see
	<<WINTERP Resources (~/.Xdefaults):>> above for details).

   NOTE: The following command line options are only available if WINTERP
   was compiled with "#define WINTERP_WANT_UNIX_SERVER" in file
   "./../src-server/config.h" or if WINTERP was compiled with
   "WANT_UNIX_SERVER= -DWINTERP_WANT_UNIX_SERVER" in the makefiles. By
   default, WINTERP compiles with the Unix Domain Socket server enabled, so
   these arguments will be available in the default WINTERP.

***	[-no_unix_server]:

	specifying this argument disables WINTERP's Unix Domain Socket
	eval-server.  Setting this argument does the same thing as
	supplying the resource "Winterp.enableUnixServer: false" (see
	<<WINTERP Resources (~/.Xdefaults):>> above for details).

***	[-enable_unix_server]:

	specifying this argument enables WINTERP's Unix Domain Socket
	eval-server -- this is the default.  Setting this argument does the
	same thing as supplying the resource "Winterp.enableUnixServer:
	true" (see <<WINTERP Resources (~/.Xdefaults):>> above for details).

***	[-unix_socket_file <socket-filepath>]:

	specifying this argument pair sets the Unix Domain Socket specified
	by <socket-filepath>.  By default, <socket-filepath> is
	"/tmp/.winterp_serv", you may want to specify a different
	<socket-filepath> if multiple 'winterp' applications are
	running. Alternately, you may want to hide the Unix Domain Socket
	from other users if you are on a multi-user machine.  Setting this
	argument does the same thing as supplying the resource
	"Winterp.unixSocketFilepath: <socket-filepath>" (see
	<<WINTERP Resources (~/.Xdefaults):>> above for details).
	Note that specifying environment variable WINTERP_UNIX_SOCKET_FILEPATH
	overrides this command line argument (as well as resource
	".unixSocketFilepath").
	
   NOTE: The following command line options are only available if WINTERP
   was compiled with "#define WINTERP_WANT_INET_SERVER" in file
   "./../src-server/config.h",  or if WINTERP was compiled with
   "WANT_INET_SERVER= -DWINTERP_WANT_INET_SERVER" in the makefiles.
   By default WINTERP does not compile with the TCP/IP server capabilities
   because they are a potential security hole.

***	[-no_inet_server]:

	specifying this argument disables WINTERP's TCP/IP eval-server --
	this is the default.  Setting this argument does the same thing as
	supplying the resource "Winterp.enableInetServer: false" (see
	<<WINTERP Resources (~/.Xdefaults):>> above for details).

***	[-enable_inet_server]:

	specifying this argument enables WINTERP's TCP/IP
	eval-server. Setting this argument does the same thing as supplying
	the resource "Winterp.enableInetServer: true" (see
	<<WINTERP Resources (~/.Xdefaults):>> above for details).

***	[-serv_port <portnum>]:

	setting this optional argument pair does the same thing as
	supplying the resource "Winterp.servicePort: <portnum>" (see
	<<WINTERP Resources (~/.Xdefaults):>> above).  Note that specifying
	environment variable WINTERP_INET_PORTNUM overrides this command
	line argument (as well as resource ".servicePort").

***	[-serv_name <servname>]:

	setting this optional argument pair does the same thing as
	supplying the resource "Winterp.serviceName: <portnum>" (see
	<<WINTERP Resources (~/.Xdefaults):>> above).


** Usage: the WINTERP-Lisp Unix Domain Socket client (./../src-client/wl):

*** usage: wl [-f <socket-filepath>] [<s-expr>]

	The optional <socket-filepath> argument sets the pathname for the
	Unix Domain Socket eval-server.  By default, <socket-filepath> is
	"/tmp/.winterp_serv", you may want to specify a different
	<socket-filepath> if multiple 'winterp' applications are
	running. Alternately, you may want to hide the Unix Domain Socket
	from other users if you are on a multi-user machine. Note that you
	may specify <socket-filepath> via environment variable
	WINTERP_UNIX_SOCKET_FILEPATH. The environment variable sets
	<socket-filepath> for both 'wl' and 'winterp'.
	
	The <s-expr> argument is a single Lisp s-expression to be sent to
	WINTERP's Lisp listener. If no <s-expr> argument is given, 'wl'
	sends an EOF (==Control-D) to XLISP, which causes WINTERP to
	terminate. Note that the <s-expr> must be quoted with ['] so
	that the shell does not attempt to interpret the parentheses as
	shell commands.

	'wl' will "hang" waiting for WINTERP to finish the evaluation.
	When the evaluation completes, 'wl' prints the results of
	the evaluation to stdout, and returns exit status 0.
	If an error occurs in evaluation, an exit status of 128 is
	returned and the following is printed to stderr:
		"wl: an evaluation error occured in WINTERP server."
	Finally, if some other error occurs, e.g. network error,
	unable to bind socket, etc, then exit status of 1 is
	returned and an eror message will appear on stderr.

	If evaluation via 'wl' causes an error and *BREAKENABLE* is set
	(including by selecting "Error Break-Loop" or "Error Trace-Back"
	in the "WINTERP Control Panel), then 'wl' will hang until the
	break-loop exits, typically because the user has invoked functions
	'clean-up', 'top-level', or 'continue', or typed Control-C or
	Control-D into WINTERP's controlling terminal.

	Example: invoking the following in a UN*X command shell:
			wl '(load "rc-shell")'
	while there is a WINTERP running with a unix domain socket
	enable, will cause WINTERP to load the file "rc-shell" and pop up
	the widgetry associated with loading that file.


** Usage: the WINTERP-Lisp TCP/IP client (./../src-client/wl-tcpip):

*** usage: wl-tcpip [-h <hostname>] [-p <port>] [<s-expr>]
	
	The optional <hostname> argument allows you to specify the host
	upon which the WINTERP's eval-server is running. By default,
	'wl-tcpip' attempts to connect to a WINTERP server running at IP
	address 127.0.0.1. See the note below for further details.  The
	hostname may also be specified by setting environment variable
	WINTERP_INET_HOSTNAME.
	
	The optional <port> argument specifies a different port number for
	WINTERP's eval-server. The default is 23751; you may want to change
	the default (along with WINTERP's "Winterp.servicePort" resource)
	if 23751 is already defined in /etc/services. You will also need to
	change <port> if you are running multiple instances of WINTERP on
	the same machine. You may "simultaneously" set the <port> argument
	for 'wl-tcpip' as well as <<Winterp.servicePort>> resource
	in 'winterp' by setting environment variable WINTERP_INET_PORTNUM to
	the desired port number.

	The <s-expr> argument is a single Lisp s-expression to be sent to
	WINTERP's Lisp listener. If no <s-expr> argument is given, 'wl'
	sends an EOF (==Control-D) to XLISP, which causes WINTERP to
	terminate. Note that the <s-expr> must be quoted with ['] so
	that the shell does not attempt to interpret the parentheses as
	shell commands.
	
	'wl-tcpip' will "hang" waiting for WINTERP to finish the evaluation.
	When the evaluation completes, 'wl-tcpip' prints the results of
	the evaluation to stdout, and returns exit status 0.
	If an error occurs in evaluation, an exit status of 128 is
	returned and the following is printed to stderr:
		"wl-tcpip: an evaluation error occured in WINTERP server."
	Finally, if some other error occurs, e.g. network error,
	unable to bind socket, etc, then exit status of 1 is
	returned and an eror message will appear on stderr.

	If evaluation via 'wl-tcpip' causes an error and *BREAKENABLE* is set
	(including by selecting "Error Break-Loop" or "Error Trace-Back"
	in the "WINTERP Control Panel), then 'wl-tcpip' will hang until the
	break-loop exits, typically because the user has invoked functions
	'clean-up', 'top-level', or 'continue', or typed Control-C or
	Control-D into WINTERP's controlling terminal.

	Example: invoking the following in a UN*X command shell:
			wl-tcpip '(load "rc-shell")'
	while there is a WINTERP running with an inet domain socket
	enabled, will cause WINTERP to load the file "rc-shell" and pop up
	the widgetry associated with loading that file.

	NOTE-0: 'wl-tcpip' is not compiled in the WINTERP distribution by
	default -- cd <winterp-top-dir>/src-client/ and do
	"cc -O -o wl-tcpip wl-tcpip.c" to compile it. Likewise, the
	'winterp' binary itself does not compile with the TCP/IP server
	feature. To get the TCP/IP server, you must recompile WINTERP after
	 setting "#define WINTERP_WANT_INET_SERVER" in 
	./../src-server/config.h, or you should set 
	"WANT_INET_SERVER= -DWINTERP_WANT_INET_SERVER" in the appropriate
	makefiles. after recompilation run 'winterp' with the resource
	 "Winterp.enableInetServer: true".

	NOTE-1: By default, 'wl-tcpip' uses the IP address 127.0.0.1 as the
	hostname. This is the standard "loopback" or localhost address on
	all UN*X machines I've worked with. If your setup defines hostname
	"localhost" as a different I.P. address, you may need to specify
	'localhost' or `hostname` as <hostname>. You may see significant
	speed increases in 'wl-tcpip' by replacing "127.0.0.1" in
	./../src-server/config.h with the appropriate IP address and
	recompiling 'wl-tcpip.c' -- hostname lookup on some machines can be
	slow. If you are really concerned about the speed of making local
	connections, between 'winterp' and 'wl-tcpip', you should consider
	using 'wl' as described above.

==============================================================================

* Introduction to XLISP objects and Widgets.

WINTERP uses XLISP's object system as its interface to the class hierarchy
of widgets provided by Motif. Specifically, each Motif widget class is
represented by one or more object classes in WINTERP.  In order to best
understand the capabilities of WINTERP's Motif interface, a brief review of
the XLISP object system is in order. You may also want to consult the XLISP
documentation ./../doc/xlisp.doc and ./../doc/XlispRef.doc for a more
precise definition of the object system. Further examples may be found in
file ./../doc/XlispOOP.doc, Tim Mikkelsen's "XLISP 2.0 OBJECTS PRIMER."

XLISP Classes describe the type of a particular object by declaring a set
of variables held in each object. These "instance variables" may only be
accessed by "methods" that respond to "messages" sent to the object.
Methods are defined for particular classes, and functionality of other
classes may be incorporated into new classes via "inheritance". From XLISP,
Motif widget classes look just like normal XLISP objects -- that means that
you can easily extend the functionality of Motif widgets by adding your own
methods to a particular widget class. You may also use inheritance to
attach your own data structures to widgets. The result is that WINTERP
provides a very clean way to interactively rapid-prototype an application,
while also providing mechanisms for code structuring and reuse.  The latter
is necessary in evolving from prototype to a structured, maintainable, and
customizable deliverable.


** Creating new objects.

Create a new instance of a class by sending the message :NEW to
<a_class_instance>:

	(SEND <a_class_instance> :NEW <parameters>)

<a_class_instance> is in fact an instance of class CLASS. Class CLASS allows
you to define new class instances by specifying the instance variables and
parent class of a particular class.


** Declaring a class.

To declare a "base class" object, that is, an object with no parent object,
just send message :NEW to the object <CLASS>

	(SEND CLASS :NEW '(<ivar0> ... <ivarN>)
			 ['(<cvar0> ... <cvarM>)])

'(<ivar0> ... (ivarN>) are a list of symbols. Each <ivar-i> names an
instance variable of the class. '(<cvar0> ... <cvarM>)]) are an optional
list of variables that are shared among all instances of that particular
class.


** Defining methods.

When a "message" is sent to an object, XLISP searches for a "method" to
answer the message. A method is a piece of Lisp code that is executed when
a particular message is sent to an object. Within the code of a method, all
object instance and class variables are accessible. Furthermore, the symbol
'self' is bound to the object the message was sent to.

Methods are defined by sending the message :ANSWER to <a_class_instance>:

	(SEND a_class_instance :ANSWER <:msg> <parameters> <code>)

where <:msg> is a keyword symbol (a symbol with a ':' prefix) representing
the message; <parameters> are the arguments given along with the message.
See the documentation on "lambda lists" in winterp/doc/xlisp.doc for details.
<code> is a list of s-expressions which get evaluated in response to a message.
The lexical environment that existed for the call to :ANSWER will be used for
value and functional bindings during method evaluation.

If you need to remember what the syntax is, consider the memory-helper
    "this class :ANSWERs to :MESSAGE..." == (send <cls> :ANSWER :MESSAGE ...)


** Inheritance

So far, the object system we just described supports *encapsulation*.
Encapsulation is good programming practice because it helps localize and
detangle complexity. Unfortunately, encapsulation runs counter to
flexibility because making flexible use of an object may require that
certain groups of instance variables be accessed by different layers of new
functionality. Most often, one wants to *reuse* aspects of a particular
class in creating code that specializes and alters the functionality of
that class. A compromise between encapsulation and flexibility is found by
using *inheritance* in an object system. Inheritance is used to allow a
 *subclass* to specialize the functionality of its *parent class* (aka,
the *superclass*):

	(send Class :NEW '(<ivar0> ... <ivarN>)
                         '(<cvar0> ... <cvarM>)
			 <superclass>)

(<ivar0> ... <ivarN>) is a list of new instance variables in the subclass;
(<cvar0> ... <cvarN>) is a list of new class variables in the subclass;
<superclass> is a class instance representing the parent from which
the new subclass inherits variables and methods.

"Inheritance" is occurring because all the instance variables of all the
parent classes of the new subclass become the variables of each subclass
instance. Furthermore, all methods defined on a parent class may also be
used on a subclass instance. Note that while a subclass' methods can access
the variables defined on the parent classes, the reverse isn't true.


** Object initialization.

As mentioned earlier, new object instances are created by sending the
message :NEW to a class object. Sending the message :NEW to a class
automatically sends message :ISNEW to the newly created instance. By
default :ISNEW on an instance is a no-op method defined on class 'Object',
which is the implicit [(grand)*]parent of all instances. If you want to
initialize the instance/class variables of a particular class, you must
define an :ISNEW method on the class.  Any parameters originally sent to
the :NEW method will be passed on to the :ISNEW method and may be used to
initialize an object to outside-world parameters.


** Example of using OOP features of XLISP with Motif widgets:

The current implementation of the Motif widget class xmListWidgetClass
makes it less-than-straightforward to create "browsers" of dynamic
information.  The problem is that a "browser" is a kind of application that
lends itself to object oriented techniques that are not always
straightforward to support in C. One often has a collection of 'things'
that one wants to display in a 'list' and perform actions on the 'thing'
corresponding to the visual selection of an element in the displayed list.
xmListWidgetClass will display an array of XmStrings in a list. When one
or more elements in the list are selected, XmStrings corresponding to the
selected elements are returned. Since the XmStrings you put into the list
widget are not the XmStrings you get out, you must call XmStringCompare on
each element of the collection of 'things' to find out which 'thing' was
selected.  Presumably, you'll want to do more than just get back an
XmString...  normally one will want to access data structures associated
with the 'thing' so as to perform an action dependent on those structures.
This could be done with a lookup table, but there's also a better way...

WINTERP allows us to subclass the Motif list widget so as to make it have
the kind of functionality we want. This subclass will contain an additional
instance variable 'items' which is an array of arbitrary XLISP objects to
be displayed in a textual browser made from the list widget. These objects
can have completely different internal representations -- the only
requirement is that they follow the protocol of being able to respond to
the messages :DISPLAY_STRING and :DEFAULT_ACTION. :DISPLAY_STRING returns a
string representation of the object to be displayed in the browser.
:DEFAULT_ACTION is the action to be performed when a list item is browsed
(by double clicking on the item).

The following creates the subclass <List_Browser> from superclass
<XM_LIST_WIDGET_CLASS>:

	(setq List_Browser
		(send Class :NEW		;create a class inst
			'(items)		;new instance vars
			'()			;no class vars
			XM_LIST_WIDGET_CLASS))	;superclass

So now all instances of <List_Browser> will contain an instance variable
<items> and will respond to all the messages understood by the
XM_LIST_WIDGET_CLASS. We want our list browser to behave as described
above, so we define an :ISNEW method to initialize instance variable
<items> to the list of arbitrary objects to be displayed.  <items> gets
initialized to an array of objects, the list widget is created, and a
XmNdefaultActionCallback is setup so that a double click will send the
message :DEFAULT_ACTION to the browsed item:

	;; (send List_Browser :new <items_list> <managed_kwd>
        ;;                         <widget_name> <widget_parent>
        ;;                         <XmList-resource-value-pairs...>)
	;; <items_list> is a list of BROWSER_OBJECTs as described above.
	;; <managed_kwd> -- a keyword, either :MANAGED or :UNMANAGED
        ;; <widget_name> -- a STRING giving the X-resource name for the widget
	;; <widget_parent> -- a WIDGET, the parent managing this widget.
	;; <XmList-resource-value-pairs...> -- these are the arguments that
	;;       will be passed on to the list widget
        ;;
	(send List_Browser :answer :ISNEW
             '(items_list managed_k widget_name widget_parent
               &rest args)
	      '(
		(let* ((items_end_idx (length items_list))
		       (display_items (make-array items_end_idx)))

		  ;; initialize the 'items' instance variable so that it
		  ;; holds all the BROWSER_OBJECTs passed in <items_list>
		  (setq items (make-array items_end_idx)) ;create the array
		  (do (                         ;copy elts from list to array
		       (i    0          (1+ i))
		       (elts items_list (cdr elts)))
		      ;; loop till no more elts
		      ((null elts))
		      ;; loop body
		      (setf (aref items i) (car elts))
		      (setf (aref display_items i) 
			    (send (car elts) :display_string))
		      )

		  ;; Call :ISNEW on the XM_LIST_WIDGET_CLASS superclass;
                  ;; This actually creates the Motif widget, by calling
                  ;; XmCreateScrolledList()...
		  (apply #'send-super :isnew
			 managed_k :scrolled widget_name widget_parent
			 :XMN_SELECTION_POLICY :browse_select
			 :XMN_ITEMS            display_items
			 :XMN_ITEM_COUNT       items_end_idx
			 args)
		  )

		;; set up a callback on the list widget initialized above such
		;; that a double click on the browser-item will send the
		;; message :default_action to the BROWSER_OBJECT.
		(send-super :add_callback :xmn_default_action_callback
			    '(callback_item_position)
			    '((send (aref items (1- callback_item_position))
				    :default_action))
			    )
		)
	      )


In the above code, SEND-SUPER works just like send, except that it doesn't
require you to give it the object to send the message to.  Instead, it
implicitly assumes that it will be called from within a method, and will
automatically send the message to a superclass of the object's class.  The
(apply #'send-super ...) form is actually calling the :ISNEW (instance
initializer) method on XM_LIST_WIDGET_CLASS, which actually creates the
widget via XmCreateScrolledList(). The APPLY of '&rest args' allow us to
splice in the optional sequence of X-resource name/value pairs passed to
the :ISNEW method to the superclass :ISNEW method that actually creates the
widget. Finally, method :ADD_CALLBACK is the WINTERP equivalent of
XtAddCallback(). See the documentation on methods on WIDGET_CLASS for more
details.

The Motif List widget also defines a number of "methods" implemented as C
routines such as XmListAddItem(), XmListAddItemUnselected(),
XmListDeleteItem(), and XmListDeletePos(). In WINTERP, we define these as
methods :ADD_ITEM, :ADD_ITEM_UNSELECTED, :DELETE_ITEM, and :DELETE_POS
respectively. Since these methods modify the collection of objects
represented by the list widget, we must update the internal array of
objects <items> to correspond with the items displayed. We do this by
intercepting those messages to the superclass of class <List_Browser> and
handle them in <List_Browser> so as to update the appropriate data:

	(send List_Browser :answer :ADD_ITEM '(item position)
	      '(
		(setq items (array-insert-pos items (1- position) item))
		(send-super :add_item 
			    (send item :display_string) 
			    position)
		)
	      )

	(send List_Browser :answer :ADD_ITEM_UNSELECTED '(item position)
	      '(
		(setq items (array-insert-pos items (1- position) item))
		(send-super :add_item_unselected 
			    (send item :display_string)
			    position)
		)
	      )

	(send List_Browser :answer :DELETE_ITEM '(item)
	      '(
		;; this is too lame to implement... requires that we compare
		;; item with the result of :display_string done on every elt
		;; of ivar 'items'
		(error "Message :DELETE_ITEM not supported in List_Browser")
		)
	      )

	(send List_Browser :answer :DELETE_POS '(position)
	      '(
		(setq items (array-delete-pos items (1- position)))
		(send-super :delete_pos position)
	       )
	     )

To see how this subclassed list browser is used, and also to see how one
might write a sample application in WINTERP using the object oriented
features of XLISP, see some of the examples programs in WINTERP's examples
directory. The directory ./../examples/lib-widgets/ contains a number of
subclassed widgets which give other examples of the kinds of things you can
do with WINTERP's object oriented programming features. In particular:

**	./../examples/lib-widgets/application.lsp:

	Defines WINTERP:APPLICATION-WIDGET-CLASS a subclass of
	XM_MAIN_WINDOW_WIDGET_CLASS which encapsulates most of the
	framework for creating applications, including the simple
	creation of menubars, a message area, etc.  An example of using
	WINTERP:APPLICATION-WIDGET-CLASS is
	./../examples/lib-widgets/fake-app1.lsp.

**	./../examples/lib-widgets/object-br.lsp:

	Defines	Object_Browser_Widget_Class, which is a subclass of
	String_Browser_Widget_Class, which in turn is a subclass of
	XM_LIST_WIDGET_CLASS. Object_Browser_Widget_Class is useful for
	creating information browsers over collections of
	objects. Example uses include ./../examples/grep-br.lsp
	which provides a file search browser based on the UN*X "grep"
	command; ./../examples/mail-br.lsp is a simple mail browser
	based on the MH scan command;  ./../examples/dircmp.lsp is a
	directory and file comparison browser based on UN*X commands
	"cmp" and "diff".

**	./../examples/lib-widgets/simple-RC.lsp:

	Defines WINTERP:RADIO-BOX-WIDGET-CLASS, 
	WINTERP:OPTION-MENU-WIDGET-CLASS, WINTERP:MENU-BAR-WIDGET-CLASS,
	WINTERP:POPUP-MENU-WIDGET-CLASS, WINTERP:PULLDOWN-MENU-WIDGET-CLASS,
	WINTERP:CHECK-BOX-WIDGET-CLASS.	These provide for simplified creation
	of common UI functions.

==============================================================================

* UN*X Subprocesses:

#ifdef WINTERP_EXPECT_SUBPROCESS

	The 'expect' library in WINTERP provides the ability to control
	multiple asynchronous UN*X subprocesses. The subprocesses talk
	to the WINTERP process through ptys; WINTERP and XLISP can read/
	write to the pty, which appears as a bidirectional stream
	to any stream primitive. See also routines
	XT_ADD_INPUT/:READ_LINE_TO_STRING and
	XT_ADD_INPUT/:READ_SEXP_TO_USTREAM.

	Examples using subprocesses:
	** winterp/examples/subcalc.lsp:
	   Demo of spawning an interactive subprocess and interacting with
	   the subrpocess through XT_ADD_INPUT/:READ_LINE_TO_STRING.
	   Subprocess can be off doing a long calculation while WINTERP GUI
	   remains active.
	** winterp/examples/subshell.lsp:
	   Demo of spawning an interactive shell subprocess and interacting
	   with the subrpocess through XT_ADD_INPUT. Subprocess can be
	   off doing a long computation while WINTERP GUI remains active.
	** winterp/examples/modem-dialer.lsp:
	   Dials phone numbers on a Hayes-Compatible modem by running
	   kermit(1) as an asynchronous subprocess. Hayes-compatible commands
	   may be sent to the modem directly by entering text in the
	   edit-field widget directly below the menu bar. The app.  provides
	   a browser of people/phone-numbers -- in the browser, double-left
	   click (or single-middle click) on the person to dial his/her
	   number (details on mouse and key bindings below).  Put your
	   database of people in file "$HOME/people.lsp" (see variable
	   *MODEM-DIALER-FILEPATH* below)
	** winterp/examples/lib-widgets/clock-disp.lsp:
	   Define Clock_Display_Widget_Class, a subclass of
	   XM_LABEL_GADGET_CLASS which displays the time in Month/Date/Year
	   Hour:Minute format. This makes use of the Unix 'date' command
	   "date '+\#(%y %m %d %H %M)'" -- if this doesn't work on your
	   system, it's because your unix isn't SVID2, XPG2, XPG3, or POSIX.2
	   compliant and can't understand the special '+' formatting option
	   for 'date'.

** Function EXP_SPAWN (exp_spawnv()):

	(EXP_SPAWN <executable-filepath> <arg0> [<arg1> [[<arg2>] ...] )
		--> returns a STREAM (with no buffering, however)
		    returns NIL if an error occurs...

		<executable-filepath> -- a string, the full path and name
					 of the executable.
		<arg0>                -- a string corresponding
					 to argv[0] in the spawned
					 executable, this should typically be
					 the same as <executable-filepath>.
                <arg-i>               -- optional string arguments
					 corresponding to argv[i] passed to
					 the spawned executable.

	Call EXP_GET_PID after calling EXP_SPAWN to find out process ID.
	To shut down the subprocess, call CLOSE on the returned STREAM,
	followed by a call to EXP_WAIT.
	
	Prior to calling EXP_SPAWN, if EXP_STTY_INIT is called, the string
	arg to that function is interpreted in the style of stty(1)
	arguments as further configuration for any pty used by future
	spawn commands. For example, exp_stty_init = "sane" repeats the
	default initialization.
	
	If EXP_STTY_INIT was never called prior to calling EXP_SPAWN, then
	the pty is initialized the same way as the user's tty.  When this
	is not possible (i.e., expect was not started with a controlling
	terminal), spawn uses the tty settings that correspond to "stty
	sane".
	
	Note: it is ok to write to the EXP_SPAWN-created subprocess with
	FORMAT, PRINT, PRIN1, PRINC PPRINT, TERPRI, WRITE-CHAR, and
	WRITE-BYTE. However, one must be very careful in reading from the
	STREAM created by EXP_SPAWN -- because you can't know how many
	characters are "ready for reading", you shouldn't use READ,
	READ-LINE, FSCANF-FIXNUM FSCANF-FLONUM or FSCANF-STRING because they
	might cause WINTERP to lock-up waiting to read a character that may
	never arrive.  For reading, you should use XT_ADD_INPUT/:READ,
	XT_ADD_INPUT/:READ_LINE_TO_STRING, or
	XT_ADD_INPUT/:READ_SEXP_TO_USTREAM.

	Description of exp_spawnv:
	-------------------------
	exp_spawnv forks a new process so that its stdin, stdout, and
	stderr can be written and read by the current process.  file is
	the name of a file to be executed.  The arg pointers are
	null-terminated strings.  Following the style of execve(), arg0
	(or argv[0]) is customarily a duplicate of the name of the file.
	
	If the process is successfully created, a file descriptor is
	returned which corresponds to the process's stdin, stdout and
	stderr.  A stream may be associated with the file descriptor by
	using fdopen().  (This should almost certainly be followed by
	setbuf() to unbuffer the I/O.)
	
	Closing the file descriptor will typically be detected by the
	process as an EOF.  Once such a process exits, it should be waited
	upon (via wait) in order to free up the kernel process slot.
	(Some systems allow you to avoid this if you ignore the SIGCHLD
	signal).
	
	After a process is started, the variable exp_pid is set to the
	process-id of the new process.
	
	The spawn functions uses a pty to communicate with the process.
	By default, the pty is initialized the same way as the user's tty.
	When this is not possible (i.e., expect was not started with a
	controlling terminal), spawn uses the tty settings that correspond
	to "stty sane".  If the variable exp_stty_init is defined, it is
	interpreted in the style of stty arguments as further
	configuration for any pty used by future spawn commands.  For
	example, exp_stty_init = "sane"; repeats the default
	initialization.

** Function EXP_POPEN (exp_popen()):

	(EXP_POPEN <command>)
		--> returns a STREAM (FILE*) or NIL
	
	Unlike POPEN, EXP_POPEN allows for reading/writing to the
	<command> subprocess; executing <command> doesn't block WINTERP.
	
	Call EXP_GET_PID after calling EXP_POPEN to find out process ID.
	To shut down the subprocess, call CLOSE on the returned STREAM,
	followed by a call to EXP_WAIT.
	
	Prior to calling EXP_POPEN, if EXP_STTY_INIT is called, the string
	arg to that function is interpreted in the style of stty(1)
	arguments as further configuration for any pty used by future
	spawn commands. For example, exp_stty_init = "sane" repeats the
	default initialization.
	
	If EXP_STTY_INIT was never called prior to calling EXP_POPEN, then
	the pty is initialized the same way as the user's tty.  When this
	is not possible (i.e., expect was not started with a controlling
	terminal), spawn uses the tty settings that correspond to "stty
	sane".
	
	Note: it is ok to write to the EXP_SPAWN-created subprocess with
	FORMAT, PRINT, PRIN1, PRINC, PPRINT, TERPRI, WRITE-CHAR, and
	WRITE-BYTE.  However, one must be very careful in reading from the
	STREAM created by EXP_SPAWN -- because you can't know how many
	characters are "ready for reading", you shouldn't use READ,
	READ-LINE, FSCANF-FIXNUM FSCANF-FLONUM or FSCANF-STRING because they
	might cause WINTERP to lock-up waiting to read a character that may
	never arrive.  For reading, you should use XT_ADD_INPUT/:READ,
	XT_ADD_INPUT/:READ_LINE_TO_STRING, or
	XT_ADD_INPUT/:READ_SEXP_TO_USTREAM.

	Description of exp_popen:
	-------------------------
	Similar to exp_spawnv above, exp_popen is yet another interface,
	styled after popen().  It takes a Bourne shell command line, and
	returns a stream that corresponds to the process's stdin, stdout
	and stderr.

** Function EXP_GET_PID (exp_pid):

	(EXP_GET_PID)
		--> FIXNUM representing the process ID of the last
		    EXP_POPEN or EXP_SPAWN.

	Description of exp_pid:
	-----------------------
	After a process is started, the variable exp_pid is set to the
	process-id of the new process. (EXP_GET_PID) retrieves that value.

** Function EXP_STTY_INIT (exp_stty_init):

	(EXP_STTY_INIT <stty-string>)
		--> returns NIL.

	If EXP_STTY_INIT is called prior to calling EXP_POPEN or
	EXP_SPAWN, <stty-string> is interpreted in the style of stty(1)
	arguments as further configuration for any pty used by future
	EXP_POPEN or EXP_SPAWN commands.

	For example,
	(EXP_STTY_INIT "sane") --
		repeats the default initialization.
	(EXP_STTY_INIT "-echo -echoe -echok") --
		turns off echoing of text written to the subprocess.

	If EXP_STTY_INIT was never called prior to calling
	EXP_POPEN or EXP_SPAWN, then the pty is initialized the same way
	as the user's tty.  When this is not possible (i.e., WINTERP was
	not started with a controlling terminal), spawn uses the tty
	settings that correspond to "stty sane".

** Function EXP_WAIT (wait(2)):

	(EXP_WAIT)
		--> returns dotted pair (pid . exit-status) on success;
	            returns dotted pair (-1  . sys_errlist[errno]) on failure.

	Call this after calling CLOSE on stream returned by
	EXP_SPAWN or EXP_POPEN. If the process hasn't existed or
	gotten killed (see EXP_KILL), this call will hang.
	Interrupt WINTERP with ^C from the controlling terminal to
	unhang an erroneous EXP_WAIT.

** Function EXP_KILL (kill(2)):

	(EXP_KILL <signal> <proccess-id-fixnum>)
		--> returns NIL

	Calls kill(2) returning NIL if successful. Signals an error
	otherwise.  See kill(2) for details/semantics.

	<signal> is either a FIXNUM or a STRING. See
	"/usr/include/sys/signal.h" on your system for appropriate values
	for <signal>. Alternately, you can specify a STRING name for the
	signal -- the string name is the same as the SIG* names in
	"/usr/include/sys/signal.h", but without the "SIG" prefix. For
	example (EXP_KILL <pid> "INT") sends a SIGINT to <pid>.

	<process-id-fixnum> is a FIXNUM representing a process ID. Process
	id FIXNUMs are returned, for example, by EXP_GET_PID.

#endif /* WINTERP_EXPECT_SUBPROCESS */

** Function POPEN:

	(POPEN <shell-command> :direction <direction>)
		    <shell-cmd>	is a string which is sent to shell
				/bin/sh and is executed as command.
		    <direction>	a keyword symbol, :input means a stream
				is created that reads from stdout of
				<shell-cmd>; :output means a stream
				is created that writes to stdin of 
				<shell-cmd>. (:input is the default.)
		    returns	a stream, or NIL if the pipe or /bin/sh 
				process couldn't be created.

	This function start a process and open a pipe as a read/write stream.

** Function PCLOSE:

	(PCLOSE <stream>)
		    <stream>	a stream object created by POPEN
		    returns	T if the command executed successfully, else
				returns the integer exit status of
				<shell-cmd>.

	This function closes a pipe stream as opened by POPEN.

** Function SYSTEM:

	(SYSTEM <shell-cmd>)
		    <shell-cmd> is a string which is sent to shell
				/bin/sh and is executed as command.
		    returns	T if the command executed successfully,
				else returns the integer exit status of
				<shell-cmd>.

	This function runs a process, sending output (if any) to
	stdout/stderr.

==============================================================================

* Input callbacks -- call callback when input available for reading:

	XT_ADD_INPUT in WINTERP extends the functionality of interfacing to
	files, pipes, fifos, sockets, subprocesses, etc.
	:READ_LINE_TO_STRING option for XT_ADD_INPUT simplifies
	interfacing to line-oriented data sources. :READ_SEXP_TO_USTREAM
	facilitates communications between lisp programs. The
	former fires a callback once per line of input, whereas
	the latter fires a callback once per complete Lisp s-expression
	(matching levels of parentheses).
	
	Examples utilizing XT_ADD_INPUT include:
	** winterp/examples/xtaddinput.lsp:
	** winterp/examples/fifo-read.lsp:

	See also the following examples discussed above:
	<<winterp/examples/subcalc.lsp:>>
	<<winterp/examples/subshell.lsp:>>
	<<winterp/examples/modem-dialer.lsp:>>
	<<winterp/examples/lib-widgets/clock-disp.lsp:>>

** XT_ADD_INPUT (XtAppAddInput()):

	This primitive takes two forms of arguments:
	  (XT_ADD_INPUT <file> <condition> <code>) or
		--> returns: <fdinputcb_object>
	  (XT_ADD_INPUT <fdinputcb-obj>)
		--> returns: <fdinputcb_object>
	
	<file> is a XLISP stream (not a u-stream though).
	
	There are three possibilities for <condition>: 
	 (1) <condition> == {:READ, :WRITE, :EXCEPT}
		These correspond to XtAppAddInput() options 
		XtInputReadMask, XtInputWriteMask, XtInputExceptMask options:
		:READ   -- input-fd is ready to be read. The reader must
			be a nonblocking read, e.g. 'read-char', 'read-byte',
			'fscanf-string'. WARNING: do not use 'read-line' or
			'read' as these will cause WINTERP to
			deadlock, requiring you to kill the process!
		:WRITE  -- input-fd is ready to be written (this is almost
			always true -- there's really no reason to use
			XT_ADD_INPUT/:write).
		:EXCEPT -- an exception condition has occured on input-fd.
	 (2) <condition> == :READ_LINE_TO_STRING
		In this case, <code> will get called with symbol
		FDINPUTCB_STRING bound to a string representing a
		line of text. Use this to read text from a stream
		line-by-line, calling <code> only once per line read from
		<file>. Note: this routine will signal an error if the
		line being read ends up being longer than 1023 characters.
	 (3) <condition> == :READ_SEXP_TO_USTREAM
		In this case, <code> will get called with symbol
		FDINPUTCB_USTREAM bound to an unnamed stream representing the
		s-expression just read. This option may be used to read-in 
		parentheses-bounded expressions, calling <code> only once per
		read s-expression. Within <code> one can pass the value of
		FDINPUTCB_USTREAM on to 'READ' for parsing,
		'GET-OUTPUT-STREAM-STRING' to return a string representation of
		the s-expr, etc.
	
	<code> is a list of lisp expressions that are evaluated when the
	fdinputcb occurs. During the fdinputcb, the lexical environment
	that existed for the call to XT_ADD_INPUT will be used for value
	and functional bindings.  Additionally, the symbol FDINPUTCB_OBJ
	is bound to the <fdinputcb-obj> that caused the
	fdinputcb. FDINPUTCB_FILE is bound to <file> argument from the
	call to XT_ADD_INPUT. Additionally, FDINPUTCB_STRING or
	FDINPUTCB_USTREAM may get bound if <condition> is
	:READ_LINE_TO_STRING or :READ_SEXP_TO_USTREAM.
	
	The form (XT_ADD_INPUT <fdinputcb-obj>) may be used to more
	efficiently reschedule previously removed fdinputcbs. Instead of
	creating a new closure around the same <code> each time a
	recurrent fdinputcb is rescheduled, this second form for
	XT_ADD_INPUT allows you to take the <fdinputcb-obj> from a
	previously removed fdinputcb and reschedule a new fdinputcb using
	the closure setup by the initial call to (XT_ADD_INPUT <file>
	<mask> <code>).  During the execution of <code>, the symbol
	FDINPUTCB_OBJ is bound to <fdinputcb-obj> so that you don't need
	to keep around a global variable for each recurrent fdinputcb.
	
	The returned <fdinputcb-obj> may be passed into the functions
	(XT_REMOVE_INPUT <fdinputcb-obj>), or
	(XT_ADD_INPUT <fdinputcb-obj>).

	WARNING: prior to closing <file> associated with a XT_ADD_INPUT,
	once must call XT_REMOVE_INPUT on the <fdinputcb-obj>. Likewise
	in for subprocesses, one should remove the input callback
	and close the associated <file>  if the associated subprocess exits.

** XT_REMOVE_INPUT (XtRemoveInput()):

	(XT_REMOVE_INPUT <fdinputcb_obj>)
		--> returns T.

	<fdinputcb_obj> is the value returned by XT_ADD_INPUT. 

	This routine removes an input callback previously
	scheduled with XT_ADD_INPUT. 

** INPUT_ACTIVE_P :

	(INPUT_ACTIVE_P <fdinputcb_obj>)
		--> returns T if <fdinputcb_obj> is still scheduled, returns
		    NIL if <fdinputcb_obj> input source was deactivated by
	            XT_REMOVE_INPUT.
	
	<fdinputcb_obj> is the value returned by XT_ADD_INPUT.

==============================================================================

* XLISP STREAM EXTENSIONS:

** Function FSCANF-FIXNUM:

	(FSCANF-FIXNUM <stream> <format>)
		    <stream>	a stream object created via OPEN or POPEN.
				Will give an error for "unnamed streams".
		    <format>	a format string containing a single
				conversion directive that will result in
				an integer valued conversion %d, %u, %o,
				%x, %ld, %lu, %lo and %lx style conversions 
				are acceptable for this routine. See the
				manual page for fscanf(3x) for details.
		    returns	an integer if fscanf(3x) reports that
				the conversion specified by <format> 
				succeeded. Returns NIL if the conversion
				wasn't successful, or if EOF was reached.

	This function reads a fixnum value from a stream using fscanf(3x).

	WARNING: specifying a <format> that will result in the
	conversion of a result larger than sizeof(long) will result in
	corrupted memory and core dumps. 

** Function FSCANF-STRING

	(FSCANF-STRING <stream> <format>)
		    <stream>	a stream object created via OPEN or POPEN.
				Will give an error for "unnamed streams".
		    <format>	a format string containing a single
				conversion directive that will result in
				a string valued conversion. %s, %c, and
				%[...] style conversions are acceptable for
				this routine. See the manual page for
				fscanf(3x) for details.
		    returns	a string if fscanf(3x) reports that
				the conversion specified by <format> 
				succeeded. Returns NIL if the conversion
				wasn't successful, or if EOF was reached.

	This function reads a string value from a stream using fscanf(3x).

	WARNING: specifying a <scanf-format> that will result in the
	conversion of a result larger than 1024 characters will result
	in corrupted memory and core dumps.

** Function FSCANF-FLONUM:

	(FSCANF-FLONUM <stream> <format>)
		    <stream>	a stream object created via OPEN or POPEN.
				Will give an error for "unnamed streams".
		    <format>	a format string containing a single
				conversion directive that will result in
				a FLONUM valued conversion. %e %f or %g
				are valid conversion specifiers for this
				routine. See the manual page for fscanf(3x)
				for details.
		    returns	a float if fscanf(3x) reports that
				the conversion specified by <format> 
				succeeded. Returns NIL if the conversion
				wasn't successful, or if EOF was reached.

	This function reads a float from a stream using fscanf(3x).

	WARNING: specifying a <scanf-format> that will result in the
	conversion of a result larger than sizeof(float) will result in
	corrupted memory and core dumps.

** Function FFLUSH:

	(FFLUSH <output-stream>)
		--> returns T on success, else error
	
	Calls fflush(3S) on <output-stream>

** Function REDIRECT_STDERR:

	(REDIRECT_STDERR)
		--> returns an input-stream suitable for reading.
	
	The returned input-stream represents the text sent to the unix standard
	error (stderr), both for the WINTERP application and for any
	subprocesses invoked by WINTERP. This is typically used to trap error
	output from subprocesses and pop up a dialog indicating a problem.
	
	The stream can be used for reading by existing XLISP/WINTERP reading
	primitives, e.g. READ-LINE, READ-CHAR, FSCANF-FIXNUM, FSCANF-STRING,
	FSCANF-FLONUM, etc.
	
	The returned input-stream is non-blocking, which means you may read
	more than one character at a time without worrying about a deadlock.
	However, note that just because you've been able to read N characters
	in one read operation, doesn't mean you've read all characters output
	on STDERR. To retrieve the full contents, you need to keep on reading
	until you've hit EOF. 
	
	Instead of polling the stream (till hitting EOF) to see if more chars
	have been read, it is better to add an input callback via XT_ADD_INPUT
	and have the callback code read from the input-stream whenever there
	are characters to be read.

** Function REDIRECT_STDOUT:

	(REDIRECT_STDOUT)
		--> returns an input-stream suitable for reading.
	
	This is just like REDIRECT_STDERR except that the returned input-stream
	represents the text sent to the unix standard output (stdout).

==============================================================================

* XLISP extensions:

** Function LOAD:

	Just a note on the way files are searched for from the XLISP
	'LOAD' primitive. When a Winterp-Lisp file is 'LOAD'ed, the following
	path searching occurs in looking for the file to load. If the file
	begins with a '/' or '.' then that file is
	loaded, otherwise, the following search behavior takes place:

	(1) The Unix environment variable "XLPATH" is consulted and searched.
	    XLPATH is a colon-separated sequence of paths.

	(2) if that isn't set, the X resource Winterp.lispLoadPath is
	    consulted to retrieve a sequence of paths comprised of
	    colon-separated paths (e.g.
		/users/mayer/:/users/mayer/tmp:/users/mayer/winterp/).
	    This path is then searched.

	(3) If the file isn't found on that path, the resource
	    <<Winterp.lispLibDir>> is consulted to find another directory for
	    the module. That directory is searched.

	(4) Finally, if the file isn't found anywhere on the aforementioned
	    paths, the current directory is searched for the requested file.

	(5) Finally, if no file is found, LOAD returns NIL.

** Function REQUIRE:

	(REQUIRE <module-name>)
		--> returns T if the requested module got loaded from a file.
		    returns NIL if the requested module had previously been
		    loaded (that is, (PROVIDE <module-name>) had been called).
		    If the module couldn't be loaded, will signal an error.

	<module-name> is a STRING, specifying the name of the file to load.
	<module-name> can be the full path to the file (e.g.
	"/users/mayer/foo.lsp"), or a filename plus extension (e.g.
	"lib-utils/unixstuf.lsp", or "foo.lsp"), or a filename without
	extension (e.g. "lib-utils/unixstuf" or "foo").

	REQUIRE is typically used to load "libraries" in WINTERP. Library
	files which are to be loaded by REQUIRE should have a (PROVIDE
	<module-name>) at the end which tells REQUIRE the desired module
	has been loaded succesfully.  REQUIRE will not load a file which
	has previously been PROVIDED, thus achieving the effect of only
	loading a given module once, even if a particular module is
	REQUIRE'd multiple times throughout the files that comprise a
	given application.

	When REQUIRE determines that <module-name> hasn't previously been
	loaded, it uses the same mechanism and load paths as used by the
	XLISP LOAD command.  First, the Unix environment variable "XLPATH"
	is consulted; if that isn't set, the X resource
	Winterp.lispLoadPath is consulted to retrieve a sequence of paths
	comprised of colon-separated paths (e.g.
	/users/mayer/:/users/mayer/tmp:/users/mayer/winterp/). If the
	required module isn't found on that path, the resource
	Winterp.lispLibDir is consulted to find another directory for the
	module. Finally, if the required module isn't found anywhere on
	the aforementioned paths, the current directory is searched for
	the requested file. If no file is found, an XLISP error is
	signalled.

	Note that (REQUIRE "lib-utils/unixstuf.lsp") will load file
	"unixstuf.lsp" even if (PROVIDE "lib-utils/unixstuf") had been
	called by a previous successful LOAD or REQUIRE of that file.
	(REQUIRE "lib-utils/unixstuf.lsp") will load the same file twice,
	because "lib-utils/unixstuf.lsp" is not equal to
	"lib-utils/unixstuf". To avoid confusion on this you should always
	specify <module-name> for PROVIDE and REQUIRE without the ".lsp"
	extension -- "<module-name>.lsp" is the filename that will get
	loaded by (REQUIRE <module-name>)...

	The global variable *MODULES* is set to a list of <module-name>
	which have been previously PROVIDE'd...

** Function PROVIDE:

	(PROVIDE <module-name>)
		--> returns NIL if <module-name> has already been PROVIDE'd;
			    T   if <module-name> wasn't previously PROVIDE'd.

	<module-name> is a STRING, specifying the name of a module/file that
	has been loaded succesfully. <module-name> is typically
	a filename plus extension (e.g. "lib-utils/unixstuf.lsp", or
	"foo.lsp"), or a filename without extension (e.g. "lib-utils/unixstuf"
	or "foo").

	PROVIDE and REQUIRE are typically used to load "libraries" in
	WINTERP.  Library files which are to be loaded by REQUIRE should
	have a (PROVIDE <module-name>) at the end which tells REQUIRE the
	desired module has been loaded succesfully. REQUIRE will not load
	a file which has previously been PROVIDED, thus achieving the
	effect of only loading a given module once, even if a particular
	module is REQUIRE'd multiple times throughout the files that
	comprise a given application.
	
	Note that (REQUIRE "lib-utils/unixstuf.lsp") will load file
	"unixstuf.lsp" even if (PROVIDE "lib-utils/unixstuf") had been
	called by a previous successful LOAD or REQUIRE of that file
	(REQUIRE "lib-utils/unixstuf.lsp") will load the same file twice,
	because "lib-utils/unixstuf.lsp" is not equal to
	"lib-utils/unixstuf". To avoid confusion on this you should always
	specify <module-name> for PROVIDE and REQUIRE without the ".lsp"
	extension -- "<module-name>.lsp" is the filename that will get
	loaded by (REQUIRE <module-name>)...
	
	The global variable *MODULES* is set to a list of <module-name>
	which have been previously PROVIDE'd...

** Function COPY-ARRAY:

	(copy-array <src> <dest> [<dest-pos>])  COPY INTO A PREALLOC'd ARRAY
	     <src>	the array to copy from
	     <dest>	the array to copy to, preallocated by MAKE-ARRAY
	     <dest-pos>	the integer offset in <dest> for beginning the copy
			If <dest-pos> is omitted, this defaults to 0.
	     returns	<dest>.

** Function ARRAY-INSERT-POS:

	(array-insert-pos <array> <pos> <elt>)	INSERT A NEW ELEMENT IN ARRAY
	    <array>	an array into which we want to insert a new element
	    <pos>	the integer index in <array> for inserted element;
			<pos> < 0 will cause the new element to be appended.
	    <elt>	any lisp value
	    returns	a new array that is one element longer than <array>;

** Function ARRAY-DELETE-POS:

	(array-delete-pos <array> <pos>)  DELETE AN ELEMENT FROM AN ARRAY
	    <array>	an array into which we want to delete an element
	    <pos>	the integer index for the element to delete in <array>;
			<pos> < 0 will delete the last element of the array.
	    returns	a new array that is one element shorter than <array>

** Function READ_EVAL_PRINT:

	(READ_EVAL_PRINT <ustream>)
		--> returns T if success, NIL if hit EOF, or FIXNUM if error.
	
	This gives programmatic access to the top-level read/eval/print
	routine. By top-level, I mean that it will act like the top-level
	R.E.P w/r/t using the global environment and setting up error and
	breakloop returns.

** Function TRACE (new names to trace):

	(TRACE <name-sym>)

	The XLISP trace function prints information prior and subsequent
	to calling the code associated with <name-sym>.

	WINTERP extends XLISP trace by permitting <name-sym> to be
	(1) a callback resource-name, e.g.
			(trace :XMN_ACTIVATE_CALLBACK)
	    -- any time an activate callback fires in any widget,
	       some information is printed on the callback,
	       callback the assiciated call_data symbols, etc.
	(2) An event handler, from :add_event_handler WIDGET_CLASS method,e.g.:
			(trace 'EVHANDLER)
	    -- any time an event-handler fires, info is printed.
	(3) An input callback, from xt_add_input, e.g.
			(trace 'FDINPUTCB)
	    -- any time an input callback fires, info is printed.
	(4) A timeout, from xt_add_timeout, e.g.
			(trace 'XT_TIMEOUT)
	    -- any time a timeout callback fires, info is printed.

==============================================================================

* XT_ADD_TIMEOUT / XT_REMOVE_TIMEOUT == XtAppAddTimeout() / XtRemoveTimeout()

	(XT_ADD_TIMEOUT <interval> <code>)
			--> returns a <timeout_obj> 

	<interval> is a FIXNUM, the number of milliseconds before the
	timeout fires.

	<code> is a list of Lisp expressions that are evaluated when the
	timeout	occurs. During the timeout, the lexical environment that
	existed for the call to XT_ADD_TIMEOUT will be used for value and
	functional bindings. Additionally, the symbol TIMEOUT_OBJ is bound
	to the timeout object that caused the timeout.

	A variant of the above form allows efficient scheduling of
	recurrent timeouts when called from within <code>
		(XT_ADD_TIMEOUT <interval> TIMEOUT_OBJ)
	Instead of creating a new closure around the same <code> each time
	a recurrent timeout is rescheduled, this second form for XT_ADD_TIMEOUT
	allows you to take the TIMEOUT_OBJ from a previously expired
	timeout and reschedule a new timeout using the closure setup by the
	initial call to (XT_ADD_TIMEOUT <interval> <code>).  During the
	execution of <code>, the symbol TIMEOUT_OBJ is bound to
	<timeout-obj> so that you don't need to keep around a global
	variable for each recurrent timeout.

	The timeout scheduled by XT_ADD_TIMEOUT may be removed by passing
	<timeout_obj> into the primitive XT_REMOVE_TIMEOUT:
		(XT_REMOVE_TIMEOUT <timeout_obj>)
        <timeout_obj> is the value returned by XT_ADD_TIMEOUT.

	To test whether the timeout associated with a <timeout_obj> has
	expired, use:
		(TIMEOUT_ACTIVE_P <timeout_obj>)
			--> returns T if <timeout_obj> is still scheduled;
			    returns NIL if <timeout_obj> has expired or if
			    the timeout was inactivated by XT_REMOVE_TIMEOUT.

==============================================================================

* Widget Primitives:

** Function WIDGETOBJP:

	(WIDGETOBJP <expr>)
		--> returns T if argument is a WIDGETOBJ, else NIL.

	WIDGETOBJP is a type predicate testing to see if a value is 
	a widget or gadget object. 

** XT_MANAGE_CHILDREN == XtManageChildren():

	(XT_MANAGE_CHILDREN <widgets...>)
		--> returns T.
	
	Given <widgets...>, an ARRAY or list of WIDGETOBJs, all of which
	must be children of the same parent, this primitive will add those
	widgets to their parent-widget's managed list, which means they
	will become visible (if mapped) and will take up space within the
	managing widget.

	If the shell widget ancestor of <widgets...> has been :REALIZE'd,
	calling XT_MANAGE_CHILDREN on a sequence of child widgets is
	more efficient than specifying the :MANAGED option to each
	child-widget creation form, or sending the :MANAGE message to each
	child-widget created. Note that the efficiency argument above is
	moot if the shell widget ancestor of <widgets...> has not been
	:REALIZE'd.

	An error will be signaled if the widgets passed to this routine do
	not all have the same parent.

** XT_UNMANAGE_CHILDREN == XtUnmanageChildren():

	(XT_UNMANAGE_CHILDREN <widgets...>)
		--> returns T.

	Given <widgets...>, an ARRAY or LIST of WIDGETOBJs, all of which
	must be children of the same parent, this primitive will remove those
	widgets from their parent-widget's managed list, which means they
	will no longer be visible or take up space.

	Calling XT_UNMANAGE_CHILDREN on a sequence of child widgets is more
	efficient than sending the :UNMANAGE message to each child-widget.

	An error will be signaled if the widgets passed to this routine do
	not all have the same parent.

** Function XM_GET_DESTINATION (XmGetDestination()):

	(XM_GET_DESTINATION)
 		--> Returns a WIDGETOBJ, "the widget to be used as the current
		    destination for quick paste and certain clipboard
		    operations." Returns NIL if
		    "there is no current destination".

	See XmGetDestination.3X manual page for details.

** GET_MOUSED_WIDGET -- primitive for visually interacting with widgets.

	(GET_MOUSED_WIDGET)
		--> returns the WIDGETOBJ designated by the user.
 
	Evaluating GET_MOUSED_WIDGET will change the cursor to a crossbar,
	indicating that the user is to 'click' the mouse on a widget
	managed by WINTERP. GET_MOUSED_WIDGET will then return the
	WIDGETOBJ corresponding to the selected widget.

	You can use this primitive to visually alter widgets displayed by
	WINTERP, for example, evaluating the following form will invert the
	colors on any widget you click (note -- you can't change the
	colors on a gadget):
		  (let
		      ((widget (get_moused_widget))
		       foreground
		       background
		       )
		    (send widget :get_values
			  :XMN_FOREGROUND 'foreground
			  :XMN_BACKGROUND 'background
			  )
		    (send widget :set_values
			  :XMN_FOREGROUND background
			  :XMN_BACKGROUND foreground
			  ))

	You may use this primitive for sending arbitrary messages to
	arbitrary widgets "visually". This primitive can be used to
	implement "builder-like" and "hypercard-like" features with WINTERP.
	For additional examples using this primitive, see 
	./../examples/interact.lsp

	Note: GET_MOUSED_WIDGET will work on any kind of widget, not only
	widgets created at the Lisp level in WINTERP. This means that you
	can use it to modify widgets inside a composite widget (e.g., the 
	scrollbar in a scrolled text or list widget). Furthermore, if you
	take an existing C-implemented Motif application and link it in
	with WINTERP such that your application uses WINTERP's event
	handling loop in main(), then you can use GET_MOUSED_WIDGET to
	modify the widgets created in your own C-implemented application code!

	KNOWN BUG -- you cannot use get_moused_widget primitive on widgets
	within a menu system. Even if you manage to post a menu that stays
	posted and then	call this function, the "grab" from the menu
	prevents this primitive from working...

	Note: if you are using Motif 1.1 and want GET_MOUSED_WIDGET's 
	functionality with the additional ability to control the mouse
	sprite, see also XM_TRACKING_LOCATE.

#ifdef MOTIF_1.1

** XM_TRACKING_LOCATE == XmTrackingLocate() [Motif >= 1.1 only]:

	(XM_TRACKING_LOCATE <widget> <fontcursor-FIXNUM> [<confine-to-p>])
		--> Returns a WIDGETOBJ that was selected by the user.
		Returns NIL if the window of the buttonpress is not a widget.

	"XmTrackingLocate provides a modal interface for selection of
	a component.  It is intended to support context help.  The function
	grabs the pointer and returns the widget in which a button press
	occurs."  (taken from XmTrackingLocate.3X man-page).

	<widget> is the widget "to use as the basis of the modal interaction"

	<fontcursor-FIXNUM> specifies the shape of the cursor for this
	interaction.  the value of this FIXNUM specifies a font whose
	name/value is defined in /usr/include/X11/cursorfont.h. For example
	Use FIXNUM value 34 to define a cross-hair (#define XC_crosshair 34).

	If the last arg supplied, <confine-to-p>, is non-NIL, then the
	interaction will be confined to <widget>. If this arg is not
	supplied, <confine-to-p> is treated as NIL.

	Note: See also WINTERP's GET_MOUSED_WIDGET primitive, which offers
	similar functionality to XM_TRACKING_LOCATE but predates it
	(XM_TRACKING_LOCATE is new to Motif 1.1).
#endif /* MOTIF_1.1 */

==============================================================================

* X Location Primitives:

** GET_MOUSE_LOCATION == XQueryPointer():

	(GET_MOUSE_LOCATION)
		--> returns dotted pair (root-x . root-y) representing
	            the x,y location of the mouse sprite with respect
                    to the root window. To access root-x, use 'car' and
		    to access root-y, use 'cdr'.

** GET_EVENT_COORDS

	(GET_EVENT_COORDS <xevent>)
		--> Returns (<x-fixnum> . <y-fixnum>) or signals error

	<xevent> is an XEvent* as returned via symbol CALLBACK_XEVENT
	(bound via :ADD_CALLBACK or :SET_CALLBACK method), ACTION_XEVENT
	(bound in in the Lisp(...) ActionProc from a translation table),
	and EVHANDLER_XEVENT (bound via :ADD_EVHANDLER or :SET_EVHANDLER
	method).

	TODO: add GET_EVENT_BUTTON, GET_EVENT_TIME, etc?, and remove
	EVHANDLER_TIME and EVHANDLER_BUTTON symbols from XtAddEventHandler()?

==============================================================================

* Xt Translation and Accelerators:

** Action Procedure Lisp() -- call XLISP evaluator from a translation table.

	WINTERP has a built-in ActionProc named "Lisp" that allows you to
	call arbitrary Lisp functions from a translation or accelerator table.
	The arguments passed on to ActionProc "Lisp" become the elements in
	the Lisp form passed on to the evaluator when the action is fired.

	For example, a translation/accelerator table containing an entry 
	"<EnterWindow>: Lisp(Lisp-function arg1 arg2 arg3)" will end up 
	evaluating the Lisp form '(Lisp-function arg1 arg2 arg3)' whenever 
	an EnterWindow event is processed.

	In the lexical scope of the action invocation, ACTION_WIDGET gets
	bound to the widget causing the action, and ACTION_XEVENT gets
	bound to the event. See ./../examples/trans.lsp for examples.

	KNOWN-BUG: I haven't found a way of escaping characters passed on
	to the translation/action table parsers to allow Lisp strings or
	lips lists to be passed on to the Lisp evaluator that is called by
	this function.  Using the evaluator through an action proc is still
	useful, just don't try to pass in very complex Lisp forms.

** XT_PARSE_TRANSLATION_TABLE == XtParseTranslationTable():

	(XT_PARSE_TRANSLATION_TABLE <string>)
		--> returns a XT_TRANSLATIONS node

	This primitive compiles <string> into a translation table and
	returns the compiled table. 

	For more information on the syntax of the string representation of
	translation tables, see the X11r4 documentation "X Toolkit
	Intrinsics -- C	Language Interface": "Appendix B: Translation Table
	Syntax" and "Chapter 10: Translation Management".
 
	NOTE: the memory allocated by XtParseTranslationTable() isn't freed
	anywhere yet -- I can't find any documentation that says you're
	supposed to free this. For now this may be a memory leak.

** XT_PARSE_ACCELERATOR_TABLE == XtParseAcceleratorTable():

	(XT_PARSE_ACCELERATOR_TABLE <string>)
		--> returns a XT_ACCELERATORS node

	This primitive compiles <string> into an accelerator table and
	returns the compiled table.

	For more information on the syntax of the string representation of
	accelerator tables, see the X11r4 documentation "X Toolkit
	Intrinsics -- C	Language Interface": "Appendix B: Translation Table
	Syntax" and "Chapter 10: Translation Management".

	NOTE: the memory allocated by XtParseAcceleratorTable() isn't freed
	anywhere yet -- I can't find any documentation that says you're
	supposed to free this. For now this may be a memory leak.

==============================================================================

* XBM/GIF Images and Pixmaps:

** Function GIF_TO_PIXMAP

	(GIF_TO_PIXMAP <gif-file-name-str> [:verbose])
		--> returns a PIXMAP node...

	<gif-file-name-str> is the full pathname to a GIF file.

	[:verbose] -- if this optional argument is present, then
	information on the pixmap will be printed to WINTERP's stdout.
	Information on the size and depth of the GIF is printed, along
	with information on color allocation.

	Function GIF_TO_PIXMAP returns a PIXMAP representing the GIF file.
	This function will allocate colors from the global colormap so that
	the pixmap may be used as argument to any widget pixmap resource.
	Note that automatic memory management of colors takes place here --
	the system will not deallocate any colors allocated by
	GIF_TO_PIXMAP until the Pixmap and any widgets displaying the
	pixmap are destroyed. If you're not using a GIF pixmap, make sure
	to not leave it "hanging" onto a global variable or within a
	closure as it will prevent it from getting deallocated. 

	As your system runs out of colors, this primitive will substitute 
	the closest matching color for any color that couldn't be allocated.
	Sometimes this will look ok, sometimes it doesn't. To get back your
	colors, be sure to destroy any widgets presenting GIF images, and
	don't leave uneeded references to GIF Pixmap values in any global
	variables or closures.

** Function XM_GET_PIXMAP == XmGetPixmap():

	(XM_GET_PIXMAP <image-name> <foreground> <background>)
		--> returns a PIXMAP node.

	<image-name> is a string representing a XImage that has been
	cached via XM_INSTALL_IMAGE. If such an XImage isn't found, then
	<image-name> is treated as the filename for a X10 or X11 bitmap file.
	You need to give a full pathname to the bitmap file, or alternately,
	you may set the environment variable XBMLANGPATH to the directories to
	be searched for bitmap files. XBMLANGPATH defaults to
	/usr/lib/X11/%L/bitmaps/%N/%B:/usr/lib/X11/%L/bitmaps/%B:/usr/lib/X11/bitmaps/%B:/usr/include/X11/bitmaps/%B
	
	In additions to images you have installed, Motif features 10
	preinstalled images: "background", "25_foreground",
	"50_foreground", "75_foreground", "vertical", "horizontal",
	"slant_right", "slant_left", "menu_cascade", "menu_checkmark".
	
	<foreground> and <background> may be strings representing color names,
	or values of type PIXEL. (generated by X_ALLOC_COLOR, or via widget-method
	:get_values on :XMN_FOREGROUND or :XMN_BACKGROUND resources).
	
	This function returns a value of type PIXMAP, which is suitable for
	passing on to any Pixmap-valued widget resource so as to display an
	image inside a widget.
	
	Note that there is no interface to XmDestroyPixmap()-- unreferenced
	pixmaps	are automatically destroyed by WINTERP during garbage
	collection.

** XM_INSTALL_IMAGE == XmInstallImage():

	(XM_INSTALL_IMAGE <ximage> <image_name>)
		--> returns T if success,  NIL if a NULL <ximage>, or
			duplicate <image_name> is given.

	This primitive installs an XIMAGE node for use by Motif's Image and
	Pixmap cacheing routines. 

	<ximage> is an XIMAGE node as returned by XM_GET_XIMAGE_FROM_FILE; 

	<image_name> is a STRING, the name under which the <ximage> is cached.

** XM_UNINSTALL_IMAGE == XmUninstallImage():

	(XM_UNINSTALL_IMAGE <ximage>)
		--> returns T if success,  NIL if a NULL <ximage>, or
			<ximage> cannot be found in the image cache.

	This primitive removes an XIMAGE from Motif's Image cache, freeing
	up the storage associated with the XImage.

	<ximage> is an XIMAGE node as returned by XM_GET_XIMAGE_FROM_FILE

** XM_GET_XIMAGE_FROM_FILE == _XmGetImageFromFile():

	(XM_GET_XIMAGE_FROM_FILE <filepath>)
		--> returns an XIMAGE node if an XImage was successfully
			retrieved from the given bitmap file; NIL if

	This primitive reads an X10 or X11 bitmap file and returns an
	XImage structure associated with that file.

	<filepath> is a STRING, the full path name to the file containing
	the XImage data.

==============================================================================

* Primitives for manipulating XM_STRINGs:

	Because Motif's XmStrings are such a complete pain to deal with,
	I've tried to make it so you can pretend XmStrings don't exist at
	all by providing automatic string-->XmString conversions for
	setting resources and for various widget methods.

	Alas, there are cases where you need to retrieve STRING values from
	an XM_STRING, create special XM_STRINGs, convert compound text to
	XM_STRINGs (or vice versa), or need to compare two XM_STRINGS. For
	such cases, I've interfaced most of Motif's XmString
	functionality...

#ifdef MOTIF_1.1

**  XM_CVT_CT_TO_XM_STRING == XmCvtCTToXmString() [Motif >= 1.1 only]:

	(XM_CVT_CT_TO_XM_STRING <compound-text>)
		--> returns an XM_STRING representing <compound-text>.

	<compound-text> is an XLISP STRING type but it is encoded using 
	compound text format, which is described in the X Consortium
	Standard "Compound Text Encoding".
#endif /* MOTIF_1.1 */

#ifdef MOTIF_1.1

** XM_CVT_XM_STRING_TO_CT == XmCvtXmStringToCT() [Motif >= 1.1 only]:

	(XM_CVT_XM_STRING_TO_CT <xmstring>)
		--> returns a STRING.

	This function converts XM_STRING type argument <xmstring> to
	a STRING encoded in compound text format. Compound text format is
	described in the X Consortium Standard "Compound Text Encoding".
#endif /* MOTIF_1.1 */

** XM_STRING_BYTE_COMPARE == XmStringByteCompare():

	(XM_STRING_BYTE_COMPARE <xmstring_a> <xmxtring_b>)
		--> returns T if the XM_STRING args are byte-for-byte equal,
		    else NIL.

	A Note from XmStringByteCompare.3X manual page:
	  "In general, if two compound strings are created with the
          same (char *) string using XmStringCreateSimple()
	  (replaced by XmStringCreateLocalized() in Motif 1.2) in the same
          language environment, the compound strings compare as equal.
          If two compound strings are created with the same (char *)
          string and the same character set other than
          XmSTRING_DEFAULT_CHARSET using XmStringCreate, the strings
          compare as equal.  The result of comparing a compound string
          created with XmStringCreate against a compound string
          created with XmStringCreateSimple()/XmStringCreateLocalized()
	  is undefined.

          In some cases, once a compound string is put into a widget,
          that string is converted into an internal form to allow
          faster processing.  Part of the conversion process strips
          out unnecessary or redundant information.  If an application
          then does an XtGetValues to retrieve a compound string from
          a widget (specifically, Label and all of its subclasses), it
          is not guaranteed that the compound string returned is
          byte-for-byte the same as the string given to the widget
          originally."

** XM_STRING_COMPARE == XmStringCompare():

	(XM_STRING_COMPARE <xmstring_a> <xmxtring_b>)
		--> returns T if the two XM_STRING args are "semantically equal",
		    else NIL.

	A note from the XmStringCompare.3X manual page:
          "XmStringCompare returns a Boolean value indicating the
          results of a semantically equivalent comparison of two
          compound strings.

          Semantically equivalent means that the strings have the same
          text components, directions, and separators.  If character
          sets are specified, they must be equal as well.  In general,
          if two compound strings are created with the same (char *)
          string using XmStringCreateSimple() (replaced by
	  XmStringCreateLocalized() in Motif 1.2) in the same language
          environment, the compound strings compare as equal.  If two
          compound strings are created with the same (char *) string
          and the same character set other than
          XmSTRING_DEFAULT_CHARSET using XmStringCreate, the strings
          compare as equal.  The result of comparing a compound string
          created with XmStringCreate against a compound string
          created with XmStringCreateSimple()/XmStringCreateLocalized()
	  is undefined."

** XM_STRING_CONCAT == XmStringConcat():

	(XM_STRING_CONCAT <xmstring_a> <xmstring_b>)
		--> returns a new XM_STRING which is the concatenation of
		    XM_STRINGs  <xmstring_a> and <xmstring_b>.

** XM_STRING_COPY == XmStringCopy():

	(XM_STRING_COPY <xmstring>)
		--> returns a new XM_STRING, a copy of <xmstring>
	

** XM_STRING_CREATE == XmStringCreate(), XmStringCreateLocalized(), XmStringCreateSimple():

	(XM_STRING_CREATE <string> [<charset>])
		--> returns an XM_STRING version of string <string>.

	Create a compound string from STRING <text>. Optional argument
	<charset> is a STRING specifying an XmStringCharSet. If the
	<charset> argument is omitted, XmFONTLIST_DEFAULT_TAG is
	used as a default value when using Motif versions >= 1.2.
	In Motif 1.1 or 1.0, XmSTRING_DEFAULT_CHARSET is used as the
	default value.
	
	Note that calling XM_STRING_CREATE with no <charset> argument is
	equivalent to calling Motif 1.1's XmStringCreateSimple();
	In Motif 1.2, calling XM_STRING_CREATE with no <charset> argument
	is equivalent to calling XmStringCreateLocalized().

	Example values for <charset> would be "", which is equivalent to
	the C Motif constant XmSTRING_DEFAULT_CHARSET; another typical
	value is "ISO8859-1", which is equivalent to the C Motif constants
	XmSTRING_ISO8859_1, XmSTRING_OS_CHARSET, and XmFALLBACK_CHARSET.

	For Motif 1.1, potential values for <charset> are: "" (default)
	"ISO8859-1" "ISO8859-2" "ISO8859-3" "ISO8859-4" "ISO8859-5" "ISO8859-6"
	"ISO8859-7" "ISO8859-8" "ISO8859-9" "JISX0201.1976-0" "GB2312.1980-0"
	"GB2312.1980-1" "JISX0208.1983-0" "JISX0208.1983-1"
	"KSC5601.1987-0" "KSC5601.1987-1". For Motif 1.2, the
	default has changed to XmFONTLIST_DEFAULT_TAG, thus
	<charset> would be the string "FONTLIST_DEFAULT_TAG_STRING".

** XM_STRING_CREATE_L_TO_R == XmStringCreateLtoR():

	(XM_STRING_CREATE_L_TO_R <text> [<charset>])
		--> returns an XM_STRING version of string <text>.
	
	Create a left-to-right compound string from STRING <text>. This
	function imposes the semantic of scanning for \n characters in the
	text. When one is found, the text up to that point is put into a
	segment followed by a separator component.  No final separator
	component is appended to the end of the compound string.  The
	direction defaults to left-to-right.  This function assumes that
	the encoding is single octet rather than double octet per character
	of text.

	Optional argument <charset> is a STRING specifying an XmStringCharSet.
	If the <charset> argument is omitted, XmFONTLIST_DEFAULT_TAG is
	used as a default value when using Motif versions >= 1.2.
	In Motif 1.1 or 1.0, XmSTRING_DEFAULT_CHARSET is used as the
	default value.

	Example values for <charset> would be "", which is equivalent to
	the C Motif constant XmSTRING_DEFAULT_CHARSET; another typical
	value is "ISO8859-1", which is equivalent to the C Motif constants
	XmSTRING_ISO8859_1, XmSTRING_OS_CHARSET, and XmFALLBACK_CHARSET.

	For Motif 1.1, other potential values for <charset> are: ""
	"ISO8859-1" "ISO8859-2" "ISO8859-3" "ISO8859-4" "ISO8859-5" "ISO8859-6"
	"ISO8859-7" "ISO8859-8" "ISO8859-9" "JISX0201.1976-0" "GB2312.1980-0"
	"GB2312.1980-1" "JISX0208.1983-0" "JISX0208.1983-1"
	"KSC5601.1987-0" "KSC5601.1987-1".  For Motif 1.2, the
	default has changed to XmFONTLIST_DEFAULT_TAG, thus
	<charset> would be the string "FONTLIST_DEFAULT_TAG_STRING".

	Note that there also exists a Motif function XmStringLtoRCreate() --
	at the time of this writing XmStringCreateLtoR() and
	XmStringLtoRCreate() are the same, therefore I'm only providing
	WINTERP primitive XM_STRING_CREATE_L_TO_R.

** XM_STRING_DIRECTION_CREATE == XmStringDirectionCreate():

	(XM_STRING_DIRECTION_CREATE :STRING_DIRECTION_L_TO_R)
		 --> returns an XM_STRING with a single L->R direction component.
	(XM_STRING_DIRECTION_CREATE :STRING_DIRECTION_R_TO_L)
		--> returns an XM_STRING with a single R->L direction component

** XM_STRING_EMPTY == XmStringEmpty():

	(XM_STRING_EMPTY <xmstring>)
		--> returns T if all segments in XM_STRING <xmstring> are
		    zero length or if there are no text segments.
		    Otherwise returns NIL.

** XM_STRING_GET_L_TO_R == XmStringGetLtoR():

	(XM_STRING_GET_L_TO_R <xmstring> [<charset>])
		--> returns a STRING, or NIL if no matching character set found.
	
	This function will fetch the first text segment of the XM_STRING
	<xmstring> which matches the character set <charset>, and returns
	that as a STRING.

	Optional argument <charset> is a STRING specifying an XmStringCharSet.
	If the <charset> argument is omitted, XmFONTLIST_DEFAULT_TAG is
	used as a default value when using Motif versions >= 1.2.
	In Motif 1.1 or 1.0, XmSTRING_DEFAULT_CHARSET is used as the
	default value.

	Example values for <charset> would be "", which is equivalent to
	the C Motif constant XmSTRING_DEFAULT_CHARSET; another typical
	value is "ISO8859-1", which is equivalent to the C Motif constants
	XmSTRING_ISO8859_1, XmSTRING_OS_CHARSET, and XmFALLBACK_CHARSET.

	For Motif 1.1, potential values for <charset> are: "" (default)
	"ISO8859-1" "ISO8859-2" "ISO8859-3" "ISO8859-4" "ISO8859-5" "ISO8859-6"
	"ISO8859-7" "ISO8859-8" "ISO8859-9" "JISX0201.1976-0" "GB2312.1980-0"
	"GB2312.1980-1" "JISX0208.1983-0" "JISX0208.1983-1"
	"KSC5601.1987-0" "KSC5601.1987-1". For Motif 1.2, the
	default has changed to XmFONTLIST_DEFAULT_TAG, thus
	<charset> would be the string "FONTLIST_DEFAULT_TAG_STRING".

#ifdef MOTIF_1.1

** XM_STRING_HAS_SUBSTRING == XmStringHasSubstring() [Motif >= 1.1 only]:

	(XM_STRING_HAS_SUBSTRING <xmstring> <xmsubstring>)
		--> returns T if XM_STRING <xmsubstring> is a substring of
		    XM_STRING <xmstring>, else returns NIL.
#endif /* MOTIF_1.1 */

** XM_STRING_LENGTH == XmStringLength():

	(XM_STRING_LENGTH <xmstring>)
		--> returns a FIXNUM representing the number of bytes in
		    <xmstring> including all tags, direction indicators,
		    and separators. 0 is returned if the compound string
		    has an invalid structure.

** XM_STRING_LINE_COUNT == XmStringLineCount():

	(XM_STRING_LINE_COUNT <xmstring>)
		--> returns a FIXNUM representing the number of lines
		    in XM_STRING <xmstring>. 

	The effect of XM_STRING_LINE_COUNT is to count lines in the 
	XM_STRING argument. Actually, it returns the number of separators
	plus one...

** XM_STRING_SEGMENT_CREATE == XmStringSegmentCreate():

	(XM_STRING_SEGMENT_CREATE <text> [<charset>] <direction> <separator_p>)
		--> returns a XM_STRING with the specified components:
		<text>, a STRING;
		<charset>, an optional STRING specifying a character set
		<direction>, a symbol, either :STRING_DIRECTION_L_TO_R, or
	                                      :STRING_DIRECTION_R_TO_L;
		<separator_p>, a boolean; if non-NIL, a separator will be
		added immediately following the <text> component.

	For Motif 1.1, potential values for <charset> are: "" (default)
	"ISO8859-1" "ISO8859-2" "ISO8859-3" "ISO8859-4" "ISO8859-5" "ISO8859-6"
	"ISO8859-7" "ISO8859-8" "ISO8859-9" "JISX0201.1976-0" "GB2312.1980-0"
	"GB2312.1980-1" "JISX0208.1983-0" "JISX0208.1983-1"
	"KSC5601.1987-0" "KSC5601.1987-1"

** XM_STRING_SEPARATOR_CREATE == XmStringSeparatorCreate():

	(XM_STRING_SEPARATOR_CREATE)
		--> returns an XM_STRING with a single component, a separator.

==============================================================================

* X Color Facilities:

#ifdef MOTIF_1.1

** XM_GET_COLORS == XmGetColors() [Motif >= 1.1 only]:

	(XM_GET_COLORS <background-pixel>)
		--> returns an array of 5 PIXEL values
		      #(<background>
			<foreground>
			<top_shadow>
			<bot_shadow>
			<select>)

	Given PIXEL-type argument <background-pixel> representing the
	background color of a widget, XM_GET_COLORS will calculate and
	return PIXEL type values for foreground, select, and shadow colors.
	For an example of XM_GET_COLORS usage, see ./../examples/colorsetr.lsp .

	Note that this routine will change at some future date to take
	<screen> and <colormap> arguments that are used by XmGetColors().
	Currently, XM_GET_COLORS uses the default screen and colormap
	of the WINTERP application's *TOPLEVEL_WIDGET*
#endif /* MOTIF_1.1 */

** X_ALLOC_COLOR == XParseColor() + XAllocColor():

	(X_ALLOC_COLOR <color>)
		--> returns a PIXEL atom corresponding to a read-only
		color cell in the installed colormap.
	
	<color> is a string, either a colorname from /usr/lib/X11/rgb.txt
	or a hexadecimal color specification of format "#RRGGBB".

** X_STORE_COLOR == XParseColor() + XStoreColor():

	(X_STORE_COLOR <pixel> <color>) 
		--> returns a PIXEL atom.

	X_STORE_COLOR stores an RGB/Color value into a single read/write
	colormap cell represented by type-PIXEL atom <pixel>.

	<color> is a string, either a colorname from /usr/lib/X11/rgb.txt
	or a hexadecimal color specification of format "#RRGGBB".

	Note that read/write colormap cells can be created via primitive
	X_ALLOC_N_COLOR_CELLS_NO_PLANES, and these are useful for
	generating the appearance of having colors shared by multiple
	widgets on the screen. For example usage, see 
	./../examples/colorsetr.lsp .

** X_ALLOC_N_COLOR_CELLS_NO_PLANES == XAllocColorCells(d,c,FALSE,NULL,0,...):

	(X_ALLOC_N_COLOR_CELLS_NO_PLANES <num-cells>)
		--> returns an array of <pixel>,
		each <pixel> being a type-PIXEL atom representing a single
		read/write color cell in the installed colormap.

	<num-cells>, a FIXNUM > 0, indicates the number of read/write color
	cells to allocate.

	For details, see see Oliver Jones' "Introduction to the X Window
	System", p. 278. For example usage, see ./../examples/colorsetr.lsp .

==============================================================================

* Motif Resolution Independence Functions:

#ifdef MOTIF_1.1

** XM_SET_FONT_UNITS == XmSetFontUnits() [Motif >= 1.1 only]:

	(XM_SET_FONT_UNITS <horiz-val> <vert-val>)
		--> Returns NIL.

	XM_SET_FONT_UNITS allows applications to initialize the font unit
	values to nonnegative FIXNUM values <horiz-val> and <vert-val>.
	Applications may want to specify resolution-independent data based
	on a global font size.  This function must be called before any
	widgets with resolution-independent data are created.  See the
	documentation on resource :XMN_UNIT_TYPE above, as well as the
	manual pages for XmGadget, XmManager, and XmPrimitive for more
	information on resolution independence.

	Note: when WINTERP allows for multiple displays, this function will
	end up changing argument sequences to accomodate a <display> arg.
#endif /* MOTIF_1.1 */

#ifdef MOTIF_1.1

** XM_CONVERT_UNITS == XmConvertUnits() [Motif >= 1.1 only]:

	(XM_CONVERT_UNITS <widget> <orientation>
			  <from_unit_type> <from_value>
			  <to_unit_type>)
		--> Returns the converted value, a FIXNUM.

	"XmConvertUnits - a function that converts a value in one unit type
	to another unit type." (quoted from XmConvertUnits.3X manual page).

	<widget> is a WIDGETOBJ -- "Specifies the widget for which the data
	is to be converted."

	<orientation> is a keyword symbol, either :HORIZONTAL or :VERTICAL
	"Specifies whether the converter uses the horizontal or vertical
	screen resolution when performing the conversions."

	<from_unit_type> and <to_unit_type> are keyword symbols, either
	:PIXELS, :100TH_MILLIMETERS, :1000TH_INCHES, :100TH_POINTS,
	:100TH_FONT_UNITS.

	<from_value> is a FIXNUM.

	Note that Motif resolution independence functions
	XmCvtFromHorizontalPixels(), XmCvtFromVerticalPixels(),
	XmCvtToHorizontalPixels(), XmCvtToVerticalPixels() have not been
	interfaced since their functionality can be achieved through
	XmConvertUnits().
#endif /* MOTIF_1.1 */

==============================================================================

* Other random Motif/Xt Functionality:

** Function WINTERP_SHOW_BUSY:

	(WINTERP_SHOW_BUSY <busy_p>)

	when <busy_p> is non-NIL, a "busy cursor" will appear over all WINTERP
	related shells, popup-shells, and dialogues.
	when <busy_p> is NIL, the "busy cursor" will be removed.
	
	Note that this routine may be called multiple times (e.g. recursively),
	however, in order to undo the effects of calling the routine N times
	with <busy_p>==T, one will need to call N times with <busy_p>==NIL.
	
	On the N'th call with <busy_p>==NIL, this routine will return a FIXNUM
	indicating the number of enqueued
	ButtonPress/ButtonRelease/ButtonMotion/
	PointerMotion/KeyPress events that have been discarded. This is done
	because the application should not have been able to respond to events
	while "busy", and yet impatient users may "type ahead" enqueuing events
	that might cause erroneous actions to occur when the application begins
	processing events again. Discarding these events will prevent erroneous
	actions from occuring...
	
	For all other calls, with <busy_p>==T this routine returns NIL. For
	calls where <busy_p>==NIL but where the number of <busy_p>==NIL
	calls done so far do not match the number of <busy_p>==T calls,
	this routine will also return NIL.

** Function X_BELL (XBell()):

	(X_BELL [<volume>])
		--> RETURNS NIL

	<volume> is an optional FIXNUM argument ranging from -100 to
	100. If the <volume> arg is not givem, it defaults to '0'. Note
	that for most cases '0' is a reasonable value, as it will allow
	the user to set up the X Window system to operate silently by
	setting the base bell volume negative via the 'xset' unix command.

** XM_SET_MENU_CURSOR == XmSetMenuCursor():

	(XM_SET_MENU_CURSOR <fontcursor>)
		--> Returns NIL.
	
	 "XmSetMenuCursor programmatically modifies the menu cursor for a client;
	 after the cursor has been created by the client, this function registers
	 the cursor with the menu system.  After calling this function, the
	 specified cursor is displayed whenever this client displays a Motif
	 menu on the indicated display.  The client can then specify different
	 cursors on different displays." (from XmSetMenuCursor.3X manual page).
	
	<fontcursor>> specifies the shape of the cursor for this interaction.
	The value of this FIXNUM specifies a font whose name/value is defined in
	/usr/include/X11/cursorfont.h.
	
	Note: when WINTERP allows for multiple displays, this function will
	end up changing arg sequences to accomodate a <display> arg.

#ifdef MOTIF_1.1

** XT_RESOLVE_PATHNAME == XtResolvePathname() [Motif >= 1.1 only]:

	(XT_RESOLVE_PATHNAME <type> <filename> <suffix> <path>)
		--> returns a STRING representing the pathname of an
		existing file created from the parameters <type> <filename>
		<suffix> and <path>. Returns NIL if no such file exists, the
		file isn't readable, or the specification is a directory.

	<path> is a string of paths separated by colons (':'), in which the 
		following substitutions are done:
	     %N -- gets substituted by the parameter <filename>, a name without
		   the extension.
	     %T -- gets substituted by the parameter <type>, a directory name. 
	     %S -- gets substituted by the parameter <suffix>.
	     
	     X11r4 Language-dependent substitutions for %L, %l %t, %c may occur
	     as well. See the documentation for XtResolvePathname() for
	     further details.
	
	<type> is a STRING, or NIL. This substitutes for occurrences of %T in
	     <path>.
	
	<filename> is a STRING. If this parameter is NIL, then note that
	     XtResolvePathname() will substitute the application class name.
	
	<suffix> is a STRING, or NIL. This substitutes for occurrences of %S
	    in <path>.

	For a useful example using XT_RESOLVE_PATHNAME, see Winterp-Lisp file
	./../examples/prov-req.lsp . 
#endif /* MOTIF_1.1 */

==============================================================================

* Winterp-Lisp global variables.

	WINTERP defines the following global variables:

** *ERRHOOK* -- XLISP error-hook.

	WINTERP extends XLISP by providing a hook that gets called
	whenever an XLISP evaluation error occurs. This is used in
	<winterp-top-dir>/examples/lib-utils/err-hook.lsp to pop
	up a dialog box each time an evaluation error occurs.
	
	The error hook is defined with
		(setq *errhook*
		      (lambda (hdr cmsg emsg &optional
			       (arg NIL arg-supplied-p))
			      <exprs>...))

	hdr  -- first arg  -- STRING
	     -- the kind of error, e.g. "error", "break", etc.
	cmsg -- second arg -- STRING or NIL
	     -- continuable error message (NIL if not continuable)
	emsg -- third arg  -- STRING
	     -- the error message
	arg  -- fourth arg -- <LVAL>
	     -- (optional) value assoc'd with error, e.g. value
		assoc'd with a bad-argument-type message.
	<exprs>...
	     -- the body of code executed each time the error-hook fires.
		If the last s-expr in <exprs>... returns NIL, you will see
		the error output also occur via the standard XLISP mechanism.

	Note that this error hook is more suited to application delivery,
	because situations can arise in prototyping in which errors cannot be
	properly output to widgets (e.g. out of memory, out of swap space,
	etc.). Therefore, use at your own risk...

** *MODULES*

	This is set to a list of <module-name> which have been previously 
	'PROVIDE'd... See <<PROVIDE>> and <<REQUIRE>>.

** *XLISP_VERSION*

	This is set to a FIXNUM indicating the current version of XLISP
	used in WINTERP. For XLISP 2.1
	*XLISP_VERSION* == 2.

** *XLISP_REVISION*

	This is set to a FIXNUM indicating the current revision of XLISP
	used in WINTERP. For XLISP 2.1
	*XLISP_REVISION* == 1.

** *MOTIF_VERSION*

	This is set to a FIXNUM indicating the current version of Motif
	used by WINTERP. This is the value of XmVERSION in <Xm/Xm.h>.

** *MOTIF_REVISION*

	This is set to a FIXNUM indicating the current revision of Motif
	used by WINTERP. This is the value of XmREVISION in <Xm/Xm.h>.

** *WINTERP_VERSION*

	This is set to a FIXNUM indicating the current revision of
	WINTERP. For WINTERP 2.00 *WINTERP_VERSION* == 2.


** *WINTERP_REVISION*

	This is set to a FIXNUM indicating the current revision of
	WINTERP. For WINTERP 2.00 *WINTERP_REVISION* == 00.

** *MOTIF_SUBREVISION*

	This is set to the "sub-revision" of Motif
		3 for Motif 1.1.3 1.1.4, 1.2.3
		1 for Motif 1.1.1
		0 for Motif 1.0 or 1.1.0

** *TOPLEVEL_WIDGET*

	This is set to a WIDGETOBJ, the WINTERP application's
	application-shell widget.  By default, this shell-widget is
	unmapped and not visible on the screen -- it is used internally to
	retrieve application-resources and certain default X values needed
	by WINTERP's internals. However, users may use this existing shell
	widget for whatever purpose they want. Note that Bug-Free operation
	of WINTERP is not at all guaranteed if you destroy this widget.

	Also, you'll want to use this widget to retrieve the command line
	arguments with which winterp was invoked. Do this with
		(send *TOPLEVEL_WIDGET* :GET_ARGV)

** *SAVED_OBJS*

	This is set to an ARRAY of WIDGETOBJ, CALLBACKOBJs, TIMEOUTOBJs, etc.
	These represent the set of objects that WINTERP considers "alive"
	and therefore forms the roots of garbage collection in the WINTERP
	environment. This is really used only for debugging purposes, as well
	as other hackery on WINTERP's internals.  Bug-Free operation of WINTERP
	is not at all guaranteed if you mess with the values in this ARRAY. For
	examples that help visualize the layout and number of saved objects, 
	see <winterp-top-dir>/examples/barchart.lsp and
	<winterp-top-dir>/examples/xtango/barchart.lsp .

==============================================================================

* WINTERP <--> Motif Widget Classes

** WIDGET_CLASS -- the WINTERP widget metaclass.

	WIDGET_CLASS is not an instantiable class. It is the base class
	from which all WINTERP widget-classes inherit methods and
	functionality from. Note that some widget classes will override
	methods defined on WIDGET_CLASS.

*** equivalent Xt 'WidgetClass':

	There is no direct equivalent. This class is essentially a       
	combination of classes 'Primitive',  'Core', 'Manager' etc.

*** equivalent creation convenience function:

	XtCreateWidget() -- see below.

*** XtCreateWidget():

	(send <WIDGET_CLASS> :NEW [:managed/:unmanaged]
				  [<name>]
				  <parent> 
				  [<resource_0> <value_0>]
				  . . .
				  [<resource_n> <value_n>])

		--> returns a newly created WIDGETOBJ of class
			<WIDGET_CLASS>.

	<WIDGET_CLASS> is an XLISP class-object that has been previously
	been defined, either by compiling it into the C source, or by
	subclassing existing widgets, or by creating a new composite widget
	class made out of existing or subclassed widget classes.

	The optional keyword-argument :MANAGED will cause a subsequent call
	to XtManageChild() (see also method :MANAGE).
	If the submessage :UNMANAGED is	present, or no submessage, then
	XtManageChild() won't be called, and the resulting widget will be
	returned unmanaged.

	The optional argument <name> is a string which becomes the
	name of the widget as used by the resource manager. If you
	are not setting any widget resources via the resource
	manager, you may leave this parameter out.

	The argument <parent> is a WIDGETOBJ that will be managing
	the widget to be created.

	The optional arguments [<resource_i> <value_i>]... represent a series
	of Motif resource name/value pairs -- upon creation of the
	widget, each <resource_i> will be set to <value_i>. Resource names are
	keyword symbols which are described in the
	"WINTERP <--> Motif resources" section of this document. Each
	<resource_i> expects a specific Lisp type for <value_i> and will signal
	an error if the wrong type <value_i> is given. For example, the Motif
	resource XmNx indicates the X-axis location of a widget with respect to
	its parent -- the corresponding WINTERP-Lisp symbol :XMN_X will expect
	its associated value to be a FIXNUM.

	Almost all resource values may also be specified as a STRING and
	Xt&Motif's resource converters will automatically convert the
	STRING to the appropriate type. The string values may be specified
	in the same way that you would specify a value for use by the X
	resource database (e.g. ~/.Xdefaults or /usr/lib/X11/app-defaults/*).

	Note that different resource names are valid for each particular
	widget class. See the Motif manual pages on a particular widget
	class to find out which resources may be set. If you attempt to set
	a resource that doesn't exist for a particular widget's class, no
	error will be signaled, and the invalid resource will be ignored.
	(I consider this behavior is a bug in the design of the Xt
	intrinsics whereas the X consortium considers this a "feature" of
	the implementation. WINTERP could ask the toolkit to see whether each
	specified resource is valid, but that would make execution too
	slow. Given that the X Consortium will never fix this bug, a future
	version of WINTERP may allow such checking to occur as an option).

*** WIDGET_CLASS Method :EXISTS_P

	(send <widget> :EXISTS_P)
		--> returns T if the widget exists (and hasn't been destroyed);
		    returns NIL if the widget has been destroyed 
		    or if the widget has never been initialized.

	Use this method for the following problem: A WIDGETOBJ value may be
	stored as the value of a symbol, or stored in a functional closure;
	the lifetime of the widget associated with the WIDGETOBJ is not
	necessarily the same. This method can test to see if the widget
	associated with the WIDGETOBJ has been destroyed by the user
	through some previous operation. Using this method can allow
	programmers to prevent sending messages to widgets that have been
	destroyed; normally, sending a message to a destroyed widget would
	signal an error.

*** XtSetValues():

	(send <widget> :SET_VALUES <resource_0> <value_0>
				   . . .
				   [<resource_n> <value_n>])
		--> returns <widget>.


	This method allows you to set the value of widget resource <resource_i>
	to value <value_i> for the widget object <widget>. Resource names are
	keyword symbols which are described in the
	"WINTERP <--> Motif resources" section of this document. Each 
	<resource_i> expects a specific Lisp type for <value_i> and will
	signal an error if the wrong type <value_i> is given. For example, the
	Motif resource XmNx indicates the X-axis location of a widget with
	respect to its parent -- the corresponding WINTERP-Lisp symbol :XMN_X
	will expect its associated value to be a FIXNUM.

	Note that different resource names are valid for each particular
	widget class. See the Motif manual pages on a particular widget
	class to find out which resources may be set. If you attempt to set
	a resource that doesn't exist for a particular widget's class, no
	error will be signaled, and the invalid resource will be ignored.
	(I consider this behavior is a bug in the design of the Xt
	intrinsics whereas the X consortium considers this a "feature" of
	the implementation. WINTERP could ask the toolkit to see whether each
	specified resource is valid, but that would make execution too
	slow. Given that the X Consortium will never fix this bug, a future
	version of WINTERP may allow such checking to occur as an option).

*** XtGetValues():

	(send <widget> :GET_VALUES 
		<resource_0> <place_0>
		. . .
		<resource_n> <place_n>)
		--> returns a list of values corresponding to <place_i>==NIL
		    (see below).		

	This method accesses values inside the OBJECT <widget> and stores
	them in Lisp data structures. <place_i> is a the place to put the
	value associated with widget resource name <resource_i>. Resource
	names are keyword symbols which are described in the
	"WINTERP <--> Motif resources" section of this document.

	If <place_i> is NIL, then <resource_i>'s value is returned by the
	method as an element in a list of results. If <place_i> is a quoted
	symbol, then that symbol gets bound to <resource_i>'s value. If
	<place_i> is a place-form (see documentation on xLisp's 'setf'
	construct) then <resource_i>'s value will be put in <place_i>,
	which is one of the following field specifiers:
                       <sym>                   set value of a symbol
                       (car <expr>)            set car of a cons node
                       (cdr <expr>)            set cdr of a cons node
                       (nth <n> <expr>)        set nth car of a list
                       (aref <expr> <n>)       set nth element of an array
                       (get <sym> <prop>)      set value of a property
                       (symbol-value <sym>)    set value-cell of a symbol
                       (symbol-function <sym>) set function-cell of a symbol
                       (symbol-plist <sym>)    set property list of a symbol

	Note that different resource names are valid for each particular
	widget class. See the Motif manual pages on a particular widget
	class to find out which resources may be retrieved. If you attempt
	to retrieve the value of a resource value that doesn't exist for a
	particular widget-class, an error will be signaled.

*** XtAddCallback():

	(send <widget_instance> :ADD_CALLBACK	<name>
						<call_data_binding_names_list>
						<code>)
		--> returns: <callback_id_object> of type CALLBACKOBJ

	(send <widget_instance> :SET_CALLBACK	<name>
						<call_data_binding_names_list>
						<code>)
		--> returns: <callback_id_object> of type CALLBACKOBJ

	Both these methods add the callback <name> to <widget_instance>.
	:SET_CALLBACK contains additional code to ensure that only one
	callback exists per <name>. :SET_CALLBACK is useful when one is
	prototyping an application and changing callbacks frequently -- you
	don't have to worry about removing the previous callback with
	XT_REMOVE_CALLBACK. Note that :ADD_CALLBACK should be used in
	time-sensitive code, since :SET_CALLBACK is slower.

	<name> is a resource keyword of type XmRCallback, eg,
	:XMN_ACTIVATE_CALLBACK, :XMN_ARM_CALLBACK, :XMN_DISARM_CALLBACK.
	For a list of valid resource names for callbacks, see the
	"XmRCallback" subheading of the "WINTERP <--> Motif resources" section
	of this document. Different widget classes support different
	callback names -- see the Motif manual page for the appropriate
	widget class to see which callbacks are valid for a particular
	widget class.  Note that an error will be signaled if an invalid
	callback <name> is given.

	<call_data_binding_name_list> is a list of symbols that get bound to
	data specific to the action on the callback widget. Most
	widgets return call_data of type XmAnyCallbackStruct:
		typedef struct
			{
			  int     reason;
			  Event  *event;
			} XmAnyCallbackStruct;
	For such widgets, specifying one or more of the following symbols
	in the callback	bindings list will bind that symbol's value in the
	lexical	environment of the callback:
		CALLBACK_WIDGET -- the WIDGETOBJ of the callback
		CALLBACK_REASON -- the reason symbol for the callback
		CALLBACK_XEVENT -- the XEvent* that caused the callback

		The symbol CALLBACK_REASON is bound to one of the following
		symbols during the callback:
			CR_NONE, CR_HELP, CR_VALUE_CHANGED, CR_INCREMENT,
			CR_DECREMENT, CR_PAGE_INCREMENT, CR_PAGE_DECREMENT,
			CR_TO_TOP, CR_TO_BOTTOM, CR_DRAG, CR_ACTIVATE,
			CR_ARM, CR_DISARM, CR_MAP, CR_UNMAP, CR_FOCUS,
			CR_LOSING_FOCUS, CR_MODIFYING_TEXT_VALUE,
			CR_MOVING_INSERT_CURSOR, CR_EXECUTE,
			CR_SINGLE_SELECT, CR_MULTIPLE_SELECT,
			CR_EXTENDED_SELECT, CR_BROWSE_SELECT,
			CR_DEFAULT_ACTION, CR_CLIPBOARD_DATA_REQUEST,
			CR_CLIPBOARD_DATA_DELETE, CR_CASCADING, CR_OK,
			CR_CANCEL, CR_APPLY, CR_NO_MATCH, CR_COMMAND_ENTERED,
			CR_COMMAND_CHANGED, CR_EXPOSE, CR_RESIZE, CR_INPUT,
		    #ifdef MOTIF_1.1
			CR_GAIN_PRIMARY, CR_LOSE_PRIMARY,
		    #endif /* MOTIF_1.1 */
		    #ifdef MOTIF_1.1.3
			CR_CREATE, CR_PROTOCOLS,
		    #endif /* MOTIF_1.1.3 */
		    #ifdef MOTIF_1.2
			CR_TEAR_OFF_ACTIVATE, CR_TEAR_OFF_DEACTIVATE,
			CR_OBSCURED_TRAVERSAL.
		    #endif /* MOITIF_1.2 */

		Note that widget classes whose callback call_data isn't of type
		XmAnyCallbackStruct will override WIDGET_CLASS's
		:ADD_CALLBACK and :SET_CALLBACK methods and provide a
		class-specific method that allows retrieval of values from
		other kinds of Xm*CallbackStructs. These methods will allow
		additional symbols in <call_data_binding_names_list>.
		However, all :ADD_CALLBACK and :SET_CALLBACK methods allow
		for the symbols CALLBACK_WIDGET CALLBACK_REASON and
		CALLBACK_XEVENT.	

	<code> is a list of Lisp expressions that are evaluated when the
	callback occurs. When the callback fires and <code> gets evaluated,
	the lexical environment that existed for the call to
	:ADD_CALLBACK/:SET_CALLBACK will be used for value and functional
	bindings.

	NOTE: The the callback associated with the returned
	<callback_id_object> may be removed via XtRemoveCallback() with the
	WINTERP primitive (XT_REMOVE_CALLBACK <callback_id_object>).

*** XtRemoveAllCallbacks():

	(SEND <widget> :REMOVE_ALL_CALLBACKS <name>)
		--> returns T.

	<name> is a resource keyword of type XmRCallback, eg,
	:XMN_ACTIVATE_CALLBACK, :XMN_ARM_CALLBACK, :XMN_DISARM_CALLBACK.

	This method removes all callbacks matching <name> from <widget>.

	WARNING: (from Motif 1.1 README file):
		Calling this routine from an application removes all callbacks
		from a widget, including those added internally by Motif code.
		An application should use XtRemoveCallback or XtRemoveCallbacks
		to remove particular callbacks.

*** XtHasCallbacks():

	(SEND <widget> :HAS_CALLBACKS <name>)
		--> returns CALLBACK_NO_LIST if callback <name> doesn't exist.
		--> returns CALLBACK_HAS_NONE if callback list has no callbacks.
		--> returns CALLBACK_HAS_SOME if some callbacks on list.

	<name> is a resource keyword of type XmRCallback, eg,
	:XMN_ACTIVATE_CALLBACK, :XMN_ARM_CALLBACK, :XMN_DISARM_CALLBACK, etc.

*** XtAddEventHandler(), XtAddRawEventHandler():

	(send <widget> :ADD_EVENT_HANDLER [:RAW] [:NONMASKABLE] <event_mask>
        	                          <event_data_bindings_list> <code>)
	(send <widget> :SET_EVENT_HANDLER [:RAW] [:NONMASKABLE] <event_mask>
					  <event_data_bindings_list> <code>)
		--> returns an <EVHANDLEROBJ> which identifies the handler.

	Optional keyword :RAW indicates that XtAddRawEventHandler() will be
	invoked so as to not affect the widget's input mask nor for it to
	select for events. Otherwise XtAddEventHandler() will get called.

	Optional keyword :NONMASKABLE indicates that the handler should be
	called for nonmaskable events.
 
	<event_mask> is a FIXNUM which is the value of the an event mask.
	event masks may be combined by doing a bitwise OR via the XLISP
	'LOGIOR' function. The following event mask constants have been
	defined: NO_EVENT_MASK, KEY_PRESS_MASK, KEY_RELEASE_MASK,
	BUTTON_PRESS_MASK, BUTTON_RELEASE_MASK, ENTER_WINDOW_MASK,
	LEAVE_WINDOW_MASK, POINTER_MOTION_MASK, POINTER_MOTIONHINT_MASK,
	BUTTON1_MOTION_MASK, BUTTON2_MOTION_MASK, BUTTON3_MOTION_MASK,
	BUTTON4_MOTION_MASK, BUTTON5_MOTION_MASK, BUTTON_MOTION_MASK,
	KEYMAP_STATE_MASK, EXPOSURE_MASK,  VISIBILITY_CHANGE_MASK
	STRUCTURE_NOTIFY_MASK, RESIZE_REDIRECT_MASK, SUBSTRUCTURE_NOTIFY_MASK
	SUBSTRUCTURE_REDIRECT_MASK, FOCUS_CHANGE_MASK, PROPERTY_CHANGE_MASK
	COLORMAP_CHANGE_MASK, OWNER_GRAB_BUTTON_MASK.

	<event_data_bindings_list> is a list of symbols that get
	bound to data specific to the action that caused the event
	handler to fire. These symbols get bound to specific values during
	the execution of the event-handler <code>.
	Valid symbols are:
		EVHANDLER_WIDGET -- bound to the WIDGETOBJ of the event
		EVHANDLER_XEVENT -- bound to the XEvent that fired handler.
		EVHANDLER_BUTTON -- fixnum -- the button or keycode
		EVHANDLER_TIME   -- fixnum -- the timestamp.

	<code> is a list of Lisp-forms to be evaluated when the eventhandler
	fires. When the eventhandler fires, the lexical environment that
	existed for the call to :ADD_EVENT_HANDLER will be used for value and
	functional bindings.

	The eventhandler may be removed by giving the <EVHANDLEROBJ> to
	procedure XT_REMOVE_EVENT_HANDLER.

	Note that the :SET_EVENT_HANDLER variant does exactly the same
	thing as :ADD_EVENT_HANDLER except that it ensures that only one
	event handler with the given <event_mask>, :RAW and :NONMASKABLE
	specifications exist on <widget>. It will remove all other matching
	event handlers in order to set the current event handler. This
	function is useful for making interactive changes to an event
	handler without having to remember to remove the previous
	handler. Note that :SET_EVENT_HANDLER is slower, so it should 
	not be used in cases where speed is important.

	NOTE: <widget> must not be a gadget. WINTERP will signal a XLISP
	error if :ADD_EVENT_HANDLER or :SET_EVENT_HANDLER is called on a
	gadget.

	NOTE: the EVHANDLER_TIME and EVHANDLER_BUTTON binding values may
	return gibberish if the eventhandler returned a event->type that
	doesn't define those fields. This is currently just a kludge for
	Motif functions that require the event->button info (popup menus)
	or event->time info (XmClipboard*). Hopefully I'll come up with
	something better in the future...

*** XtRemoveEventHandler() // XtRemoveRawEventHandler()

	(XT_REMOVE_EVENT_HANDLER <EVHANDEROBJ>)
		--> returns true.

	This procedure removes the eventhandler corresponding to the 
	<EVHANDLEROBJ> returned by method :ADD_EVENT_HANDLER

*** XtBuildEventMask():

	(send <widget> :BUILD_EVENT_MASK)
		--> returns as a FIXNUM the event mask representing the
	logical OR of all event masks for event handlers registered on
	<widget>. This includes masks set by XtAddEventHandler(), all event
	translations & accelerators.

	NOTE: <widget> must not be a gadget. WINTERP will signal a XLISP
	error if :BUILD_EVENT_MASK is called on a gadget.

*** XtOverrideTranslations():

	(send <widget> :OVERRIDE_TRANSLATIONS <translations>)
		--> returns <widget>

	This method destructively merges the new <translations> into
	<widget>'s existing translations -- event sequences in <translations>
	that already exist from a previous translation will override.

	<translations> can be a string, in which case it is compiled into a
	translation table. Otherwise, we expect a value of type
	XT_TRANSLATIONS as returned by XT_PARSE_TRANSLATION_TABLE.

	NOTE: <widget> must not be a gadget. WINTERP will signal a XLISP
	error if :OVERRIDE_TRANSLATIONS is called on a gadget.

*** XtAugmentTranslations():

	(send <widget> :AUGMENT_TRANSLATIONS <translations>) 
		--> returns <widget>.

	This method nondestructively merges the new <translations> into
	<widget>'s existing translations -- event sequences in <translations>
	that already exist a previous translation will be ignored.

	<translations> can be a string, in which case it is compiled into a
	translation table. Otherwise, we expect a value of type
	XT_TRANSLATIONS as returned by XT_PARSE_TRANSLATION_TABLE.

	NOTE: <widget> must not be a gadget. WINTERP will signal a XLISP
	error if :AUGMENT_TRANSLATIONS is called on a gadget.

*** XtUninstallTranslations():

	(send <widget> :UNINSTALL_TRANSLATIONS)
		-->  returns <widget>

	This method removes all translations from <widget>.

	NOTE: <widget> must not be a gadget. WINTERP will signal a XLISP
	error if :UNINSTALL_TRANSLATIONS is called on a gadget.

*** XtInstallAccelerators():

	(send <destination> :INSTALL_ACCELERATORS <source>)
		-->  returns <destination>

	This method installs the accelerators from widget <source> onto
	widget <destination> by augmenting the destination translations with
	the source accelerators.
	Both <source> and <destination> are WIDGETOBJs.

	NOTE: <destination> must not be a gadget. WINTERP will signal a XLISP
	error if :INSTALL_ACCELERATORS is called on a gadget.

*** XtInstallAllAccelerators():

	(send <destination> :INSTALL_ALL_ACCELERATORS <source>)
		-->  returns <destination>

	This method installs the accelerators from widget <source> and all
	its children onto widget <destination> by augmenting the destination
	translations with the source accelerators.
	Both <source> and <destination> are WIDGETOBJs.

	NOTE: <destination> must not be a gadget. WINTERP will signal a XLISP
	error if :INSTALL_ALL_ACCELERATORS is called on a gadget.

*** XtDestroyWidget():

	(send <widget> :DESTROY)
		--> returns NIL.

	After calling this routine, the WIDGETOBJ <widget> may be garbage
	collected, along with all other resources the widget references, such
	as PIXMAPs CALLBACKOBJs, and EVHANDLEROBJs. Furthermore, this will
	destroy all children of the destroyed widget and allow their storage
	to be garbage collected as well.

*** XtManageChild():

	(send <widget> :MANAGE)
		--> returns <widget>

	This method will add <widget> to its parent-widget's managed list,
	which means it will become visible (if mapped) and will take up space
	within the managing widget.

*** XtUnmanageChild():

	(send <widget> :UNMANAGE)
		--> returns <widget>

	This method will remove <widget> from its parent's managed list,
	which means it will no longer be visible or take up space.

*** XtAddGrab():

	(send <widget> :ADD_GRAB <exclusive_p> <spring_loaded_p>)
		-->  returns <widget>

	This method appends <widget> to the modal cascade -- redirects user
	input to this widget. <exclusive_p> and <spring_loaded_p> are
	booleans.

	NOTE: <widget> must not be a gadget. WINTERP will signal a XLISP
	error if :ADD_GRAB is called on a gadget.

*** XtRemoveGrab():

	(send <widget> :REMOVE_GRAB)
		-->  returns <widget>

	Removes the redirection of user input to <widget> done via :ADD_GRAB

	NOTE: <widget> must not be a gadget. WINTERP will signal a XLISP
	error if :REMOVE_GRAB is called on a gadget.

*** XtIsCompositeObject() [MOTIF_1.0] // XtIsComposite() [MOTIF_1.1]:

	(send <widget> :IS_COMPOSITE)
		--> returns T if <widget> is a composite widget, else NIL.

*** XtIsConstraint():

	(send <widget> :IS_CONSTRAINT)
		--> returns T if <widget> is a constraint widget, else NIL.

*** XtIsShell():

	(send <widget> :IS_SHELL)
		--> returns T if <widget> is a shell widget, else NIL.

*** XtSetSensitive():

	(send <widget> :SET_SENSITIVE <sensitive_p>)
		--> returns <widget>.

	If <sensitive_p> is NIL, then the widget will not respond to user
	input.

*** XtSetMappedWhenManaged():

	(send <widget> :SET_MAPPED_WHEN_MANAGED <mapped_p>)
		--> returns <widget>.

	If <mapped_p> is non-NIL, then the widget will be mapped (displayed)
	when it is managed by its parent widget.

	NOTE: <widget> must not be a gadget. WINTERP will signal a XLISP
	error if :SET_MAPPED_WHEN_MANAGED is called on a gadget.

*** XtIsManaged():

	(send <widget> :IS_MANAGED)
		--> returns T if the widget is managed, else NIL. 

	See also method :MANAGE and :UNMANAGE

*** XtIsRealized():

	(send <widget> :IS_REALIZED) 
		--> returns T if the widget is realized, else NIL.

	See also methods :REALIZE and :UNREALIZE

*** XtIsSensitive():

	(send <widget> :IS_SENSITIVE)
		--> returns T if the widget will accept user input, else NIL. 

	See also method :SET_SENSITIVE.

*** XtParent():

	(send <widget> :PARENT)
		--> returns the given <widget>'s parent widget or NIL 
		    if no parent.

*** XtWindow() [MOTIF_1.0] // XtWindowOfObject() [MOTIF_1.1]:

	(send <widget> :WINDOW)
		--> returns the given <widget>'s window.

*** XtMapWidget():

	(send <widget> :MAP)
		--> returns <widget>.

	If the widget is realized and managed, this method will make the
	window appear on the display. Make it disappear with :UNMAP.

*** XtUnmapWidget():

	(send <widget> :UNMAP)
		--> returns <widget>.

	If the widget is realized and managed, this method will make the
	window disappear from the display. Make it reappear with :MAP.

*** XmUpdateDisplay():

	(send <widget> :UPDATE_DISPLAY [<sleep-microseconds>])
		--> returns <widget>.

	This method is useful for refreshing WINTERP's Xwindows displays
	while inside a callback. Since the X display won't get refreshed
	until you hit the XtNextEvent/XtDispatcEvent loop you cannot normally
	update the display inside a callback. Thus, this function is
	especially useful for forcing a status message to be seen before a
	long computation occurs within a callback.

	The optional FIXNUM argument <sleep-microseconds> specifies the 
	number of microseconds for the WINTERP process to sleep after
	updating the display. This will ensure that the updated display
	remains visible for a given amount of time prior to any subsequent
	updates.

	NOTE: The functionality offered by this optional argument is
	a special WINTERP extension; the standard OSF/Motif XmUpdateDisplay()
	call doesn't allow for this. Also, note that <sleep-microseconds>
	specifies microseconds -- a value of 1,000,000 will cause
	:UPDATE_DISPLAY to sleep for 1 second.

*** XmAddTabGroup():

	(send <widget> :ADD_TAB_GROUP)
		--> returns <widget>

	This method adds <widget> to the list of tab groups associated with a
	particular widget hierarchy.

*** XmRemoveTabGroup():

	(send <widget> :REMOVE_TAB_GROUP)
		--> returns <widget>

	This method removes <widget> from the list of tab groups associated
	with a particular widget hierarchy.

*** XmIsPrimitive():

	(send <widget> :IS_PRIMITIVE)
		--> returns T if <widget> is a motif primitive widget, 
		    else NIL.

*** XmIsGadget():

	(send <widget> :IS_GADGET)
		--> returns T if <widget> is a motif gadget, else NIL.

*** XmIsManager():

	(send <widget> :IS_MANAGER)
		--> returns T if <widget> is a motif manager widget, else NIL.

#ifdef MOTIF_1.1

*** XmProcessTraversal() [Motif >= 1.1 only]:

	(send <widget> :PROCESS_TRAVERSAL <direction>)
		--> "Returns T if the setting succeeded.  Returns NIL if the
		keyboard focus policy is not :EXPLICIT, if there are no
		traversable items, or if the call to the routine has invalid
		parameters."
	
	This method "determines which component receives keyboard events
	 when a widget has the focus." (from XmProcessTraversal.3X manual page)
	
	<direction> is a keyword symbol, one of the following:
	:TRAVERSE_CURRENT
	     "Finds the hierarchy and the tab group that contain widget.
		If this tab group is not the active tab group, makes it the
		active tab group.  If widget is an item in the active tab
		group, makes it the active item.  If widget is the active
		tab group, makes the first traversable item in the tab group
		the active item."
	:TRAVERSE_DOWN
	    "Finds the hierarchy that contains widget.  Finds the active
		item in the active tab group and makes the item below it the
		active item.  If there is no item below, wraps."
	:TRAVERSE_HOME
		"Finds the hierarchy that contains widget.  Finds the active
		item in the active tab group and makes the first traversable
		item in the tab group the active item."
	:TRAVERSE_LEFT
	     "Finds the hierarchy that contains widget.  Finds the active item
		in the active tab group and makes the item to the left the
		active item.  If there is no item to the left, wraps."
	:TRAVERSE_NEXT
	     "Finds the hierarchy that contains widget.  Finds the active item
	     in the active tab group and makes the next item the active item."
	:TRAVERSE_NEXT_TAB_GROUP
	     "Finds the hierarchy that contains widget.  Finds the active tab
	     group (if any) and makes the next tab group the active tab group
	     in the hierarchy."
	:TRAVERSE_PREV
	     "Finds the hierarchy that contains widget.  Finds the active item
	     in the active tab group and makes the previous item the active
	     item."
	:TRAVERSE_PREV_TAB_GROUP
	     "Finds the hierarchy that contains widget.  Finds the active tab
	     group (if any) and makes the previous tab group the active tab
	     group in the hierarchy."
	:TRAVERSE_RIGHT
	    "Finds the hierarchy that contains widget.  Finds the active item
	    in the active tab group and makes the item to the right the active
	    item.  If there is no item to the right, wraps."
	:TRAVERSE_UP
	    "Finds the hierarchy that contains widget. Finds the active item
	     in the active tab group and makes the item above it the active
	     item. If there is no item above, wraps."
#endif /* MOTIF_1.1 */

#ifdef MOTIF_1.1

*** XtName() [Motif >= 1.1 only]:

	(send <widget> :NAME)
		--> returns STRING of widget's name. 

	The name returned is the STRING passed to the optional [<name>]
	argument during widget creation. If no <name> argument is given
	at widget creation time, the result of method :NAME will be the
	empty string "". See method :NEW on WIDGET_CLASS for details.
#endif /* MOTIF_1.1 */

#ifdef MOTIF_1.1

*** XtCallActionProc() [Motif >= 1.1 only]:

	(send <widget> :CALL_ACTION_PROC <action> <xevent>
		       [<param0> [<param1> [...] ]])
		--> Returns <widget>.

	This method invokes the specified action procedure <action> on <widget>.

	<action> is a STRING specifying the name of the action procedure
	defined on the widget. See the manual page on the widget's class
	to find out the defined names for widget action procedures. Note
	that the action procedure names are case sensitive. If the action
	procedure is not found, an XtWarning is generated.

	<xevent> is an XEVENT object that is passed on to the action procedure.
	Typically, this would come from the value of the symbol
	CALLBACK_XEVENT that is bound during execution of a WINTERP callback.

	[<param0> [<param1> [...] ]] are an optional sequence of STRING
	values that are passed on to the action procedure. The number
	of parameters, as well as the contents of the parameters are
	dependent on the definition of the action procedure. Many action
	procedures do not take any parameters, in which case, none should
	be supplied.

	NOTE: <widget> must not be a gadget. WINTERP will signal a XLISP
	error if :CALL_ACTION_PROC is called on a gadget.
	
	Note the following caveat from the X Toolkit specification:
	"It is the responsibility of the caller to ensure that the contents
	of the <xevent> and [<param0> [<param1> [...] ]] arguments are
	appropriate for the specified action routine and, if necessary,
	that the specified widget is realized or sensitive." In other words,
	you can cause a segmentation violation inside Motif/Xt by making an
	inappropriate call to :CALL_ACTION_PROC.

	Example: the following code sets up a callback on pushbutton widget
	<insertbut_w>. The callback calls method :CALL_ACTION_PROC on the
	XmText widget <te_w>. The method calls action procedure
	insert-string() on the XmText widget, which causes insertion of 
	all the string parameters given to the action proc into the XmText
	instance at the cursor position.
	
		(send insertbut_w :set_callback :xmn_activate_callback
		      '(CALLBACK_XEVENT)
		      '(
			(send te_w :CALL_ACTION_PROC "insert-string"
			      CALLBACK_XEVENT
			      "jimbrowski " "must " "wear " "a " "hat\n")
		       ))

#endif /* MOTIF_1.1 */

#ifdef MOTIF_1.1

*** XtGetValues(XmNchildren/XmNnumChildren) [Motif >= 1.1 only]:

	(send <composite_widget> :GET_CHILDREN)
		--> Returns an array of WIDGETOBJs, the children
		of <composite_widget>. Returns NIL if no children.

	This method retrieves the composite-widget resoruces
	XtNchildren/XmNchildren and XtNnumChildren/XmNnumChildren. 
	Due to flaws in Motif/Xt design, :GET_VALUES on resource
	XmNchildren cannot be done in a straightforward fashion.
	I've worked around that limitation by providing this method.
	(Note that these resources are read-only, so there's no
	point in having any :SET_VALUES interface for them either.)

	This method will signal an error if the WIDGETOBJ receiving the
	:GET_CHILDREN message is not a subclass of the 'Composite'
	widgetclass. (Which makes sense, since no other widget classes 
	have children...)
#endif /* MOTIF_1.1 */

*** WIDGET_CLASS Method :FORCED_EXPOSE_UPDATE :

	(send <widget> :FORCED_EXPOSE_UPDATE)
	  	==> returns <widget>
  
	This is useful in making popup dialogues visible before embarking
	on a long computation. Although the Event loop in this method will
	not process timeouts or events from input sources, it can and will
	process Lisp callbacks.  if an error or catch/throw causes a
	nonlocal exit from the callback, one may expect trouble. Be careful.

	NOTE: <widget> must not be a gadget. WINTERP will signal a XLISP
	error if :FORCED_EXPOSE_UPDATE is called on a gadget.

	WARNING: calling this routine in a situation where <widget> never
	gets an expose can cause WINTERP to "lock up". You'll have to
	kill the WINTERP process via kill(1) from another terminal. Chances
	are, you don't want to call this function interactively (i.e. by
	typing it into the read-eval-print loop, evaluating it in the
	winterp control panel or emacs' WINTERP interfaces.

*** WIDGET_CLASS Method :CHANGE_COLOR :

	(send <widget> :CHANGE_COLOR <bg-color>)
		--> Returns <widget>.
	
	<widget> must be a widget; an XLISP error gets signalled if a gadget 
	is used.
	
	<bg-color> is a STRING or PIXEL value representing the desired color
	for <widget>'s background. If a STRING value is given, it will be
	converted to a pixel value based on color names given in
	/usr/lib/X11/rgb.txt; alternately, one may specify the color
	specification in hexadecimal as "#RRGGBB"...
	
	Given a new background color <bg-color>, method :CHANGE_COLOR
	recalculates the foreground, select, and shadow colors based on the
	new background color and sets the corresponding resources for the
	widget. The new colors are based on Motif's default color
	calculation procedures.

______________________________________________________________________________

** <SHELL_WIDGET_CLASS> -- the WINTERP shell widget metaclass

	<SHELL_WIDGET_CLASS> is a widget (pseudo) metaclass for all shell
	widgets. A shell widget is an object representing a "top level"
	window that are managed by a window manager (e.g. mwm, the
	Motif window manager).

	<SHELL_WIDGET_CLASS> is a subclass of WIDGET_CLASS, so all methods
	on that	metaclass also work on this class as well. 


*** XtAppCreateShell():

	The following create instances of metaclass <SHELL_WIDGET_CLASS>:

	(send TOP_LEVEL_SHELL_WIDGET_CLASS :new [<name> [<class-name>]]
						[<args>...])
		--> XtAppCreateShell(...topLevelShellWidgetClass...)

	(send APPLICATION_SHELL_WIDGET_CLASS :new [<name> [<class-name>]]
						  [<args>...])
		--> XtAppCreateShell(...applicationShellWidgetClass...)

	(send OVERRIDE_SHELL_WIDGET_CLASS :new [<name> [<class-name>]]
					       [<args>...])
		--> XtAppCreateShell(...overrideShellWidgetClass...)

	(send TRANSIENT_SHELL_WIDGET_CLASS :new [<name> [<class-name>]]
						[<args>...])
		--> XtAppCreateShell(...transientShellWidgetClass...)

	[<name>] is an optional string that can be used to qualify the
	resources of all the children of the shell widget as well as the
	shell widget itself. (e.g. if <name>=="foo", then the resources
	corresponding to the shell are specified as "foo*resource".
	If [<name>] is omitted, then the shell's name defaults to "".
	One may use this feature to specify multiple logical applications
	running under WINTERP -- each "application" has its own
	application_shell or top_level_shell and the widgets in each
	"application" have their own resource hierarchy.
		
	[<class-name>] is an optional string that can be used to set a different
	class name for the widget hierarchy under this shell widget. If
	<class-name> is omitted, the shell's class-name defaults to "Winterp"
	unless the [-class <classname>] command-line option is given, in which
	case the shell's classname is <classname>. Note that if you want to
	set <class-name>, you must also set parameter <name>.
	(Note: setting a <class-name> does not tell WINTERP to look in an
	application defaults file named <class-name>; setting the application
	defaults file used by WINTERP can only be set via the
	[-class <classname>] command-line parameter.)

	[<args>...] represents a sequence of resource pairs. For
	more details on resource pairs, see method :SET_VALUES or :NEW
	on WIDGET_CLASS (above).

*** XtRealizeWidget():

	(send <Shell_Widget_Instance> :REALIZE)
		==> returns <Shell_Widget_Instance>

	This method causes the shell window and its subwindows to be
	created and will make the window appear on the screen.


*** XtUnrealizeWidget():

	(send <Shell_Widget_Instance> :UNREALIZE)
		==> returns <Shell_Widget_Instance>

	This method destroys the window associated with the shell and
	all its subwindows.


*** XmIsMotifWMRunning():

	(send <Shell_Widget_Instance> :IS_MOTIF_WM_RUNNING)
		==> returns T if the motif window manager (mwm) is running,
		    else NIL.


*** XtGetValues(XmNargv/XmNargc):

	(send <Application_Shell_Widget_Instance> :GET_ARGV) or
	(send <Application_Popup_Shell_Widget_Instance> :GET_ARGV)
		==> returns an array of strings.
	
	Method :GET_ARGV is valid only for ApplicationShell widgets.
	It retrieves the resources XmNargv and XmNargc from
	<Application_Shell_Widget_Instance> and returns an array of strings
	representing the command line args with	which the program was called.

	Example: to retrieve the command line arguments with which winterp
	was invoked, do:
			(send *TOPLEVEL_WIDGET* :GET_ARGV)
	Where *TOPLEVEL_WIDGET* is a global symbol bound to the (by default)
	hidden (unmapped) WINTERP main application shell. (see above for
	more info on *TOPLEVEL_WIDGET*)

*** XtSetValues(XmNargv/XmNargc):

	(send <Application_Shell_Widget_Instance> :SET_ARGV <args>)
		==> returns <Application_Shell_Widget_Instance>.

	Method :SET_ARGV is valid only for ApplicationShell widgets.
	This sets the XmNargv and XmNargc resources based on the sequence of
	string arguments <args>. The resources are set on
	<Application_Shell_Widget_Instance> and this supposedly will allow
	session managers that the application should start up with the new
	<args> specified here.

*** <SHELL_WIDGET_CLASS> Method :MAP_RAISED (XMapRaised()):

	(send <Shell_Widget_Instance> :MAP_RAISED)
		==> returns <Shell_Widget_Instance>
	
	This method ':MAP's the shell and all subwindows that have map
	requests, and raises the shell to the top of the stacking order.

*** <SHELL_WIDGET_CLASS> Method :RAISE_WINDOW (XRaiseWindow()):

	(send <Shell_Widget_Instance> :RAISE_WINDOW)
		==> returns <Shell_Widget_Instance>
	
	Raises the shell to the top of the stacking order, such that no other
	sibling windows obscure it.

*** <SHELL_WIDGET_CLASS> Method :LOWER_WINDOW (XLowerWindow()):

	(send <Shell_Widget_Instance> :LOWER_WINDOW)
		==> returns <Shell_Widget_Instance>
	
	Lowers the shell to the bottom of the stacking order so that it
	doesn't obscure any sibling windows.

______________________________________________________________________________

** <POPUP_SHELL_WIDGET_CLASS> -- the WINTERP popup shell widget metaclass

	<POPUP_SHELL_WIDGET_CLASS> is a (pseudo) metaclass for all popup shells.
	Popup shells are used for creating dialog boxes, menus, and other
	interactors that "pop up" from an application window. Like instances of
	<SHELL_WIDGET_CLASS>, popup shells are "top level" windows that are
	managed by the window manager.

	This class is a subclass of <SHELL_WIDGET_CLASS> and
	WIDGET_CLASS, all methods on those classes also work on this class.

*** XtCreatePopupShell():

	The following create instances of metaclass <POPUP_SHELL_WIDGET_CLASS>.
	Optional argument <name> is a string, the name of the widget.
	<parent> is a WIDGETOBJ that has the new widget instance as popup
	child. [<args>...] represents a sequence of resource pairs. For
	more details on resource pairs, see method :SET_VALUES or :NEW
	on WIDGET_CLASS.

	(send TOP_LEVEL_POPUP_SHELL_WIDGET_CLASS :new [<name>] <parent>
							[<args>...])
		--> XtCreatePopupShell(topLevelShellWidgetClass)

	(send APPLICATION_POPUP_SHELL_WIDGET_CLASS :new [<name>] <parent>
							[<args>...])
		--> XtCreatePopupShell(applicationShellWidgetClass)

	(send OVERRIDE_POPUP_SHELL_WIDGET_CLASS :new [<name>] <parent>
						     [<args>...])
		--> XtCreatePopupShell(overrideShellWidgetClass)

	(send TRANSIENT_POPUP_SHELL_WIDGET_CLASS :new [<name>] <parent>
						      [<args>...])
		--> XtCreatePopupShell(transientShellWidgetClass)

	(send XM_DIALOG_POPUP_SHELL_WIDGET_CLASS :new [<name>] <parent>
						      [<args>...])
		--> XmCreateDialogShell()
		--> XtCreatePopupShell(xmDialogShellWidgetClass)

	(send XM_MENU_POPUP_SHELL_WIDGET_CLASS :new [<name>] <parent>
						    [<args>...])
		--> XmCreateMenuShell()
		--> XtCreatePopupShell(xmMenuShellWidgetClass)

*** XtPopup():

	(send <Popup_Shell_Widget_Instance> :POPUP <grabkind>)
		==> returns <Popup_Shell_Widget_Instance>

	This method pops up the shell, keyword symbol <grabkind> determines
	the kind of grab used: :grab_none, :grab_nonexclusive, :grab_exclusive.

*** XtPopDown():

	(send <Popup_Shell_Widget_Instance> :POPDOWN)
		==> returns  <Popup_Shell_Widget_Instance>

	This method pops down the shell, making it invisible and removing
	the grab setup by :popup.

*** XtGetValues(XmNargv/XmNargc):

	(send <Application_Popup_Shell_Widget_Instance> :GET_ARGV)
		==> returns an array of strings.
	
	Method :GET_ARGV is valid only for ApplicationShell widgets.
	It retrieves the resources XmNargv and XmNargc from
	<Application_Shell_Widget_Instance> and returns an array of strings
	representing the command line args with	which the program was called.

*** XtSetValues(XmNargv/XmNargc):

	(send <Application_Popup_Shell_Widget_Instance> :SET_ARGV <args>)
		==> returns <Application_Popup_Shell_Widget_Instance>.

	Method :SET_ARGV is valid only for ApplicationShell widgets.
	This sets the XmNargv and XmNargc resources based on the sequence of
	string arguments <args>. The resources are set on
	<Application_Popup_Shell_Widget_Instance> and this supposedly will allow
	session managers that the application should start up with the new
	<args> specified here.

*** <POPUP_SHELL_WIDGET_CLASS> Method :MAP_RAISED (XMapRaised()):

	(send <Popup_Shell_Widget_Instance> :MAP_RAISED)
		==> returns <Popup_Shell_Widget_Instance>
	
	This method ':MAP's the shell and all subwindows that have map
	requests, and raises the shell to the top of the stacking order.

*** <POPUP_SHELL_WIDGET_CLASS> Method :RAISE_WINDOW (XRaiseWindow()):

	(send <Popup_Shell_Widget_Instance> :RAISE_WINDOW)
		==> returns <Popup_Shell_Widget_Instance>
	
	Raises the shell to the top of the stacking order, such that no other
	sibling windows obscure it.

*** <POPUP_SHELL_WIDGET_CLASS> Method :LOWER_WINDOW (XLowerWindow()):

	(send <Popup_Shell_Widget_Instance> :LOWER_WINDOW)
		==> returns <Popup_Shell_Widget_Instance>
	
	Lowers the shell to the bottom of the stacking order so that it
	doesn't obscure any sibling windows.

______________________________________________________________________________

** XM_ARROW_BUTTON_WIDGET_CLASS / XM_ARROW_BUTTON_GADGET_CLASS

*** equivalent Xt 'WidgetClass':

	xmArrowButtonWidgetClass
	xmArrowButtonGadgetClass

*** equivalent creation convenience function:

	(send XM_ARROW_BUTTON_WIDGET_CLASS :new [:managed/:unmanaged] ...) 
		--> XmCreateArrowButton()

	(send XM_ARROW_BUTTON_GADGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateArrowButtonGadget()


*** XtAddCallback():

   #ifdef MOTIF_1.0
	In Motif 1.0, :ADD_CALLBACK/:SET_CALLBACK on arrow buttons will
	use the :ADD_CALLBACK/:SET_CALLBACK methods defined on
	<WIDGET_CLASS>, the XmAnyCallbackStruct fields defined on those
	methods will be valid.
   #endif /* MOTIF_1.0 */

   #ifdef MOTIF_1.1
	(send <arrow-button> :ADD_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ
	(send <arrow-button> :SET_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ

	These methods work just like the :ADD_CALLBACK/:SET_CALLBACK
	methods on WIDGET_CLASS except that these methods understand
	how to get call_data values from the XmArrowButtonCallbackStruct
		typedef struct
		{
		    int     reason;
		    XEvent  *event;
		    int	    click_count;
		} XmArrowButtonCallbackStruct;

	Specifying one or more of the following symbols in the callback
	bindings list will bind that symbol's value in the lexical
	environment of the callback:
		CALLBACK_WIDGET -- the WIDGETOBJ of the callback
		CALLBACK_REASON -- the reason symbol for the callback
		CALLBACK_XEVENT -- the XEvent* that caused the callback
		CALLBACK_CLICK_COUNT -- a FIXNUM representing the number of
					clicks upon the button. The click count
					will only be > 1 when resource 
					:XMN_MULTI_CLICK == :MULTICLICK_KEEP
   #endif /* MOTIF_1.1 */
______________________________________________________________________________

** XM_BULLETIN_BOARD_WIDGET_CLASS

*** equivalent Xt 'WidgetClass':

	xmBulletinBoardWidgetClass

*** equivalent creation convenience function:

	(send XM_BULLETIN_BOARD_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateBulletinBoard()

	(send XM_BULLETIN_BOARD_WIDGET_CLASS :new [:managed/:unmanaged]
					     :DIALOG ...)
		--> XmCreateBulletinBoardDialog()
______________________________________________________________________________

** XM_CASCADE_BUTTON_WIDGET_CLASS / XM_CASCADE_BUTTON_GADGET_CLASS

*** equivalent Xt 'WidgetClass':

	xmCascadeButtonWidgetClass
	xmCascadeButtonGadgetClass

*** equivalent creation convenience function:

	(send XM_CASCADE_BUTTON_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateCascadeButton()

	(send XM_CASCADE_BUTTON_GADGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateCascadeButtonGadget()

*** XmCascadeButtonHighlight():

	(send <cascadebutton> :HIGHLIGHT <highlight_p>)
		--> returns <cascadebutton>

	This method draws the shadow highlight around the cascadebutton if
	<highlight_p> is true, and unhighlights if <highlight_p> is NIL.

#ifdef MOTIF_1.1

*** XtGetValues(...XmNsubMenuId...): [Motif 1.1 only -- Motif bug work-around]

	(send <cascadebutton> :GET_SUB_MENU_WIDGET)
		==> this method returns the WIDGETOBJ corresponding to the
		the widget returned by resource XmNsubMenuId.

	Why use this instead of XmNsubMenuId?? Because due to some weird
	Motif 1.1 bug, (probably in motif) doing
	(send <cascadebutton> :get_values :XMN_SUB_MENU_ID nil) returns
	<cascadebutton>. ???
#endif /* MOTIF_1.1 */

______________________________________________________________________________

** XM_COMMAND_WIDGET_CLASS

*** equivalent Xt 'WidgetClass':

	xmCommandWidgetClass

*** equivalent creation convenience function:

	(send XM_COMMAND_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateCommand()

   #ifdef MOTIF_1.2
	(send XM_COMMAND_WIDGET_CLASS :new [:managed/:unmanaged] :dialog ...)
		--> XmCreateCommandDialog()
   #endif MOTIF_1.2

*** XtAddCallback():

	(send <commandwidget> :ADD_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ
	(send <commandwidget> :SET_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ

	These methods work just like the :ADD_CALLBACK/:SET_CALLBACK
	methods on WIDGET_CLASS except that these methods understand
	how to get call_data values from the XmCommandCallbackStruct:
		typedef struct
		{
		    int reason;
		    XEvent	*event;
		    XmString	value;
		    int	length;
		} XmCommandCallbackStruct;

	Specifying one or more of the following symbols in the callback
	bindings list will bind that symbol's value in the lexical
	environment of the callback:
		CALLBACK_WIDGET -- the WIDGETOBJ of the callback
		CALLBACK_REASON -- the reason symbol for the callback
		CALLBACK_XEVENT -- the XEvent* that caused the callback
		CALLBACK_VALUE -- the XmString of the command.
		CALLBACK_LENGTH -- the length of XmString in CALLBACK_VALUE

*** XmCommandGetChild():

	(send <commandwidget> :GET_CHILD <symbol>)
		--> returns a WIDGETOBJ corresponding to <symbol>

	<symbol> can be :DIALOG_COMMAND_TEXT,
	                :DIALOG_HISTORY_LIST,
	                :DIALOG_PROMPT_LABEL, or
   #ifdef MOTIF_1.2
			:DIALOG_WORK_AREA
   #endif MOTIF_1.2

*** XmCommandAppendValue():

	(send <commandwidget> :APPEND_VALUE <value>)
		--> returns <value>.

	This method appends the string or XmString <value> to the string in
	the command area widget. If a normal string is given, it will be
	converted to an XmString and returned as the method's result.

*** XmCommandSetValue():

	(send <commandwidget> :SET_VALUE <value>)
		--> returns <value>

	This method sets the text in the widget's command area to the
	string or XmString <value>. If a normal string is given, it will be
	converted to an XmString and returned as the method's result.

*** XmCommandError():
	(send <commandwidget> :ERROR <error>)
		--> returns <error>.

	This method temporarily displays the string or XmString <error> in
	the history area of the command widget, the display is cleared upon
	entry of the next command. If a normal string is given, it will be
	converted to an XmString and returned as the method's result.

*** XtGetValues(XmNhistoryItems/XmNhistoryItemCount):

	(send <commandwidget> :GET_HISTORY_ITEMS)]
		--> returns an array of XM_STRING, each representing
		an item in the command widget's selection box.

	This method allows retrieval of command widget resource XmNhistoryItems.
	Due to flaws in Motif/Xt design, :GET_VALUES on resource
	:XMN_HISTORY_ITEMS cannot be done in a straightforward fashion.
	I've worked around that limitation by providing this method.

______________________________________________________________________________

** XM_DRAWING_AREA_WIDGET_CLASS

*** equivalent Xt 'WidgetClass':

	xmDrawingAreaWidgetClass

*** equivalent creation convenience function:

	(send XM_DRAWING_AREA_WIDGET_CLASS :new [:managed/:unmanaged] ..)
		--> XmCreateDrawingArea()

*** XtAddCallback():

	(send <drawingareawidget> :ADD_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ
	(send <drawingareawidget> :SET_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ

	These methods work just like the :ADD_CALLBACK/:SET_CALLBACK
	methods on WIDGET_CLASS except that this method knows
	how to get call_data values from the XmDrawingAreaCallbackStruct:
		typedef struct
		{
			int     reason;
			XEvent  *event;
			Window  window;
		} XmDrawingAreaCallbackStruct;

	Specifying one or more of the following symbols in the callback
	bindings list will bind that symbol's value in the lexical
	environment of the callback:
		CALLBACK_WIDGET -- the WIDGETOBJ of the callback
		CALLBACK_REASON -- the reason symbol for the callback
		CALLBACK_XEVENT -- the XEvent* that caused the callback
		CALLBACK_WINDOW -- the Window of the callback

______________________________________________________________________________

** XM_DRAWN_BUTTON_WIDGET_CLASS

*** equivalent Xt 'WidgetClass':

	xmDrawnButtonWidgetClass

*** equivalent creation convenience function:

	(send XM_DRAWN_BUTTON_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateDrawnButton()

*** XtAddCallback():

	(send <drawnbuttonwidget> :ADD_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ
	(send <drawnbuttonwidget> :SET_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ

	These methods work just like the :ADD_CALLBACK/:SET_CALLBACK
	methods on WIDGET_CLASS except that these methods understand
	how to get call_data values from the XmDrawnButtonCallbackStruct: 
		typedef struct
		{
		    int     reason;
		    XEvent  *event;
		    Window  window;
		#ifdef MOTIF_1.1
		    int	    click_count;  /* FIELD EXISTS ONLY IN MOTIF 1.1 */
		#endif MOTIF_1.1
		} XmDrawnButtonCallbackStruct;

	Specifying one or more of the following symbols in the callback
	bindings list will bind that symbol's value in the lexical
	environment of the callback:
		CALLBACK_WIDGET -- the WIDGETOBJ of the callback
		CALLBACK_REASON -- the reason symbol for the callback
		CALLBACK_XEVENT -- the XEvent* that caused the callback
		CALLBACK_WINDOW -- the Window of the callback
	   #ifdef MOTIF_1.1
		CALLBACK_CLICK_COUNT -- a FIXNUM representing the number of
					clicks upon the button. The click count
					will only be > 1 when resource 
					:XMN_MULTI_CLICK == :MULTICLICK_KEEP
	   #endif /* MOTIF_1.1 */

______________________________________________________________________________

** XM_FILE_SELECTION_BOX_WIDGET_CLASS

*** equivalent Xt 'WidgetClass':

	xmFileSelectionBoxWidgetClass

*** equivalent creation convenience function:

	(send XM_FILE_SELECTION_BOX_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateFileSelectionBox()

	(send XM_FILE_SELECTION_BOX_WIDGET_CLASS :new [:managed/:unmanaged] :dialog ...)
		--> XmCreateFileSelectionDialog()

*** XtAddCallback():

	(send <fileselboxwidget> :ADD_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ
	(send <fileselboxwidget> :SET_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ

	These methods work just like the :ADD_CALLBACK/:SET_CALLBACK
	methods on WIDGET_CLASS except that these methods understand
	how to get call_data values from the XmFileSelectionBoxCallbackStruct: 
		typedef struct
		{
		    int reason;
		    XEvent	*event;
		    XmString	value;
		    int		length;
		    XmString	mask;
		    int		mask_length;
		#ifdef MOTIF_1.1
		    XmString	dir;	    /* FIELD EXISTS ONLY IN MOTIF 1.1 */
		    int		dir_length; /* FIELD EXISTS ONLY IN MOTIF 1.1 */
		    XmString	pattern;    /* FIELD EXISTS ONLY IN MOTIF 1.1 */
		    int		pattern_length; /* FIELD EXISTS ONLY IN MOTIF 1.1 */
		#endif /* MOTIF_1.1 */
		} XmFileSelectionBoxCallbackStruct;

	Specifying one or more of the following symbols in the callback
	bindings list will bind that symbol's value in the lexical
	environment of the callback:
		CALLBACK_WIDGET -- the WIDGETOBJ of the callback
		CALLBACK_REASON -- the reason symbol for the callback
		CALLBACK_XEVENT -- the XEvent* that caused the callback
		CALLBACK_VALUE  -- the XmString corresponding to the current
				   value of resource :XMN_DIR_SPEC
		CALLBACK_LENGTH -- the length of XmString in CALLBACK_VALUE	
		CALLBACK_MASK   -- the XmString corresponding to the current
				   value of resource :XMN_DIR_MASK
		CALLBACK_MASK_LENGTH -- the length of XmString in CALLBACK_MASK
	   #ifdef MOTIF_1.1
		CALLBACK_DIR		-- the current base directory (XmString)
		CALLBACK_DIR_LENGTH	-- length of XmString in CALLBACK_DIR
		CALLBACK_PATTERN	-- the search pattern (XmString)
		CALLBACK_PATTERN_LENGTH -- length of XmString in CALLBACK_PATTERN
	   #endif /* MOTIF_1.1 */

*** XmFileSelectionBoxGetChild():

	(send <fileselboxwidget> :GET_CHILD <child_sym>)
		--> returns a WIDGETOBJ, the child of <fileselboxwidget>
		corresponding to one of the following keyword symbols:
		#ifdef MOTIF_1.1
		     :DIALOG_DIR_LIST
		     :DIALOG_DIR_LIST_LABEL
		#endif /* MOTIF_1.1 */
		     :DIALOG_WORK_AREA
		     :DIALOG_SEPARATOR
		     :DIALOG_APPLY_BUTTON
		     :DIALOG_CANCEL_BUTTON
		     :DIALOG_DEFAULT_BUTTON
		     :DIALOG_FILTER_LABEL
		     :DIALOG_FILTER_TEXT
		     :DIALOG_HELP_BUTTON
		     :DIALOG_LIST
		     :DIALOG_LIST_LABEL
		     :DIALOG_OK_BUTTON
		     :DIALOG_SELECTION_LABEL
		     :DIALOG_TEXT

*** XmFileSelectionDoSearch():

	(send <fileselboxwidget> :DO_SEARCH [<dirmask>])
		--> returns <dirmask>

	This method initiates a directory search. The search will be
	according to the string or XmString <dirmask>. If <dirmask> is NIL,
	or not supplied, then the search will use the current directory
	mask. This method returns <dirmask> as an XmString or NIL.

#ifdef MOTIF_1.1

*** XtGetValues(XmNdirListItems/XmNdirListItemCount) [MOTIF_1.1 only]:

	(send <fileselboxwidget> :GET_DIR_LIST_ITEMS)
		--> returns an array of XM_STRING, each representing
		an item in the file-selection box's directory list widget.

	This method allows retrieval of list widget resource XmNdirListItems.
	Due to flaws in Motif/Xt design, :GET_VALUES on resource
	:XMN_DIR_LIST_ITEMS cannot be done in a straightforward fashion.
	I've worked around that limitation by providing this method.
#endif /* MOTIF_1.1 */

#ifdef MOTIF_1.1

*** XtGetValues(XmNfileListItems/XmNfileListItemCount) [MOTIF_1.1 only]:

	(send <fileselboxwidget> :GET_FILE_LIST_ITEMS)
		--> returns an array of XM_STRING, each representing
		an item in the file-selection box's file list widget.

	This method allows retrieval of list widget resource XmNfileListItems.
	Due to flaws in Motif/Xt design, :GET_VALUES on resource
	:XMN_FILE_LIST_ITEMS cannot be done in a straightforward fashion.
	I've worked around that limitation by providing this method.
#endif /* MOTIF_1.1 */

______________________________________________________________________________

** XM_FORM_WIDGET_CLASS

*** equivalent Xt 'WidgetClass':

	xmFormWidgetClass

*** equivalent creation convenience function:

	(send XM_FORM_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateForm()

	(send XM_FORM_WIDGET_CLASS :new [:managed/:unmanaged] :dialog ...)
		--> XmCreateFormDialog()

______________________________________________________________________________

** XM_FRAME_WIDGET_CLASS

*** equivalent Xt 'WidgetClass':

	xmFrameWidgetClass

*** equivalent creation convenience function:

	(send XM_FRAME_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateFrame()
______________________________________________________________________________

** XM_LABEL_WIDGET_CLASS / XM_LABEL_GADGET_CLASS

*** equivalent Xt 'WidgetClass':

	xmLabelWidgetClass
	xmLabelGadgetClass

*** equivalent creation convenience function:

	(send XM_LABEL_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateLabel()

	(send XM_LABEL_GADGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateLabelGadget()
______________________________________________________________________________

** XM_LIST_WIDGET_CLASS

*** equivalent Xt 'WidgetClass':

	xmListWidgetClass

*** equivalent creation convenience function:

	(send XM_LIST_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateList()

	(send XM_LIST_WIDGET_CLASS :new [:managed/:unmanaged] :scrolled ...)
		--> XmCreateScrolledList()

	Note -- the :SCROLLED XmList widget created by XmCreateScrolledList()
	is anomalous, since it returns a list widget whose parent is of
	class xmScrolledWindowWidgetClass. Unless special kludgery was
	added since the last time I looked at the source, this may result
	in problems in using this widget with managers and constraint
	manager as <parent>. Motif has a few special cases for its own
	manager widgets, but other manager widgets (e.g. XmGraph,
	Table, etc) may not have special case code to handle this
	aspect of Motif misdesign. For such situations, or situations
	where you encounter problems in layout using the :scrolled
	XmText widget, you should pass
		(send <list_w> :parent)
	as the reference widget for layout attachments.

*** XtAddCallback():

	(send <listwidget> :ADD_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ
	(send <listwidget> :SET_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ

	These methods work just like the :ADD_CALLBACK/:SET_CALLBACK
	methods on WIDGET_CLASS except that these methods understand
	how to get call_data values from the XmListCallbackStruct:
		typedef struct
		{
		   int 	reason;
		   XEvent    *event;
		   XmString  item;
		   int       item_length;
		   int       item_position;
		   XmString  *selected_items;
		   int       selected_item_count;
		#ifdef MOTIF_1.1
		   int       *selected_item_positions;/* EXISTS ONLY IN 1.1 */
		#endif /* MOTIF_1.1 */	
		   int       selection_type;
		} XmListCallbackStruct;

	Specifying one or more of the following symbols in the callback
	bindings list will bind that symbol's value in the lexical
	environment of the callback:
		CALLBACK_WIDGET -- the WIDGETOBJ of the callback
		CALLBACK_REASON -- the reason symbol for the callback
		CALLBACK_XEVENT -- the XEvent* that caused the callback
		CALLBACK_ITEM	-- the selected list item, an XmString.
		CALLBACK_ITEM_LENGTH -- the length of XmString in CALLBACK_ITEM
		CALLBACK_ITEM_POSITION -- the position of the selected item
				          in the list, a nonnegative FIXNUM.
		CALLBACK_SELECTED_ITEMS -- an ARRAY of XmStrings corresponding
					   to the selected items in the list.
	   #ifdef MOTIF_1.1
		CALLBACK_SELECTED_ITEM_POSITIONS --
				-- an ARRAY of FIXNUMS reprenseting the
				   positions of items in the list widget.
	   #endif /* MOTIF_1.1 */
		CALLBACK_SELECTED_ITEM_COUNT -- a FIXNUM, the number of items
						in CALLBACK_SELECTED_ITEMS and
						CALLBACK_SELECTED_ITEM_POSITIONS
		CALLBACK_SELECTION_TYPE -- a SYMBOL, either INITIAL, ADDITION,
					   or MODIFICATION corresponding to
					   the Motif constants XmINITIAL,
					   XmADDITION, or XmMODIFICATION.

	Note that the callback bindings that are valid depend on the
	kind of callback you have set up:

	For :XMN_SINGLE_SELECTION_CALLBACK, :XMN_BROWSE_SELECTION_CALLBACK
	and :XMN_DEFAULT_ACTION_CALLBACK, the valid symbols are:
		CALLBACK_WIDGET, CALLBACK_REASON, CALLBACK_XEVENT,
		CALLBACK_ITEM, CALLBACK_ITEM_LENGTH, CALLBACK_ITEM_POSITION.

	For :XMN_MULTIPLE_SELECTION_CALLBACK, the valid symbols are:
		CALLBACK_WIDGET, CALLBACK_REASON, CALLBACK_XEVENT, 
		CALLBACK_ITEM, CALLBACK_ITEM_LENGTH, CALLBACK_ITEM_POSITION,
		CALLBACK_SELECTED_ITEMS, CALLBACK_SELECTED_ITEM_POSITIONS, 
		CALLBACK_SELECTED_ITEM_COUNT.

	For :XMN_EXTENDED_SELECTION_CALLBACK, the valid symbols are:
		CALLBACK_WIDGET, CALLBACK_REASON, CALLBACK_XEVENT, 
		CALLBACK_ITEM, CALLBACK_ITEM_LENGTH, CALLBACK_ITEM_POSITION,
		CALLBACK_SELECTED_ITEMS, CALLBACK_SELECTED_ITEM_COUNT,
		CALLBACK_SELECTION_TYPE, CALLBACK_SELECTED_ITEM_POSITIONS

*** XmListAddItem()

	(send <listwidget> :ADD_ITEM <item> <position>)
	     --> returns <item> as an XmString.

	This method adds <item> to <listwidget> at the given position.

	<item> is a string or XmString. If <item> is given as a string, it
	     is converted to an XmString and that XmString is returned.

	<position> is an positive fixnum. Specifying 0 will add the item to
	the end	of the list, 1 makes it the first item, 2 the second, etc.

*** XmListAddItemUnselected():

	(send <listwidget> :ADD_ITEM_UNSELECTED <item> <position>)
	     ==> returns <item> as an XmString.

	This method adds <item> to <listwidget> at the given position and
	ensures that <item> is not selected.

	<item> is a string or XmString. If <item> is given as a string, it
	is converted to an XmString and that XmString is returned by the
	method.

	<position> is an positive fixnum. Specifying 0 will add the item to
	the end	of the list, 1 makes it the first item, 2 the second, etc.

#ifdef MOTIF_1.1

*** XmListAddItems() [Motif >= 1.1 only]

	(send <listwidget> :ADD_ITEMS <item-seq> <position>)
		==> returns <listwidget>

	This method adds the specified items to the list at the
	given position. When the items are inserted into the list, they are
	compared with the current list of selected items. If the any of the new
	items matches an item on the selected list, it appears selected.

	<item-seq> is a list or array of strings or XmStrings. Note that if 
	strings are given, they will automatically be converted to XmStrings
	before being passed to <listwidget>.

	<position> is an positive fixnum. Specifying 0 will add the item to
	the end	of the list, 1 makes it the first item, 2 the second, etc.
#endif /* MOTIF_1.1 */

#ifdef MOTIF_1.1

*** XmListDeleteAllItems() [Motif >= 1.1 only]

	(send <listwidget> :DELETE_ALL_ITEMS)
		==> returns <listwidget>.

	XmListDeleteAllItems deletes all items from <listwidget>.
#endif /* MOTIF_1.1 */

*** XmListDeleteItem():

	(send <listwidget> :DELETE_ITEM <item>)
	     ==> returns <item> as an XmString

	This method deletes the specified <item> from <listwidget>, giving
	an XtWarning if <item> doesn't exist.

	<item> is a string or XmString. If <item> is given as a string, it
	is converted to an XmString and that XmString is returned by the
	method.

#ifdef MOTIF_1.1

*** XmListDeleteItems() [Motif >= 1.1 only]

	(send <listwidget> :DELETE_ITEMS <item-seq>)
		==> returns <listwidget>

	<item-seq> is a list or array of strings or XmStrings. Note that if 
	strings are given, they will automatically be converted to XmStrings
	before being passed to <listwidget>.

	This method deletes the specified <item-seq> from <listwidget>, giving
	an XtWarning if <item> doesn't exist.
#endif /* MOTIF_1.1 */

#ifdef MOTIF_1.1

*** XmListDeleteItemsPos() [Motif >= 1.1 only]

	(send <listwidget> :DELETE_ITEMS_POS <position> <item-count>)
		==> returns <listwidget>.

	This method deletes the items at <position> from <listwidget>. The
	number of items to delete at <position> is specified by
	<item-count>. A position of zero deletes the last item on the list.

	This method gives an XtWarning if the item doesn't exist.
	<position> is an positive fixnum.
	<item-count> is an positive fixnum.
#endif /* MOTIF_1.1 */

*** XmListDeletePos():

	(send <listwidget> :DELETE_POS <position>)
	     ==> returns <listwidget>.

	This method deletes the item at <position> from <listwidget>. A
	position of zero deletes the last item on the list. Gives an
	XtWarning if the item doesn't exist. <position> is an positive fixnum. 

*** XmListDeselectAllItems():

	(send <listwidget> :DESELECT_ALL_ITEMS)
	     ==> returns <listwidget>.

	This method unhighlights all selected items and removes all items
	from the selected items list.

*** XmListDeselectItem():

	(send <listwidget> :DESELECT_ITEM <item>)
	     ==> returns <item> as an XmString

	This method removes the specified <item> from the selected list and
	unhighlights it.

	<item> is a string or XmString. If <item> is given as a string, it
	is converted to an XmString and that XmString is returned by the
	method.

*** XmListDeselectPos():

	(send <listwidget> :DESELECT_POS <position>)
	     ==> returns <listwidget>.

	This method removes the item associated with <position> from the
	selected list and unhighlights it.

	<position> is an positive fixnum. 

#ifdef MOTIF_1.1

*** XmListGetMatchPos() [Motif >= 1.1 only]
	(send <listwidget> :GET_MATCH_POS <item>)
		==> returns an array of FIXNUMS, each representing the
		position of <item> in <listwidget>. Returns NIL if no matches
		found for <item>.

	<item> is a string or XmString. If <item> is given as a string, it
	is converted to an XmString.
#endif /* MOTIF_1.1 */

#ifdef MOTIF_1.1

*** XmListGetSelectedPos() [Motif >= 1.1 only]
	(send <listwidget> :GET_SELECTED_POS)
		==> returns an array of FIXNUMS, each representing the
		position of the selected items in <listwidget>. Returns NIL
		if there are no selected items.
#endif /* MOTIF_1.1 */

*** XmListItemExists():

	(send <listwidget> :ITEM_EXISTS <item>)
	     ==> returns T if the item is in the specified list widget,
		 else NIL.

	<item> is a string or XmString. If <item> is given as a string, it
	is converted to an XmString.

#ifdef MOTIF_1.1

*** XmListItemPos() [Motif >= 1.1 only]

	(send <listwidget> :ITEM_POS <item>)
		==> returns FIXNUM position of the first instance of <item> in
		<listwidget>. If <item> doesn't exist, returns NIL.

	<item> is a string or XmString. If <item> is given as a string, it
	is converted to an XmString. Note that the position of thefirst item
	in the list is 1, not 0.
#endif /* MOTIF_1.1 */

#ifdef MOTIF_1.1

*** XmListReplaceItems() [Motif >= 1.1 only]

	(send <listwidget> :REPLACE_ITEMS <old-item-seq> <new-item-seq>)
		==> returns <listwidget>

	This method replaces each specified item of the sequence <old-item-seq>
	with a corresponding new item from <new-item-seq>.

	<old-item-seq> and <new-item-seq> is a list or array of strings or
	XmStrings.  Note that if strings are given, they will automatically
	be converted to XmStrings before being passed to <listwidget>.
#endif /* MOTIF_1.1 */

#ifdef MOTIF_1.1

*** XmListReplaceItemsPos() [Motif >= 1.1 only]

	(send <listwidget> :REPLACE_ITEMS_POS <item-seq> <position>)
		==> returns <listwidget>

	This method replaces the items beginning at <position> with the
	items specified in <item-seq>. <item-seq> is a list or array of
	strings or XmStrings. Note that if strings are given, they will
	automatically be converted to XmStrings before being passed to
	<listwidget>.
#endif /* MOTIF_1.1 */

*** XmListSelectItem():

	(send <listwidget> :SELECT_ITEM <item> [<notify_p>])
	     ==> returns <item> as an XmString

	This method adds <item> to the selected items list and highlights it.

	<item> is a string or XmString. If <item> is given as a string, it
	is converted to an XmString and that XmString is returned by the
	method.

	<notify_p> is an optional boolean parameter. If non-NIL, it will
	issue a	callback indicating an item has been selected.

*** XmListSelectPos():

	(send <listwidget> :SELECT_POS <position> [<notify_p>])
	     ==> returns <listwidget>.

	This method adds the item corresponding to <position> to the selected
	items list and highlights it.

	<position> is an positive fixnum. 

	<notify_p> is an optional boolean parameter. If non-NIL, it will
	issue a	callback indicating an item has been selected.

#ifdef MOTIF_1.1

*** XmListSetAddMode() [Motif >= 1.1 only]

	(send <listwidget> :SET_ADD_MODE <add-mode-p>)
		==> returns <listwidget>

	<add-mode-p> is a boolean. If <add-mode-p> non-NIL, then <listwidget>
	will be set into add mode. This allows application-control over
	Add Mode in the extended selection model.
#endif /* MOTIF_1.1 */

*** XmListSetBottomItem():

	(send <listwidget> :SET_BOTTOM_ITEM <item>)
	     ==> returns <item> as an XmString

	This method makes <item> be the last visible position in the list.
	<item> is a string or XmString. If <item> is given as a string, it
	is converted to an XmString and that XmString is returned by the
	method.

*** XmListSetBottomPos():

	(send <listwidget> :SET_BOTTOM_POS <position>)
	     ==> returns <listwidget>.

	This method makes the item associated with <position> be the last
	visible	position in the list.

	<position> is an positive fixnum. 

*** XmListSetHorizPos():

	(send <listwidget> :SET_HORIZ_POS <position>)
	     ==> returns <listwidget>.

	This method scrolls the list horizontally such that the scrollbar
	reflects <position> in the list.

	<position> is an positive fixnum. 

*** XmListSetItem():

	(send <listwidget> :SET_ITEM <item>)
	     ==> returns <item> as an XmString

	This method makes <item> be the first visible item in the
	list. <item> is a string or XmString. If <item> is given as a
	string, it is converted to an XmString and that XmString is
	returned by the method.

*** XmListSetPos():

	(send <listwidget> :SET_POS <position>)
	     ==> returns <listwidget>.

	This method makes the item associated with <position> be the first
	visible element of the list.

	<position> is an positive fixnum. 

*** XtGetValues(XmNitems/XmNitemCount):

	(send <listwidget> :GET_ITEMS)
		--> returns an array of XM_STRING, each representing
		an item in the list widget.

	This method allows retrieval of list widget resource XmNitems.
	Due to flaws in Motif/Xt design, :GET_VALUES on resource
	:XMN_ITEMS cannot be done in a straightforward fashion.
	I've worked around that limitation by providing this method.

*** XtGetValues(XmNselectedItems/XmNselectedItemCount):

	(send <listwidget> :GET_SELECTED_ITEMS)
		--> returns an array of XM_STRING, each representing
		a selected item in the list widget.

	This method allows retrieval of list widget resource XmNselectedItems.
	Due to flaws in Motif/Xt design, :GET_VALUES on resource
	:XMN_SELECTED_ITEMS cannot be done in a straightforward fashion.
	I've worked around that limitation by providing this method.

______________________________________________________________________________

** XM_MAIN_WINDOW_WIDGET_CLASS

*** equivalent Xt 'WidgetClass':

	xmMainWindowWidgetClass

*** equivalent creation convenience function:

	(send XM_MAIN_WINDOW_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateMainWindow()

***  XmMainWindowSetAreas():

	(send <mainwinwidget> :SET_AREAS <menu> <command> <hscroll> <vscroll>
	                                 <workregion>)
	     ==> returns <mainwinwidget>.

	This method is used to attach children to be managed by an instance of
	XM_MAIN_WINDOW_WIDGET_CLASS. <menu> <command> <hscroll> <vscroll>
	and <workregion> are all WIDGETOBJs that must be created (with
	MainWindow as parent) before calling :SET_AREAS.
	If you don't want to set a particular region, pass NIL as the argument
	for the particular widget.

	<menu> specifies the WIDGETOBJ for the MenuBar to be
	associated with the MainWindow widget The resource name associated
	with this argument is :XMN_MENU_BAR.

	<command> specifies the WIDGETOBJ for the command window to be
	associated with the MainWindow widget. The resource name associated
	with this argument is :XMN_COMMAND_WINDOW.

	<hscroll> specifies the WIDGETOBJ for the horizontal ScrollBar to
	be associated with the MainWindow widget. The resource name associated
	with this argument is :XMN_HORIZONTAL_SCROLL_BAR.

	<vscroll> specifies the WIDGETOBJ for the vertical ScrollBar to be
	associated with the MainWindow widget. The resource name associated
	with this argument is :XMN_VERTICAL_SCROLL_BAR.

	<workregion> specifies the WIDGETOBJ for the work window to be
	associated with the MainWindow widget. The resource name associated
	with this argument is :XMN_WORK_WINDOW.

*** XmMainWindowSep1():

	(send <mainwinwidget> :SEP1)
	      ==> returns the WIDGETOBJ corresponding to the first
		  separator widget.

	The first separator widget is located between the MenuBar and the
	Command widget.  This separator is visible only when
	resource :XMN_SHOW_SEPARATOR is T.

*** XmMainWindowSep2():

	(send <mainwinwidget> :SEP2)
	      ==> returns the WIDGETOBJ corresponding to the second
		  separator widget.

	The second Separator widget is located between the Command widget
	and the ScrolledWindow.  This Separator is visible only when
	resource :XMN_SHOW_SEPARATOR is T.

#ifdef MOTIF_1.1

*** XmMainWindowSep3():  [Motif >= 1.1 only]

	(send <mainwinwidget> :SEP3)
	      ==> returns the WIDGETOBJ corresponding to the third
		  separator widget.

	The third Separator widget is located between the message window
	and the widget above it. This Separator is visible only when
	resource :XMN_SHOW_SEPARATOR is T.
#endif /* MOTIF_1.1 */
______________________________________________________________________________

** XM_MESSAGE_BOX_WIDGET_CLASS

*** equivalent Xt 'WidgetClass':

	xmMessageBoxWidgetClass

*** equivalent creation convenience function:

	(send XM_MESSAGE_BOX_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateMessageBox()

	(send XM_MESSAGE_BOX_WIDGET_CLASS :new [:managed/:unmanaged]
              :MESSAGE_DIALOG ...)
		--> XmCreateMessageDialog()

	(send XM_MESSAGE_BOX_WIDGET_CLASS :new [:managed/:unmanaged]
              :ERROR_DIALOG ...)
		--> XmCreateErrorDialog()

	(send XM_MESSAGE_BOX_WIDGET_CLASS :new [:managed/:unmanaged]
              :INFORMATION_DIALOG ...)
		--> XmCreateInformationDialog()

	(send XM_MESSAGE_BOX_WIDGET_CLASS :new [:managed/:unmanaged]
	      :QUESTION_DIALOG ...)
		--> XmCreateQuestionDialog()

	(send XM_MESSAGE_BOX_WIDGET_CLASS :new [:managed/:unmanaged]
              :WARNING_DIALOG ...)
		--> XmCreateWarningDialog()

	(send XM_MESSAGE_BOX_WIDGET_CLASS :new [:managed/:unmanaged]
              :WORKING_DIALOG ...)
		--> XmCreateWorkingDialog()

   #ifdef MOTIF_1.2 (1.2.2 or greater)
	(send XM_MESSAGE_BOX_WIDGET_CLASS :new [:managed/:unmanaged]
              :TEMPLATE_DIALOG ...)
		--> XmCreateTemplateDialog()
   #endif MOTIF_1.2

*** XmMessageBoxGetChild():

	(send <messageboxwidget> :GET_CHILD <symbol>)
		--> returns a WIDGETOBJ, the child of <messageboxwidget> 
		corresponding to one of the following keyword <symbol>s:
			:DIALOG_DEFAULT_BUTTON
			:DIALOG_SYMBOL_LABEL
			:DIALOG_MESSAGE_LABEL
			:DIALOG_OK_BUTTON
			:DIALOG_CANCEL_BUTTON
			:DIALOG_HELP_BUTTON
			:DIALOG_SEPARATOR
______________________________________________________________________________

** XM_PANED_WINDOW_WIDGET_CLASS

*** equivalent Xt 'WidgetClass':

	xmPanedWindowWidgetClass

*** equivalent creation convenience function:

	(send XM_PANED_WINDOW_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreatePanedWindow()
______________________________________________________________________________

** XM_PUSH_BUTTON_WIDGET_CLASS / XM_PUSH_BUTTON_GADGET_CLASS

*** equivalent Xt 'WidgetClass':

	xmPushButtonWidgetClass
	xmPushButtonGadgetClass

*** equivalent creation convenience function:

	(send XM_PUSH_BUTTON_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreatePushButton()

	(send XM_PUSH_BUTTON_GADGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreatePushButtonGadget()

*** XtAddCallback():

   #ifdef MOTIF_1.0
	In Motif 1.0, :ADD_CALLBACK/:SET_CALLBACK on push buttons will
	use the :ADD_CALLBACK/:SET_CALLBACK methods defined on
	<WIDGET_CLASS>, the XmAnyCallbackStruct fields defined on those
	methods will be valid.
   #endif /* MOTIF_1.0 */

   #ifdef MOTIF_1.1
	(send <push-button> :ADD_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ
	(send <push-button> :SET_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ

	These methods work just like the :ADD_CALLBACK/:SET_CALLBACK
	methods on WIDGET_CLASS except that these methods understand
	how to get call_data values from the XmPushButtonCallbackStruct
		typedef struct
		{
		   int		reason;
		   XEvent	*event;
		   int		click_count;
		} XmPushButtonCallbackStruct;

	Specifying one or more of the following symbols in the callback
	bindings list will bind that symbol's value in the lexical
	environment of the callback:
		CALLBACK_WIDGET -- the WIDGETOBJ of the callback
		CALLBACK_REASON -- the reason symbol for the callback
		CALLBACK_XEVENT -- the XEvent* that caused the callback
		CALLBACK_CLICK_COUNT -- a FIXNUM representing the number of
					clicks upon the button. The click count
					will only be > 1 when resource 
					:XMN_MULTI_CLICK == :MULTICLICK_KEEP
   #endif /* MOTIF_1.1 */
______________________________________________________________________________

** XM_ROW_COLUMN_WIDGET_CLASS

*** equivalent Xt 'WidgetClass':

	xmRowColumnWidgetClass

*** equivalent creation convenience function:

	(send XM_ROW_COLUMN_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateRowColumn()

   #ifdef MOTIF_1.1
	(send XM_ROW_COLUMN_WIDGET_CLASS :new [:managed/:unmanaged] ...
	      :WORK_AREA ...)
		-->  XmCreateWorkArea();
   #endif /* MOTIF_1.1 */

	(send XM_ROW_COLUMN_WIDGET_CLASS :new [:managed/:unmanaged]
	      :RADIO_BOX ...)
		--> XmCreateRadioBox()

   #ifdef MOTIF_1.1
	(send XM_ROW_COLUMN_WIDGET_CLASS :new [:managed/:unmanaged]
	      :SIMPLE_RADIO_BOX ...)
		-->  XmCreateSimpleRadioBox();
   #endif /* MOTIF_1.1 */

	(send XM_ROW_COLUMN_WIDGET_CLASS :new [:managed/:unmanaged]
	      :OPTION_MENU ...)
		--> XmCreateOptionMenu()

   #ifdef MOTIF_1.1
	(send XM_ROW_COLUMN_WIDGET_CLASS :new [:managed/:unmanaged]
	      :SIMPLE_OPTION_MENU ...)
		--> XmCreateSimpleOptionMenu();
   #endif /* MOTIF_1.1 */

	(send XM_ROW_COLUMN_WIDGET_CLASS :new [:managed/:unmanaged]
	      :MENU_BAR ...)
		--> XmCreateMenuBar()

   #ifdef MOTIF_1.1
	(send XM_ROW_COLUMN_WIDGET_CLASS :new [:managed/:unmanaged]
	      :SIMPLE_MENU_BAR ...)
		--> XmCreateSimpleMenuBar();
   #endif /* MOTIF_1.1 */

	(send XM_ROW_COLUMN_WIDGET_CLASS :new [:managed/:unmanaged]
	      :POPUP_MENU ...)
		--> XmCreatePopupMenu()

   #ifdef MOTIF_1.1
	(send XM_ROW_COLUMN_WIDGET_CLASS :new [:managed/:unmanaged]
	      :SIMPLE_POPUP_MENU ...)
		--> XmCreateSimplePopupMenu();
   #endif /* MOTIF_1.1 */

	(send XM_ROW_COLUMN_WIDGET_CLASS :new [:managed/:unmanaged]
	      :PULLDOWN_MENU ...)
		--> XmCreatePulldownMenu()

   #ifdef MOTIF_1.1
	(send XM_ROW_COLUMN_WIDGET_CLASS :new [:managed/:unmanaged]
	      :SIMPLE_PULLDOWN_MENU ...)
		--> XmCreateSimplePulldownMenu();
   #endif /* MOTIF_1.1 */

   #ifdef MOTIF_1.1
	(send XM_ROW_COLUMN_WIDGET_CLASS :new [:managed/:unmanaged]
	      :SIMPLE_CHECK_BOX ...)
		--> XmCreateSimpleCheckBox();
   #endif /* MOTIF_1.1 */

*** High-Level interface to XmCreateSimple*() routines:

	Don't use the techniques mentioned below in
	<<Deprecated: Note on XmCreateSimple*() routines:>>. There is a better
	way. See:

		<winterp-top-dir>/examples/fake-app1.lsp:
			Uses WINTERP:APPLICATION-WIDGET-CLASS and other
			high-level interfaces to XmCreateSimple*() routines
			to create a fake application complete w/ menubar, etc.

		<winterp-top-dir>/examples/lib-widgets/application.lsp:
			Define WINTERP:APPLICATION-WIDGET-CLASS a subclass of
			XM_MAIN_WINDOW_WIDGET_CLASS which contains a message
			area instance of TIMED-MESSAGE-DISPLAY-WIDGET-CLASS and
			has a pulldown menu system created from a
			WINTERP:MENU-BAR-WIDGET-CLASS instance.

		<winterp-top-dir>/examples/lib-widgets/simple-RC.lsp:
			Define subclasses of XM_ROW_COLUMN_WIDGET_CLASS which
			simplify access to the "simple menu" creation routines.
			Specifically: WINTERP:RADIO-BOX-WIDGET-CLASS,
			WINTERP:OPTION-MENU-WIDGET-CLASS,
			WINTERP:MENU-BAR-WIDGET-CLASS,
			WINTERP:POPUP-MENU-WIDGET-CLASS,
			WINTERP:PULLDOWN-MENU-WIDGET-CLASS,
			WINTERP:CHECK-BOX-WIDGET-CLASS.

*** Deprecated: Low-level interface to XmCreateSimple*() routines:

	If you use any of the XmCreateSimple*() routines above, you
	will also want to set the following resources (which are settable
	only at widget creation	time) :XMN_POST_FROM_BUTTON,
	:XMN_BUTTON_COUNT, :XMN_BUTTONS, :XMN_BUTTON_MNEMONICS,
	:XMN_BUTTON_MNEMONIC_CHAR_SETS,	:XMN_BUTTON_ACCELERATORS,
	:XMN_BUTTON_ACCELERATOR_TEXT, :XMN_BUTTON_TYPE, :XMN_BUTTON_SET,
	:XMN_OPTION_LABEL, :XMN_OPTION_MNEMONIC.

	For example, the following code will create a menu-bar, and 
	the first pulldown of the menu-bar entry ("Files"):

  (setq menubar_w
	(send XM_ROW_COLUMN_WIDGET_CLASS :new :managed :simple_menu_bar
	      "menubar" main_w
	      :XMN_BUTTON_COUNT 5	;create file cascadebuttons in menubar
	      :XMN_BUTTONS
	      		#("Files" "Edit" "Fold" "Spindle" "Mutilate")
	      :XMN_BUTTON_MNEMONICS
			#(#\F     #\E    #\o    #\S       #\M)
	      ))

   (setq pulldown_w
	 (send XM_ROW_COLUMN_WIDGET_CLASS :new :simple_pulldown_menu
	       "pulldown" menubar_w
	       :XMN_POST_FROM_BUTTON 0	;post pulldown from menubar's "Files"
	       :XMN_BUTTON_COUNT 5	;create five buttons in this pulldown
	       :XMN_BUTTONS
			#("Quit" "Open" "Open in New Window" "Save" "Save As")
	       :XMN_BUTTON_MNEMONICS
			#(#\Q    #\O    #\N                  #\S    #\A)
	       :XMN_BUTTON_MNEMONIC_CHAR_SETS
			#("" "" "ISO8859-1" "ISO8859-1" "ISO8859-1")
	       :XMN_BUTTON_ACCELERATORS
			#("Ctrl<Key>C" "Ctrl<Key>F" "Ctrl<Key>O" "Ctrl<Key>S" "Ctrl<Key>W")
	       :XMN_BUTTON_ACCELERATOR_TEXT
			#("^C" "^F" "^O" "^S" "^W")
	       :XMN_BUTTON_TYPE 
			#(:PUSHBUTTON :PUSHBUTTON :PUSHBUTTON :PUSHBUTTON
			  :PUSHBUTTON)
	       ))

	Note: WINTERP does not provide an interface to XmNsimpleCallback, which
	is the newfangled way Motif expects you to set up callbacks on
	widgets created by XmCreateSimple*(). Instead, WINTERP employs an
	already existing means of setting callbacks in the row-column widget --
	XmNentryCallback (:XMN_ENTRY_CALLBACK). This is a truly amazing concept
	for Motif, being able to use the same code and techniques to do slightly
	different things. :->

	The following example sets up a callback on pulldown_w which was
	created by XmCreateSimplePulldownMenu() in the example above. The
	callback will print the message associated with the function behind
	each button in the menu:
		
   (send pulldown_w
	 :add_callback :xmn_entry_callback ;use instead of XmNsimpleCallback
	 '(CALLBACK_ENTRY_WIDGET)	;gets bound to widget causing c.b.
	 '(
	   ;; (send CALLBACK_ENTRY_WIDGET :name) returns "button_<#>"
	   ;; where <#> is 0 ... (:XMN_BUTTON_COUNT - 1).
	   ;; we use 'read' to return the FIXNUM <#> after truncating the
	   ;; 7 chars "button_" from the front of the string.
	   (case (read (make-string-input-stream
			(send CALLBACK_ENTRY_WIDGET :name) 7))
		 (0 (format T "Quit Function Called\n"))
		 (1 (format T "Open Function Called\n"))
		 (2 (format T "Open in New Window Function Called\n"))
		 (3 (format T "Save Function Called\n"))
		 (4 (format T "Save As Function Called\n"))
		 (T (format T "Error\n")))
	   ))

	For further examples of using XmCreateSimple*() routines, see
	./../examples/fake-app.lsp and
	./../examples/RowColumn.lsp.

*** XtAddCallback():

	(send <rowcolwidget> :ADD_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ
	(send <rowcolwidget> :SET_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ

	These methods work just like the :ADD_CALLBACK/:SET_CALLBACK
	methods on WIDGET_CLASS except that these methods understand
	how to get call_data values from the XmRowColumnCallbackStruct:
		typedef struct
		{
		    int     reason;
		    XEvent  *event;
		    Widget  widget;
		    char    *data;
		    char    *callbackstruct;
		} XmRowColumnCallbackStruct;

	Specifying one or more of the following symbols in the callback
	bindings list will bind that symbol's value in the lexical
	environment of the callback:
		CALLBACK_WIDGET -- the WIDGETOBJ of the callback
		CALLBACK_REASON -- the reason symbol for the callback
		CALLBACK_XEVENT -- the XEvent* that caused the callback
	
	If the you're doing 
	(send <rowcolwidget> :ADD_CALLBACK :XMN_ENTRY_CALLBACK ...) or
	(send <rowcolwidget> :SET_CALLBACK :XMN_ENTRY_CALLBACK ...)
	then the following symbols may be bound to call_data values from the
	entry widget in <rowcolwidget> that fired:

		CALLBACK_ENTRY_WIDGET -- a WIDGETOBJ representing the child
					 of <rowcolwidget> that fired.
		CALLBACK_ENTRY_REASON -- the reason SYMBOL for an
					 entrywidget of class
					 XM_TOGGLE_BUTTON_GADGET_CLASS or
					 XM_TOGGLE_BUTTON_WIDGET_CLASS
		CALLBACK_ENTRY_SET    -- T if the entrywidget is a
					 set toggle button, NIL if
					 an unset togglebutton. IF not a
					 togglebutton, then results
					 unpredictable.
	   #ifdef MOTIF_1.1
		CALLBACK_ENTRY_CLICK_COUNT -- a FIXNUM representing the number of
					      clicks upon the entry-button. The
					      click count will only be > 1 when
					      the entry-button's resource
					      :XMN_MULTI_CLICK is set to
					      :MULTICLICK_KEEP. This callback
					      symbol should only be used if the
					      entry is a button -- unpredictable
					      results will occur for other cases.
	   #endif /* MOTIF_1.1 */
		CALLBACK_ENTRY_DATA   -- if a callback was set for the
					 entry widget, this will be its
					 CALLBACKOBJ. Uses for this
					 parameter are unknown and
					 unpredictable. 

*** XmMenuPosition():

	(send <popup_menu> :MENU_POSITION <event>)
	     ==> returns <popup_menu>

	This method will position a popup menupane at the position
	specified by event->x_root, event->y_root, where <event> is an XEvent.
	This method should only be used on a row_column widget created via
	(send XM_ROW_COLUMN_WIDGET_CLASS :new :popup_menu ...).

*** XmOptionLabelGadget():

	(send <option_menu> :OPTION_LABEL_GADGET)
	     ==> returns the WIDGETOBJ corresponding to the label
	         gadget created in an <option_menu> instance. 

	This method should only be used on a rowcolumn instance created
	via (send XM_ROW_COLUMN_WIDGET_CLASS :new :option_menu ...)

*** XmOptionButtonGadget():

	(send <option_menu> :OPTION_BUTTON_GADGET)
	     ==> returns the WIDGETOBJ corresponding to the cascade
	         button gadget created in an <option_menu> instance.

	This method should only be used on a rowcolumn instance created
	via (send XM_ROW_COLUMN_WIDGET_CLASS :new :option_menu ...)

#ifdef MOTIF_1.1

*** XmGetPostedFromWidget(): [Motif >= 1.1 only]

	(send <menu> :GET_POSTED_FROM_WIDGET)
		==> returns the WIDGETOBJ corresponding to the
		    the widget from which the menu was posted.

	This method returns the WIDGETOBJ from which a menu was posted. An
	application can use this routine during the activate callback to
	determine the context in which the menu callback should be interpreted.

	In a popup, the widget returned is the widget which initiated the
	post. In a pulldown from a menubar or option menu, then the
	returned widget is the menubar or option menu.
#endif /* MOTIF_1.1 */

#ifdef MOTIF_1.1

*** XtGetValues(...XmNsubMenuId...): [Motif 1.1 only -- Motif bug work-around]

	(send <rowcolwidget> :GET_SUB_MENU_WIDGET)
		==> this method returns the WIDGETOBJ corresponding to the
		the widget returned by resource XmNsubMenuId.

	Why use this instead of XmNsubMenuId?? Because due to some weird
	Motif 1.1 bug, (probably in motif) doing
	(send <rowcolwidget> :get_values :XMN_SUB_MENU_ID nil) returns
	<rowcolwidget>. ???
#endif /* MOTIF_1.1 */

*** NOTE on methods :MENU_POSITION :OPTION_BUTTON_GADGET :OPTION_LABEL_GADGET, GET_POSTED_FROM_WIDGET, and :GET_SUB_MENU_WIDGET:

	Future versions of WINTERP may create a special POPUP_MENU_CLASS
	and OPTION_MENU_CLASS subclasses of XM_ROW_COLUMN_WIDGET_CLASS that
	have :MENU_POSITION and {:OPTION_BUTTON_GADGET,:OPTION_LABEL_GADGET}
	as methods in order to avoid problems with calling these methods on the
	wrong row column widget variant.
______________________________________________________________________________

** XM_SCALE_WIDGET_CLASS

*** equivalent Xt 'WidgetClass':

	xmScaleWidgetClass

*** equivalent creation convenience function:

	(send XM_SCALE_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateScale()

*** XtAddCallback():

	(send <scale_widget> :ADD_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ
	(send <scale_widget> :SET_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ

	These methods work just like the :ADD_CALLBACK/:SET_CALLBACK
	methods on WIDGET_CLASS except that these methods understand
	how to get call_data values from the XmScaleCallbackStruct:
		typedef struct 
		{
		   int reason;
		   XEvent * event;
		   int value;
		} XmScaleCallbackStruct;

	Specifying one or more of the following symbols in the callback
	bindings list will bind that symbol's value in the lexical
	environment of the callback:
		CALLBACK_WIDGET -- the WIDGETOBJ of the callback
		CALLBACK_REASON -- the reason symbol for the callback
		CALLBACK_XEVENT -- the XEvent* that caused the callback
		CALLBACK_VALUE  -- a FIXNUM representing the slider location.

*** XmScaleSetValue():

	(send <scale_widget> :SET_VALUE <value>)
		==> returns <scale_widget>

	This method sets the <scale_widget>'s slider position to <value>, a
	FIXNUM.

*** XmScaleGetValue():

	(send <scale_widget> :GET_VALUE)
		--> returns slider value as a FIXNUM
______________________________________________________________________________

** XM_SCROLLED_WINDOW_WIDGET_CLASS

*** equivalent Xt 'WidgetClass':

	xmScrolledWindowWidgetClass

*** equivalent creation convenience function:

	(send XM_SCROLLED_WINDOW_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateScrolledWindow()

*** XmScrolledWindowSetAreas():

	(send <ScrolledWin_Widget> :SET_AREAS <hscroll> <vscroll> <wregion>)
		--> returns <ScrolledWin_Widget>

	This method allows you to add or change the work region controlled by
	a scrolled window, and set the scrollbars for scrolled windows in which
	resource :XMN_SCROLLING_POLICY is set to :APPLICATION_DEFINED.
	<wregion> <hscroll> and  <vscroll> are all WIDGETOBJs. Use NIL
	if you don't want to set a particular parameter.

*** XmScrollVisible():

	(send <ScrolledWin_Widget> :SCROLL_VISIBLE <wid>
				                   <hor-margin> <ver-margin>)
		--> returns <ScrolledWin_Widget>....

	Method :SCROLL_VISIBLE makes WIDGETOBJ <wid>, an obscured or partially
	obscured widget or gadget descendant of a ScrolledWindow work area
	visible.  The function repositions the work area and sets the specified
	margins (FIXNUMs <hor-margin> and <ver-margin>) between the widget
	and the nearest viewport boundary. The widget's location relative
	to the viewport determines whether one or both of the margins must
	be adjusted. This function requires that the :XMN_SCROLLING_POLICY of
	the ScrolledWindow widget be set to :AUTOMATIC.

______________________________________________________________________________

** XM_SCROLL_BAR_WIDGET_CLASS

*** equivalent Xt 'WidgetClass':

	xmScrollBarWidgetClass

*** equivalent creation convenience function:

	(send XM_SCROLL_BAR_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateScrollBar()

*** XtAddCallback():
	(send <scrollbar_widget> :ADD_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ
	(send <scrollbar_widget> :SET_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ

	These methods work just like the :ADD_CALLBACK/:SET_CALLBACK
	methods on WIDGET_CLASS except that these methods understand
	how to get call_data values from the XmScrollBarCallbackStruct:
		typedef struct
		{
		   int reason;
		   XEvent * event;
		   int value;
		   int pixel;
		} XmScrollBarCallbackStruct;

	Specifying one or more of the following symbols in the callback
	bindings list will bind that symbol's value in the lexical
	environment of the callback:
		CALLBACK_WIDGET -- the WIDGETOBJ of the callback
		CALLBACK_REASON -- the reason symbol for the callback
		CALLBACK_XEVENT -- the XEvent* that caused the callback
		CALLBACK_VALUE  -- a FIXNUM representing the slider location.
		CALLBACK_PIXEL  -- a FIXNUM representing the coordinate of
				   the mouse button selection. For a
				   vertical scrollbar, it's the 'y'
				   coordinate; For a horizontal scrollbar,
				   it's the 'x' coordinate.
				   NOTE: The value is valid only for callbacks
				   :XMN_TO_TOP_CALLBACK/:XMN_TO_BOTTOM_CALLBACK

*** XmScrollBarGetValues():

	(send <scrollbar_widget> :GET_VALUE) 
		==> returns a list
		(<value> <slider_size> <increment> <page_increment>)
		all of which are FIXNUMs representing  the values of resources
		:XMN_VALUE, :XMN_SLIDER_SIZE, :XMN_INCREMENT, and
		:XMN_PAGE_INCREMENT respectively.
	
	Note that I couldn't call this method :GET_VALUES (for consistency
	with the name XmScrollBarGetValues()) because it would override
	method :GET_VALUES on WIDGET_CLASS.

*** XmScrollBarSetValues():

	(send <scrollbar_widget> :SET_VALUE <value> <slider_size> 
	                                    [[[<increment>]
					      <page_increment>]
					     <notify>])
	==> returns <scrollbar_widget>.

	<value> is a fixnum specifying the slider position
	(same as setting the resource :XMN_VALUE)

	<slider_size> is a fixnum specifying the size of the slider.
	(same as setting resource :XMN_SLIDER_SIZE).

	<increment> is an optional fixnum specifying the amount of button
	increment and decrement. (same as setting resource :XMN_INCREMENT).

	<page_increment> is an optional fixnum specifying the page
	increment size. (same as setting resource :XMN_INCREMENT).

	<notify> is an optional Boolean, if NIL, the value changed callback
	will not be activated, else it will.
	
	Note that I couldn't call this method :SET_VALUES (for consistency
	with name XmScrollBarSetValues()) because it would override method
	:SET_VALUES on WIDGET_CLASS.
______________________________________________________________________________

** XM_SELECTION_BOX_WIDGET_CLASS

*** equivalent Xt 'WidgetClass':

	xmSelectionBoxWidgetClass

*** equivalent creation convenience function:

	(send XM_SELECTION_BOX_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateSelectionBox()

	(send XM_SELECTION_BOX_WIDGET_CLASS :new [:managed/:unmanaged] :dialog ...)
		--> XmCreateSelectionDialog()

	(send XM_SELECTION_BOX_WIDGET_CLASS :new [:managed/:unmanaged] :prompt_dialog ...)
		--> XmCreatePromptDialog()

*** XtAddCallback():

	(send <selectionbox_widget> :ADD_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ
	(send <selectionbox_widget> :SET_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ

	These methods work just like the :ADD_CALLBACK/:SET_CALLBACK
	methods on WIDGET_CLASS except that these methods understand
	how to get call_data values from the XmSelectionBoxCallbackStruct:
		typedef struct
		{
		    int reason;
		    XEvent	*event;
		    XmString	value;
		    int	length;
		} XmSelectionBoxCallbackStruct;

	Specifying one or more of the following symbols in the callback
	bindings list will bind that symbol's value in the lexical
	environment of the callback:
		CALLBACK_WIDGET -- the WIDGETOBJ of the callback
		CALLBACK_REASON -- the reason symbol for the callback
		CALLBACK_XEVENT -- the XEvent* that caused the callback
		CALLBACK_VALUE  -- an XmString, the value selected from
				   the selectionbox list, or entered into
				   the selectionbox text field.
		CALLBACK_LENGTH -- the length of XmString CALLBACK_VALUE.

*** XmSelectionBoxGetChild():

	(send <selectionbox_widget> :get_child <childname>)
	==> returns the WIDGETOBJ corresponding to <childname> which is one
	    of the following keyword symbols:
		:DIALOG_LIST, :DIALOG_LIST_LABEL, :DIALOG_SELECTION_LABEL,
		:DIALOG_WORK_AREA, :DIALOG_TEXT, :DIALOG_SEPARATOR,
		:DIALOG_OK_BUTTON, :DIALOG_APPLY_BUTTON,
		:DIALOG_CANCEL_BUTTON, :DIALOG_HELP_BUTTON,
		:DIALOG_DEFAULT_BUTTON

*** XtGetValues(XmNlistItems/XmNlistItemCount):

	(send <selectionbox_widget> :GET_LIST_ITEMS)
		--> returns an array of XM_STRING, each representing
		a selected item in the selection box's list widget.

	This method allows retrieval of list widget resource XmNlistItems.
	Due to flaws in Motif/Xt design, :GET_VALUES on resource
	:XMN_LIST_ITEMS cannot be done in a straightforward fashion.
	I've worked around that limitation by providing this method.

______________________________________________________________________________

** XM_SEPARATOR_WIDGET_CLASS / XM_SEPARATOR_GADGET_CLASS

*** equivalent Xt 'WidgetClass':

	xmSeparatorWidgetClass
	xmSeparatorGadgetClass

*** equivalent creation convenience function:

	(send XM_SEPARATOR_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateSeparator()

	(send XM_SEPARATOR_GADGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateSeparatorGadget()
______________________________________________________________________________

** XM_TEXT_WIDGET_CLASS // XM_TEXT_FIELD_WIDGET_CLASS

*** equivalent Xt 'WidgetClass':

	xmTextWidgetClass, xmTextFieldWidgetClass

*** equivalent creation convenience function:

   #ifdef MOTIF_1.1
	(send XM_TEXT_FIELD_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateTextField()
   #endif /* MOTIF_1.1 */

	(send XM_TEXT_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateText()

	(send XM_TEXT_WIDGET_CLASS :new [:managed/:unmanaged] :scrolled ...)
		--> XmCreateScrolledText()

	Note -- the :SCROLLED XmText widget created by XmCreateScrolledText()
	is anomalous, since it returns a text widget whose parent is of
	class xmScrolledWindowWidgetClass. Unless special kludgery was
	added since the last time I looked at the source, this may result
	in problems in using this widget with managers and constraint
	manager as <parent>. Motif has a few special cases for its own
	manager widgets, but other manager widgets (e.g. XmGraph,
	Table, etc) may not have special case code to handle this
	aspect of Motif misdesign. For such situations, or situations
	where you encounter problems in layout using the :scrolled
	XmText widget, you should pass
		(send <text_w> :parent)
	as the reference widget for layout attachments.

*** XtAddCallback():

	(send <text> :ADD_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ
	(send <text> :SET_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ

	These methods work just like the :ADD_CALLBACK/:SET_CALLBACK
	methods on WIDGET_CLASS except that these methods understand
	how to get call_data values from the XmTextVerifyCallbackStruct:
		typedef struct
		{
		    int reason;
		    XEvent  *event;
		    Boolean doit;
		    XmTextPosition currInsert, newInsert;
		    XmTextPosition startPos, endPos;
		    XmTextBlock text;
		} XmTextVerifyCallbackStruct, *XmTextVerifyPtr;

	Specifying one or more of the following symbols in the callback
	bindings list will bind that symbol's value in the lexical
	environment of the callback:
		CALLBACK_WIDGET -- the WIDGETOBJ of the callback
		CALLBACK_REASON -- the reason symbol for the callback
		CALLBACK_XEVENT -- the XEvent* that caused the callback
		CALLBACK_DOIT   -- this is always bound to T, but if you
				   set it to NIL within the body of the
				   callback code, you can prevent the action
				   that caused the callback from occuring.
				   This field is only valid for
					:XMN_LOSING_FOCUS_CALLBACK, 
					:XMN_MODIFY_VERIFY_CALLBACK, and
					:XMN_MOTION_VERIFY_CALLBACK.
		CALLBACK_CUR_INSERT -- a FIXNUM, the current position of the
				       insert cursor. This field is only
				       valid for:
					:XMN_LOSING_FOCUS_CALLBACK, 
					:XMN_MODIFY_VERIFY_CALLBACK, and
					:XMN_MOTION_VERIFY_CALLBACK.
		CALLBACK_NEW_INSERT -- a FIXNUM, the position at which the 
				       user attempted to position the
				       insert cursor. This field is only
				       valid for:
					:XMN_LOSING_FOCUS_CALLBACK, 
					:XMN_MODIFY_VERIFY_CALLBACK, and
					:XMN_MOTION_VERIFY_CALLBACK.
		CALLBACK_START_POS  -- a FIXNUM, the starting position of
				       the text to modify. This field is
				       only valid for: 
					:XMN_LOSING_FOCUS_CALLBACK, and
					:XMN_MODIFY_VERIFY_CALLBACK.
		CALLBACK_END_POS    -- a FIXNUM, the ending position of the 
				       text to modify. This field is
				       only valid for: 
					:XMN_LOSING_FOCUS_CALLBACK, and
					:XMN_MODIFY_VERIFY_CALLBACK.
		CALLBACK_TEXT        -- A STRING, holds the textual
					information that was inserted. This 
					field is only valid for 
					:XMN_MODIFY_VERIFY_CALLBACK.

*** XM_TEXT_WIDGET_CLASS Method :READ_FILE :

	(send <text_widget> :READ_FILE <filename>)
		--> on success, returns a FIXNUM -- the length of the file;
		    on failure to read file, signals an error.

	This method displays <filename> in <text_widget>. <filename> is a
	STRING representing the fully qualified path to the file.
	Errors will be signalled if the file is not readable.
	
*** XM_TEXT_WIDGET_CLASS Method :WRITE_FILE :

	(send <text_widget> :WRITE_FILE <filename>)
		--> on success, returns a FIXNUM -- the length of the file;
		    on failure to write file, signals an error.

	This method writes the text in <text_widget> into <filename>.
	<filename> is a STRING representing the fully qualified path to the
	file. Errors will be signalled if the file is not writeable.

*** XM_TEXT_WIDGET_CLASS Method :READ_FILE_GOTO_LINE :

	(send <text_widget> :READ_FILE_GOTO_LINE <filename> <linenum>
						 <highlight_p>)
		--> on success, returns a FIXNUM -- the length of the file;
		    on failure to read file, signals an error.
	<filename> is a STRING, the full path to the file to be read.
	<linenum> is a FIXNUM >=0, the line to display.
	<higlight_p> is a boolean, if non-NIL highlights the selected line.

	This method combines the capabilities of :READ_FILE and :GOTO_LINE...

*** XM_TEXT_WIDGET_CLASS Method :GOTO_LINE :

	(send <text_widget> :GOTO_LINE <linenum> <highlight_p>)
		--> returns the FIXNUM position of the desired current line.
	<linenum> is a FIXNUM >=0, the line to display.
	<higlight_p> is a boolean, if non-NIL the highlight the selected line.

	This method puts the cusor on the desired <linenum>.
	highlighting the line if <highlight_p> is true.

*** XM_TEXT_WIDGET_CLASS Method :SEARCH :

	(send <text_widget> :SEARCH <search-str>)
		--> returns NIL if <search-str> not found in <text-w>
		    returns a FIXNUM == the position of the text on success.

	This method puts the cursor on the position in <text_widget>
	where the text under the cursor matches <search-str>. It
	returns that position.

*** XmTextClearSelection() // XmTextFieldClearSelection():

	(send <text> :CLEAR_SELECTION [<xevent>])
		--> returns <text>

	This method clears the primary selection in the Text widget.	

	The optional <xevent> parameter is an XEVENT object from which
	the event-time is taken. Most often one would just pass in the
	value of callback symbol CALLBACK_XEVENT. If the <xevent> argument
	is missing, then 'CurrentTime' (Motif 1.0) or
	'XtLastTimestampProcessed()' (Motif 1.1) is used.

#ifdef MOTIF_1.1

*** XmTextCopy() // XmTextFieldCopy() [Motif >= 1.1 only]:

	(send <text> :COPY [<xevent>])
		--> Returns T normally; returns NIL if the primary
		selection is NULL, if the widget doesn't own the primary
		selection, or if unable to gain ownership of the clipboard
		selection.

	This method copies the primary selection to the clipboard.

	The optional <xevent> parameter is an XEVENT object from which
	the event-time is taken. Most often one would just pass in the
	value of callback symbol CALLBACK_XEVENT. If the <xevent> argument
	is missing, then 'CurrentTime' (Motif 1.0) or
	'XtLastTimestampProcessed()' (Motif 1.1) is used.
#endif /* MOTIF_1.1 */

#ifdef MOTIF_1.1

*** XmTextCut() // XmTextFieldCut() [Motif >= 1.1 only]:

	(send <text> :CUT [<xevent>])
		--> Returns T normally; returns NIL if the primary selection
		is NULL, if the widget doesn't own the primary selection, or if
		unable to gain ownership of the clipboard selection.

	This method copies the primary selected text to the clipboard and
	then deletes the primary selected text. Calling this method will
	also invoke the widget's XmNmodifyVerifyCallback and
	XmNvalueChangedCallback callbacks.

	The optional <xevent> parameter is an XEVENT object from which
	the event-time is taken. Most often one would just pass in the
	value of callback symbol CALLBACK_XEVENT. If the <xevent> argument
	is missing, then 'CurrentTime' (Motif 1.0) or
	'XtLastTimestampProcessed()' (Motif 1.1) is used.
#endif /* MOTIF_1.1 */

*** XmTextDisableRedisplay() [MOTIF_1.0, MOTIF_1.2] // _XmTextDisableRedisplay() [MOTIF_1.1]

	(send <text_widget> :DISABLE_REDISPLAY)
		--> returns <text_widget>

	This method is useful to call before making a series of updates
	to the text widget's string value. It prevents the changes from
	being displayed until message :ENABLE_REDISPLAY is received. 

	Note that in Motif 1.1, this function has changed its name to
	_XmTextDisableRedisplay(), and is not documented as being external
	because it is missing from Xm/Text.h. In Motif 1.2,
	XmTextDisableRedisplay() is officially supported...

	Note that this method is defined only on the XM_TEXT_WIDGET_CLASS,
	it doesn't exist for XM_TEXT_FIELD_WIDGET_CLASS.

*** XmTextEnableRedisplay() [MOTIF_1.0, MOTIF_1.2] // : _XmTextEnableRedisplay() [MOTIF_1.1]:

	(send <text_widget> :ENABLE_REDISPLAY)
		--> returns <text_widget>

	This method allows changes made to the text widget to be displayed
	after the text widget has received a message :DISABLE_REDISPLAY.

	Note that in Motif 1.1, this function has changed its name to
	_XmTextEnableRedisplay(), and is not documented as being external
	because it is missing from Xm/Text.h.  In Motif 1.2,
	XmTextEnableRedisplay() is officially supported...

	Note that this method is defined only on the XM_TEXT_WIDGET_CLASS,
	it doesn't exist for XM_TEXT_FIELD_WIDGET_CLASS.

#ifdef MOTIF_1.1

*** XmTextGetAddMode() // XmTextFieldGetAddMode() [Motif >= 1.1 only]:

	(send <text> :GET_ADD_MODE)
		--> Returns T if the text widget is in add mode, else NIL.

	See method :SET_ADD_MODE on <text> for details on add-mode.
#endif /* MOTIF_1.1 */

#ifdef MOTIF_1.1

*** XmTextGetBaseline() // XmTextFieldGetBaseline() [Motif >= 1.1 only]:

	(send <text> :GET_BASELINE)
		--> Returns a FIXNUM value that indicates the x position of
		the first baseline in the Text widget, relative to the x
		position of the top of the widget.  The calculation takes
		into account the margin height, shadow thickness, highlight
		thickness, and font ascent of the first font in the fontlist.
#endif /* MOTIF_1.1 */

#ifdef MOTIF_1.1

*** XmTextGetCursorPosition() // XmTextFieldGetCursorPosition() [Motif >= 1.1 only]:

	(send <text> :GET_CURSOR_POSITION)
		--> returns a FIXNUM, the position of the insert cursor
		as an index (0 based) into the text widget's string value.

	This method seems to be exactly the same as
	:GET_INSERTION_POSITION. I'm providing it for the sake of
	completeness, because I cannot possibly know whether this method
	will take on some special significance in some future version of Motif.
#endif /* MOTIF_1.1 */

*** XmTextGetEditable() // XmTextFieldGetEditable():

	(send <text> :GET_EDITABLE)
		--> returns T if editable, NIL otherwise. This is the
		same as the value of resource :XMN_EDITABLE.

*** XmTextGetInsertionPosition() // XmTextFieldGetInsertionPosition():

	(send <text> :GET_INSERTION_POSITION)
		--> returns a FIXNUM, the position of the insert cursor
		as an index (0 based) into the text widget's string value.

	This method returns the value of resource :XMN_TEXT_POSITION.

*** XmTextGetLastPosition() // XmTextFieldGetLastPosition():

	(send <text> :GET_LAST_POSITION)
		--> Returns a FIXNUM indicating the position of the last
		    character in the text buffer. This is an integer number
		    of characters from the beginning of the buffer.  The
		    first character position is 0.

	Note: this method will return an error if you are using Motif 1.0
	on a non-HPUX system. In Motif 1.0, the function corresponding to
	this method, XmTextGetLastPosition(), was not documented. On most
	Motif's it was still externally accessible (i.e. not defined as
	"static" in Xm/Text.c.). Since the functionality provided by the
	procedure seemed useful, I decided to interface it, even though it
	was undocumented. Unfortunately, a few bright vendors with nothing
	better to do decided to change the OSF/Motif 1.0 source so that the
	procedure is not accessible (declared the procedure "static")
	thereby causing compilation problems when porting WINTERP to other
	vendor's Motif 1.0.

	I know that the function exists in HP's Motif 1.0, but cannot know
	whether	other vendors will decide to make gratuitous changes to the
	Motif source. Therefore, for all Motif 1.0 non-HPUX systems,
	calling this method will signal an error. If you know your version
	of Motif 1.0 is	"pure", and you need this functionality, the
	changes you need to make in ./../src-server/wc_Text.c should be
	obvious. A better solution would be to use Motif 1.1.

	For Motif 1.1 this functionality is documented and defined, so
	don't worry about it.

*** XmTextGetMaxLength() // XmTextFieldGetMaxLength():

	(send <text> :GET_MAX_LENGTH)
		--> returns a FIXNUM, the maximum length of a text string
		entered into <text> from the keyboard.

*** XmTextGetSelection() // XmTextFieldGetSelection():

	(send <text> :GET_SELECTION)
		--> returns a string, the value of the primary selection;
		if no text is selected, an empty string is returned.

*** XmTextGetSelectionPosition() // XmTextFieldGetSelectionPosition():

	(send <text> :GET_SELECTION_POSITION)
		--> returns a "dotted pair" (<left_pos> . <right_pos>):
		Taking 'car' of this result returns <left_pos> which is a FIXNUM
		representing the position of the left side of the primary
		selection. Taking 'cdr' of the result returns <right_pos>
		which is a FIXNUM representing the position if the right side of
		the selection. Returns NIL if the widget doesn't own the
		primary selection.

	Note: this method will return an error if you are using Motif 1.0
	on a non-HPUX system. In Motif 1.0, the function corresponding to
	this method, XmTextGetSelectionPosition(), was not documented. On most
	Motif's it was still externally accessible (i.e. not defined as
	"static" in Xm/Text.c.). Since the functionality provided by the
	procedure seemed useful, I decided to interface it, even though it
	was undocumented. Unfortunately, a few bright vendors with nothing
	better to do decided to change the OSF/Motif 1.0 source so that the
	procedure is not accessible (declared the procedure "static")
	thereby causing compilation problems when porting WINTERP to other
	vendor's Motif 1.0.

	I know that the function exists in HP's Motif 1.0, but cannot know
	whether	other vendors will decide to make gratuitous changes to the
	Motif source. Therefore, for all Motif 1.0 non-HPUX systems,
	calling this method will signal an error. If you know your version
	of Motif 1.0 is	"pure", and you need this functionality, the
	changes you need to make in ./../src-server/wc_Text.c should be
	obvious. A better solution would be to use Motif 1.1.

	For Motif 1.1 this functionality is documented and defined, so
	don't worry about it.

*** XmTextGetSource():

	No interface to this method exists in the current version of WINTERP.

*** XmTextGetString() // XmTextFieldGetString():

	(send <text> :GET_STRING)
		--> returns the string presented/edited in the text edit widget.

*** XmTextGetTopCharacter():

	(send <text_widget> :GET_TOP_CHARACTER)
		---> returns a FIXNUM representing the number of characters
		from the beginning of the text buffer occuring before the
		first character being displayed in <text_widget>.

	This method returns the value of the :XMN_TOP_CHARACTER resource.

	Note that this method is defined only on the XM_TEXT_WIDGET_CLASS,
	it doesn't exist for XM_TEXT_FIELD_WIDGET_CLASS.

	[Note: the name XmTextGetTopPosition() was changed to
	XmTextGetTopCharacter() in Motif patch 1.01. People using WINTERP
	on HPUX 7.0 (which uses the unpatched Motif 1.0) should note
	this gratuitous name change in Motif.]	

#ifdef MOTIF_1.1

*** XmTextInsert() // XmTextFieldInsert() [Motif >= 1.1 only]:

	(send <text> :INSERT <position> <value>)
		--> Returns <text>.

	This method inserts a character string <value> into the text string
	in the Text widget.  The string is inserted after the character
	position specified by the FIXNUM <position>. The first position in
	the text widget is at zero.

	This routine also calls the widget's XmNmodifyVerifyCallback and
	XmNvalueChangedCallback callbacks.
#endif /* MOTIF_1.1 */

#ifdef MOTIF_1.1

*** XmTextPaste() // XmTextFieldPaste() [Motif >= 1.1 only]:

	(send <text> :PASTE)
		--> returns T normally; returns NIL if the primary
		selection is NULL or if the widget doesn't own the primary
		selection.

	This method inserts the clipboard selection at the destination
	cursor. If resource :XMN_PENDING_DELETE is True and the destination
	cursor is inside the current selection, the clipboard selection
	replaces the selected text.  Calling this method also invokes the
	widget's XmNmodifyVerifyCallback and XmNvalueChangedCallback callbacks.
#endif /* MOTIF_1.1 */

*** XmTextPosToXY() // XmTextFieldPosToXY():

	(send <text> :POS_TO_XY <position>)
		--> returns a "dotted pair" (<x> . <y>). Taking 'car' of the
		result returns <x>, a FIXNUM representing the pixel x position
		corresponding to <position>. 'cdr' of the result returns <y>,
		a FIXNUM representing the pixel y position corresponding to 
		<position>. Returns NIL if <position> is not displayed in
		the widget.

	The positions returned by this method are relative to the upper
	left corner of the widget. <position> is a FIXNUM representing the
	zero-based character index in <text>.

	Note: this method will return an error if you are using Motif 1.0
	on a non-HPUX system. In Motif 1.0, the function corresponding to
	this method, XmTextPosToXY(), was not documented. On most
	Motif's it was still externally accessible (i.e. not defined as
	"static" in Xm/Text.c.). Since the functionality provided by the
	procedure seemed useful, I decided to interface it, even though it
	was undocumented. Unfortunately, a few bright vendors with nothing
	better to do decided to change the OSF/Motif 1.0 source so that the
	procedure is not accessible (declared the procedure "static")
	thereby causing compilation problems when porting WINTERP to other
	vendor's Motif 1.0.

	I know that the function exists in HP's Motif 1.0, but cannot know
	whether	other vendors will decide to make gratuitous changes to the
	Motif source. Therefore, for all Motif 1.0 non-HPUX systems,
	calling this method will signal an error. If you know your version
	of Motif 1.0 is	"pure", and you need this functionality, the
	changes you need to make in ./../src-server/wc_Text.c should be
	obvious. A better solution would be to use Motif 1.1.

	For Motif 1.1 this functionality is documented and defined, so
	don't worry about it.

#ifdef MOTIF_1.1

*** XmTextRemove() // XmTextFieldRemove() [Motif >= 1.1 only]:

	(send <text> :REMOVE)
		--> Returns T normally; returns NIL if the primary
		selection is NULL or if the widget doesn't own the primary
		selection.

	This method deletes the primary selected text and calls the
	widget's XmNmodifyVerifyCallback and XmNvalueChangedCallback
	callbacks if there is a selection.
#endif /* MOTIF_1.1 */

*** XmTextReplace() // XmTextFieldReplace():

	(send <text> :REPLACE <from-pos> <to-pos> <string>)
		--> returns <text_widget>.

	This method replaces part of the text string displayed by
	<text> with <string> a STRING value.

	<from-pos> and <to-pos> are FIXNUMs which represent the indexes
	of the character segment to be replaced. If <from-pos>==<to-pos>
	the <string> is inserted after <from-pos>. The value 0 represents
	the first position in the text widget.	

	This method also calls the widget's XmNmodifyVerifyCallback
	and XmNvalueChangedCallback callbacks.

*** XmTextScroll():

	(send <text_widget> :SCROLL <n>)
		--> returns <text_widget>.

	This method will scroll the text displayed by the text widget
	up or down by <n> lines. If <n> is a positive FIXNUM, the text
	moves upward. If <n> is a negative FIXNUM, the text moves down. 

	Note that this method is defined only on the XM_TEXT_WIDGET_CLASS,
	it doesn't exist for XM_TEXT_FIELD_WIDGET_CLASS.

	Note: this method will return an error if you are using Motif 1.0
	on a non-HPUX system. In Motif 1.0, the function corresponding to
	this method, XmTextScroll(), was not documented. On most
	Motif's it was still externally accessible (i.e. not defined as
	"static" in Xm/Text.c.). Since the functionality provided by the
	procedure seemed useful, I decided to interface it, even though it
	was undocumented. Unfortunately, a few bright vendors with nothing
	better to do decided to change the OSF/Motif 1.0 source so that the
	procedure is not accessible (declared the procedure "static")
	thereby causing compilation problems when porting WINTERP to other
	vendor's Motif 1.0.

	I know that the function exists in HP's Motif 1.0, but cannot know
	whether	other vendors will decide to make gratuitous changes to the
	Motif source. Therefore, for all Motif 1.0 non-HPUX systems,
	calling this method will signal an error. If you know your version
	of Motif 1.0 is	"pure", and you need this functionality, the
	changes you need to make in ./../src-server/wc_Text.c should be
	obvious. A better solution would be to use Motif 1.1.

	For Motif 1.1 this functionality is documented and defined, so
	don't worry about it.

#ifdef MOTIF_1.1

*** XmTextSetAddMode() // XmTextFieldSetAddMode() [Motif >= 1.1 only]:

	(send <text> :SET_ADD_MODE <add-modeP>)
		--> returns <text>

	This method controls whether or not the Text widget is in Add Mode.
	When <add-modeP> is T, the widget is set to Add Mode and the
	insert cursor can be moved without disturbing the primary
	selection. Else the primary selection is disturbed by cursor movement.
#endif /* MOTIF_1.1 */

#ifdef MOTIF_1.1

*** XmTextSetCursorPosition() // XmTextFieldSetCursorPosition() [Motif >= 1.1 only]:

	(send <text> :SET_CURSOR_POSITION <position>)
		--> returns <text>

	This method seems to be exactly the same as :SET_INSERTION_POSITION.
	I'm providing it for the sake of completeness, because I cannot
	possibly know whether this method will take on some special
	significance in some future version of Motif.
#endif /* MOTIF_1.1 */

*** XmTextSetEditable() // XmTextFieldSetEditable():

	(send <text> :SET_EDITABLE <editableP>)
		--> returns <text>

	This method sets the edit permission of the <text>. If
	<editableP> is NIL, then keyboard input will not edit text,
	otherwise users may edit the text. This method sets the resource
	:XMN_EDITABLE.

#ifdef MOTIF_1.1

*** XmTextSetHighlight() // XmTextFieldSetHighlight() [Motif >= 1.1 only]:

	(send <text> :SET_HIGHLIGHT <leftpos> <rightpos> <highlightmode>)
		--> Returns <text>

	This method highlights text between the two specified character
	positions <leftpos> and <rightpos>.

	The <highlightmode> parameter determines the type of highlighting,
	e.g. :HIGHLIGHT_NORMAL, :HIGHLIGHT_SELECTED, and
	:HIGHLIGHT_SECONDARY_SELECTED.

	Note that highlighting text merely changes the visual appearance of
	the text; it does not set the selection.
#endif /* MOTIF_1.1 */

*** XmTextSetInsertionPosition() // XmTextFieldSetInsertionPosition():

	(send <text> :SET_INSERTION_POSITION <position>)
		--> returns <text>

	This method sets the insertion cursor position of the Text widget
	to index <position>, a FIXNUM. This routine also calls the widget's
	XmNmotionVerifyCallback callbacks if the insertion cursor position
	changes.

*** XmTextSetMaxLength() // XmTextFieldSetMaxLength():

	(send <text> :SET_MAX_LENGTH <max_length>)
		--> returns <text>

	This method sets the value of the current maximum allowable length
	of a text string entered from the keyboard to <max_length>, a FIXNUM.

	The maximum allowable length prevents the user from entering a
	text string from the keyboard that is larger than this limit.
	Strings that are entered using the :XMN_STRING resource or the
	:SET_STRING method ignore this resource.

*** XmTextSetSelection() // XmTextFieldSetSelection():

	(send <text> :SET_SELECTION <firstpos> <lastpos> [<xevent>])
		--> returns <text>.

	This method sets the primary selection in <text>. The selection
	is set between indexes <firstpos> and <lastpos>, both FIXNUMs. Calling
	this method will also set the insertion cursor position to <lastpos>
	and call the XmNmotionVerifyCallback callbacks.

	The optional <xevent> parameter is an XEVENT object from which
	the event-time is taken. Most often one would just pass in the
	value of callback symbol CALLBACK_XEVENT. If the <xevent> argument
	is missing, then 'CurrentTime' (Motif 1.0) or
	'XtLastTimestampProcessed()' (Motif 1.1) is used.

*** XmTextSetSource():

	No interface to this method exists in the current version of WINTERP.

*** XmTextSetString() // XmTextFieldSetString():

	(send <text> :SET_STRING <string>)
		--> returns <text_widget>

	This method sets the string value of the Text widget. This routine
	calls the widget's XmNmodifyVerifyCallback and XmNvalueChangedCallback
	callbacks.  It also sets the insertion cursor position to the beginning
	of the string and calls the widget's XmNmotionVerifyCallback callbacks.

*** XmTextSetTopCharacter():

	(send <text_widget> :SET_TOP_CHARACTER <top_position>)
		--> returns <text_widget>.
	
	This method sets the first character to be displayed by 
	<text_widget> to be the character whose index is the FIXNUM
	<top_position>. If resource :XMN_EDIT_MODE is set to :MULTI_LINE_EDIT,
	then the line of text that contains <top_position> is displayed at the
	top of the widget without shifting the text left or right.

	Note that this method is defined only on the XM_TEXT_WIDGET_CLASS,
	it doesn't exist for XM_TEXT_FIELD_WIDGET_CLASS.

	[Note: the name XmTextSetTopPosition() was changed to
	XmTextSetTopCharacter() in Motif patch 1.01. People using WINTERP
	on HPUX 7.0 (which includes the unpatched Motif 1.0) should note
	this gratuitous name change in Motif.]	

*** XmTextShowPosition() // XmTextFieldShowPosition():

	(send <text> :SHOW_POSITION <position>)
		--> returns <text_widget>

	This method forces the text at the specified FIXNUM index <position>
	to be displayed. If the resource :XMN_AUTO_SHOW_CURSOR_POSITION is
	set to 'T', the insert cursor is also set to <position>.
      #ifdef MOTIF_1.2
	The Motif 1.2 manual pages indicate a change in the semantics:
	"If :XMN_AUTO_SHOW_CURSOR_POSITION is 'T', the APPLICATION should
	also set the insert cursor to this position." (see method
	:SET_INSERTION_POSITION).
      #endif MOTIF_1.2


*** XmTextXYToPos() // XmTextFieldXYToPos():

	(send <text> :XY_TO_POS <x> <y>)
		--> returns a FIXNUM representing the character position
		nearest to the specified FIXNUM positions <x> and <y>.
		These positions are pixel coordinates relative to the upper
		left corner of the text widget.

	Note: this method will return an error if you are using Motif 1.0
	on a non-HPUX system. In Motif 1.0, the function corresponding to
	this method, XmTextXYToPos(), was not documented. On most
	Motif's it was still externally accessible (i.e. not defined as
	"static" in Xm/Text.c.). Since the functionality provided by the
	procedure seemed useful, I decided to interface it, even though it
	was undocumented. Unfortunately, a few bright vendors with nothing
	better to do decided to change the OSF/Motif 1.0 source so that the
	procedure is not accessible (declared the procedure "static")
	thereby causing compilation problems when porting WINTERP to other
	vendor's Motif 1.0.

	I know that the function exists in HP's Motif 1.0, but cannot know
	whether	other vendors will decide to make gratuitous changes to the
	Motif source. Therefore, for all Motif 1.0 non-HPUX systems,
	calling this method will signal an error. If you know your version
	of Motif 1.0 is	"pure", and you need this functionality, the
	changes you need to make in ./../src-server/wc_Text.c should be
	obvious. A better solution would be to use Motif 1.1.

	For Motif 1.1 this functionality is documented and defined, so
	don't worry about it.

______________________________________________________________________________

** XM_TOGGLE_BUTTON_WIDGET_CLASS / XM_TOGGLE_BUTTON_GADGET_CLASS

*** equivalent Xt 'WidgetClass':

	xmToggleButtonWidgetClass
	xmToggleButtonGadgetClass

*** equivalent creation convenience function:

	(send XM_TOGGLE_BUTTON_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateToggleButton()

	(send XM_TOGGLE_BUTTON_GADGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateToggleButtonGadget()

*** XtAddCallback():

	(send <togglebutton> :ADD_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ
	(send <togglebutton> :SET_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ

	These methods work just like the :ADD_CALLBACK/:SET_CALLBACK
	methods on WIDGET_CLASS except that these methods understand
	how to get call_data values from the XmToggleButtonCallbackStruct:
		typedef struct
		{
		   int reason;
		   XEvent * event;
		   int set;
		} XmToggleButtonCallbackStruct;

	Specifying one or more of the following symbols in the callback
	bindings list will bind that symbol's value in the lexical
	environment of the callback:
		CALLBACK_WIDGET -- the WIDGETOBJ of the callback
		CALLBACK_REASON -- the reason symbol for the callback
		CALLBACK_XEVENT -- the XEvent* that caused the callback
		CALLBACK_SET    -- T if the togglebutton causing the
				   callback is set, else NIL.

*** XmToggleButtonGetState() / XmToggleButtonGadgetGetState():

	(send <togglebutton> :GET_STATE)
		--> returns T if the toggle button is set, else NIL

*** XmToggleButtonSetState() / XmToggleButtonGadgetSetState():

	(send <togglebutton> :SET_STATE <state_p> <notify_p>)
		--> returns <togglebutton>.

	This method sets the state of the togglebutton to OFF if
	boolean <state_p> is NIL, else it set the state to ON

	<notify_p> -- if not NIL, :XMN_VALUE_CHANGED_CALLBACK gets called.

==============================================================================

#ifdef WINTERP_XTANGO_WIDGET
* WINTERP/Xtango Widget Class and Tango Image Classes

** Compilation option "-DWINTERP_XTANGO_WIDGET

	If WINTERP has been compiled with "-DWINTERP_XTANGO_WIDGET"
	then you have Xtango functionality built into WINTERP. To
	enable/disable this functionality, you may add/remove
	"-DWINTERP_XTANGO_WIDGET" via (1) changing the machine/os-appropriate
	makefile in <winterp-top-dir>/src-server/Makefile.*; or (2) make
	equivalent change to the Imakefile or its generated Makefile in
	that directory; or (3) edit <winterp-top-dir>/src-server/config.h...

	If you use methods (2) or (3) to add/delete WINTERP_XTANGO_WIDGET
	features, you must make sure to delete all the
	<winterp-top-dir>/src-server/*.o files, or at least delete the
	following: tic_*.o, wc_Xtango.o, wc_DropPockt.o, wc_XmGraph.o, 
	wc_Table.o, winterp.o, w_resources.o, w_funtab.o, w_callbacks.o...
	If you add/remove the feature by editing the appropriate
	<winterp-top-dir>/src-server/Makefile.* files, then the appropriate
	files will get remade automatically.

** Introduction to Stasko and Hayes' Xtango:

	XTANGO is a general purpose animation system that supports
	programmers developing color, real-time, 2 & 1/2 dimensional, smooth
	animations.  The focus of the system is on ease-of-use.  XTANGO
	utilizes the path-transition animation paradigm which helps move
	animation design to an abstract, high level.  Programmers need not be
	graphics experts to develop their own animations. The Xtango
	library used by WINTERP was developed by John T. Stasko
	(stasko@cc.gatech.edu) and Doug	Hayes at the Georgia Institute of
	Technology -- WINTERP uses a modified version of "xtangovararg"
	(version 1.52) -- the original is available via anonymous ftp from
	par.cc.gatech.edu:pub/xtangovarargs.tar.Z (130.207.119.254).

	The WINTERP interface to XTANGO further simplifies the
	creation of graphics and animation. It provides a new widget class
	TANGO:WIDGET_CLASS in which Tango animations may be displayed. Within
	the TANGO:WIDGET_CLASS instance, a set of TANGO:IMAGE_CLASS instances
	may be displayed and animated -- the images may be lines, rectangles,
	circles, ellipses, polylines, polygons, splines, bitmaps, GIFs, text,
	or a composite of the aforementioned types.  All Xtango images types
	other that text, bitmaps and GIFs are pixel independent, thereby
	simplifying scaling, zooming, and resizing of Xtango graphics.

	The WINTERP interface to XTANGO allows programmers to use the XLISP
	object system to create new images with new functionality and
	encapsulated animation capabilities by subclassing and/or composing the
	previously mentioned image types. Unlike Xtango, animations and
	graphics may be developed interactively in WINTERP. Furthermore,
	WINTERP's Xtango performs automatic memory management on all types
	associated with Xtango -- storeage associated with paths, transitions,
	images, and the tango widget is automatically deallocated
	when the data is no longer needed.

	For details on the Xtango system underlying WINTERP's interface to
	Xtango, see <winterp-top-dir>/doc/xtangodoc.tex (LaTeX format)
	and <winterp-top-dir>/doc/xtangodoc.ps.Z (compressed postscript).
	For a conceptual overview of Xtango, see
	<winterp-top-dir>/doc/xtango.ps.Z (compressed postscript).

** TANGO Colors (TANGO_COLOR):

	TANGO_COLOR is a FIXNUM representing a Pixel value specific to the
	Xtango package. One may also pass STRING values as TANGO_COLOR,
	typically, these are color names from /usr/lib/X11/rgb.txt, e.g.
	"red". One may also specify a hexadecimal value for the color, e.g.
	"#FF0000".

	The following constants represent predefined Xtango color values:
		TANGO_COLOR_WHITE
		TANGO_COLOR_YELLOW
		TANGO_COLOR_GREEN
		TANGO_COLOR_BLUE
		TANGO_COLOR_ORANGE
		TANGO_COLOR_RED
		TANGO_COLOR_MAROON
		TANGO_COLOR_BLACK

	See also <<TANGO:WIDGET_CLASS Method :LOAD_COLOR>> as a way to load
	colors into Xtango's colormap. If you are repeatedly using the same
	color, it is more efficient to use the TANGO_COLOR fixnum as returned
	by :LOAD_COLOR or the color constants listed above, rather than forcing
	a STRING to TANGO_COLOR conversion to be done multiple times.

	Note that the underlying Xtango library limits <tango_color> arguments
	to work only with the eight "basic" tango colors mentioned above.
	This limitation only applies to programmatically changing the colors
	of an image during an animation, e.g. through methods :TAP_COLOR and
	:TX_COLOR, and function TANGO:PATH_COLOR. <tango_color>
	arguments for image creation can use the full set of colors from 
	/usr/lib/X11/rgb.txt. If the specified color is not
	available, an error will be signalled during color allocation.

** TANGO Locations and Coordinates (TANGO_LOC):

	Locations in WINTERP's Xtango are represented as XLISP
	COMPLEX type data #C(<x> <y>), where <x> and <y> are FLONUMs
	representing the location within the TANGO:WIDGET_CLASS instance.
	Using COMPLEX data simplifies mathematical and geometric calculations
	because WINTERP's XLISP can do mathematical operations on
	COMPLEX numbers (+, -, *, /, SIN, COS, TAN, ASIN, ACOS, ATAN, EXPT,
	EXP, SQRT, etc).

	For an example of using COMPLEX domain calculations, see
	<winterp-top-dir>/examples/xtango/test-dial.lsp which
	defines a "dial widget" using XTANGO graphics, and employs
	COMPLEX domain calculations involving "cis" ==
	COS(x) + i*SIN(x) = EXP(i*x). In particular see
	DIAL-WIDGET-CLASS (<winterp-top-dir>/examples/xtango/wcls-dial.lsp)
	and POLAR-ARROW-IMAGE-CLASS
	(<winterp-top-dir>/examples/xtango/icls-plrar.lsp).

	Note that the coordinate system for XTANGO is the opposite of
	what you'd expect given the useage of COMPLEX domain coordinates --
	by default, the visible area of the TANGO:WIDGET_CLASS instance
	is represented by the following border coordinates:

		#C(0.0 0.0)     #C(1.0 0.0)
		      +---------------+
		      |               |
		      |               |
		      |               |
		      |               |
		      +---------------+		     
		#C(0.0 1.0)     #C(1.0 1.0)

	The coordinates bounding the viewing area can be changed by invoking
	methods :ZOOM, :PAN, or :SET_COORD. Method :INQ_COORD returns the 
	border coordinates.

** TANGO Paths (TANGO_PATH):

	A TANGO Path is a data type that identifies an animation path along
	which an image is modified.  A path can be thought of as a list of
	relative offsets, each relative to the previous position.

	Paths are applied to Xtango transition operations (methods :TX_* on
	TANGO:IMAGE_CLASS and subclasses); each element in a path is applied
	to the appropriate transition operator, becoming a single frame of
	animation when the transition is performed via TANGO:TX_PERFORM or via
	:PERFORM keyword supplied to a transition operation.

*** Function TANGO:PATH_CREATE (TANGOpath_create(), TANGOpath_null()):
	
	(TANGO:PATH_CREATE [<path>...])
		==> returns a TANGO_PATH node representing a path
		    (<x0,y0>...<xn,yn>)
	
	The [<path>...] argument is optional, and may be of multiple types:

	* if the <path> argument is omitted, then a path of length one with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
		example: (TANGO:PATH_CREATE)
					==> returns null path of length 1.

	* else, if <path> is of type FIXNUM, then a path of length <path> with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
		example: (TANGO:PATH_CREATE 2)
					==> returns null path of length 2.

	* else, if <path> is one or more COMPLEX (e.g. #C(<x> <y>) arguments
	  then a path element is created for each COMPLEX argument,
	  with the x and y offsets of each path element set to each
	  complex argument's <x> and <y> parts.
		example: (TANGO:PATH_CREATE #C(0.1 0.1) #C(0.1 0.1)
					    #C(0.1 0.1) #C(0.1 0.1))
				==> returns a path of length 4 w/
				    x and y offsets set to 0.1 .

	* else, if <path> is a a pair of sequences (LIST or ARRAY) of FLONUMS,
	  then a path of the same length as the sequences is created,
	  with the x and y offsets set to the corresponding <x> <y>.
		example: (TANGO:PATH_CREATE #'(0.1 0.1 0.1 0.1)
					    #'(0.1 0.1 0.1 0.1))
				==> returns a path of length 4 w/
				    x and y offsets set to 0.1 .

*** Function TANGO:PATH_LENGTH (TANGOpath_length()):

	(TANGO:PATH_LENGTH <path>)
		==> returns a FIXNUM representing length of <path>.
	
		<path> is a TANGO_PATH node, created (for example) by
		function TANGO:PATH_CREATE.
	
	This routine returns the numbers of offsets in the given path.

*** Function TANGO:PATH_DX (TANGOpath_dx()):

	(TANGO:PATH_DX <path>)
		==> returns a FLONUM representing the x distance traversed by
		    path.
	
		<path> is a TANGO_PATH node, created (for example) by
		function TANGO:PATH_CREATE.
	
	This routine returns the <x> distance that the given <path>
	traverses from start to finish.

*** Function TANGO:PATH_DY (TANGOpath_dy()):

	(TANGO:PATH_DY <path>)
		==> returns a FLONUM representing the y distance traversed
		    by path
	
		<path> is a TANGO_PATH node, created (for example) by
		function TANGO:PATH_CREATE.
	
	This routine returns the <y> distance that the given <path> traverses
	from start to finish.

*** Function TANGO:PATH_TYPE (TANGOpath_type()):

	(TANGO:PATH_TYPE <k_type>)
		==> returns a TANGO_PATH node.
	
	<k_type> is a keyword argument, one of
	      :STRAIGHT         -- move right
	      :CLOCKWISE        -- move clockwise right in an upward arc
	      :COUNTERCLOCKWISE -- move counterclockwise left in an upward arc
	
	Each of these paths when created will have 20 relative offset points
	and will change in <x> by a total value of 0.2 animation coordinate
	system units.
	
	The paths created by this routine will probably not be utilized as is,
	although there is no reason why they cannot be.  They are provided
	primarily as starting paths for use in the subsequent path modification
	routines.

*** Function TANGO:PATH_COLOR (TANGOpath_color()):

	(TANGO:PATH_COLOR <color>)
		==> returns a TANGO_PATH node.
	
	<color> is a FIXNUM ranging from 0-7 representing a Xtango pixel value.
	The following symbols have been predefined with Xtango pixel values:
			TANGO_COLOR_WHITE			0
			TANGO_COLOR_YELLOW			1
			TANGO_COLOR_GREEN			2
			TANGO_COLOR_BLUE			3
			TANGO_COLOR_ORANGE			4
			TANGO_COLOR_RED				5
			TANGO_COLOR_MAROON			6
			TANGO_COLOR_BLACK			7
		(Note that the underlying Xtango path-color primitives
		 do not allow other Xtango colors to be defined for
		 path operations).
	 
	This routine returns a one offset path that will change an image to
	the given color when the path is used as an argument to tango-image
	method :TX_COLOR.  The direction of the offset in the path determines
	the color to utilize.  For example, if there is an image
	'red_door_image' that you wish to be painted black, you could call
	   (send red_door_image :TX_COLOR (TANGO:PATH_COLOR TANGO_COLOR_BLACK))
	
	For the above usage, you could also avoid calling TANGO:PATH_COLOR
	entirely by using method :TAP_COLOR, e.g.
	   (send red_door_image :TAP_COLOR TANGO_COLOR_BLACK).
	Note that colors created with TANGO:WIDGET_CLASS method :LOAD_COLOR
	cannot be used as parameters to this function. The supported colors are
	TANGO_COLOR_WHITE thru TANGO_COLOR_BLACK.

*** Function TANGO:PATH_ADD_TAIL (TANGOpath_add_tail()):

	(TANGO:PATH_ADD_TAIL <path> <num>)
		==> returns a TANGO_PATH node.
	
	<path> is a TANGO_PATH as returned by other TANGO:PATH_* routines.
	<num> is a positive FIXNUM, if <=0, the value 0 is used.
	
	This routine elongates a path by extending the "tail" of the path.
	The parameter <num> designates the number of null #C(0.0 0.0) offsets
	that will be apppended to the given <path>, producing a new path that
	is returned.

*** Function TANGO:PATH_ADD_HEAD (TANGOpath_add_head()):

	(TANGO:PATH_ADD_HEAD <path> <num>)
		==> returns a TANGO_PATH node.
	
	<path> is a TANGO_PATH as returned by other TANGO:PATH_* routines.
	<num> is a positive FIXNUM, if <=0, the value 0 is used.
	
	This routine elongates a path by extending the "head" of the path.
	The parameter <num> designates the number of null #C(0.0 0.0) offsets
	that will be prepended to the given <path>, producing a new path that
	is returned.

*** Function TANGO:PATH_DELETE_TAIL (TANGOpath_delete_tail()):

	(TANGO:PATH_DELETE_TAIL <path> <num>)
		==> returns a TANGO_PATH node.
	
	<path> is a TANGO_PATH as returned by other TANGO:PATH_* routines.
	<num> is a positive FIXNUM, if <=0, the value 0 is used.
	
	This routine provides a way of shortening a path.  The parameter <num>
	designates the number of offsets that will be removed from tail of the
	given <path> in order to produce a new path that is returned.

*** Function TANGO:PATH_DELETE_HEAD (TANGOpath_delete_head()):

	(TANGO:PATH_DELETE_HEAD <path> <num>)
		==> returns a TANGO_PATH node.
	
	<path> is a TANGO_PATH as returned by other TANGO:PATH_* routines.
	<num> is a positive FIXNUM, if <=0, the value 0 is used.
	
	This routine provides a way of shortening a path.  The parameter
	<num> designates the number of offsets that will be removed from head
	of the given <path> in order to produce a new path that is returned.

*** Function TANGO:PATH_REVERSE (TANGOpath_reverse()):

	(TANGO:PATH_REVERSE <path>)
		==> returns a TANGO_PATH node.
	
	<path> is a TANGO_PATH as returned by other TANGO:PATH_* routines.
	
	This routine returns a path that is the inverse of the given <path>.
	Being an inverse path means that the order of offsets is reversed,
	and each offset points in the exact opposite direction.  This routine
	provides a way for an image to retrace its tracks from a movement
	transition.

*** Function TANGO:PATH_ROTATE (TANGOpath_rotate()):

	(TANGO:PATH_ROTATE <path> <deg>)
		==> returns a TANGO_PATH node.
	
	<path> is a TANGO_PATH as returned by other TANGO:PATH_* routines.
	<deg> is a positive FIXNUM, ranging from 0 to 360 (degrees).
	
	This routine returns a path that corresponds to the rotation of the
	given <path> in a counter-clockwise motion.  The number of degrees to
	rotate is provided by the FIXNUM integer parameter <deg> which should
	be between 0 and 360.

*** Function TANGO:PATH_INTERPOLATE (TANGOpath_interpolate()):

	(TANGO:PATH_INTERPOLATE <path> <factor>)
		==> returns a TANGO_PATH node.
	
	<path> is a TANGO_PATH as returned by other TANGO:PATH_* routines.
	<factor> is a FLONUM
	
	This routine returns a path in which the number of offsets is modified
	by a factor given by the <factor> parameter.  If a path with length 10
	is interpolated with a factor of 2.0, the returned path will have 20
	offsets. If the factor is 0.3, the path will have 3 offsets.  Straight
	linear interpolation is used.  Consequently, when interpolating a path
	with choppy, wavy motion characteristics, individual extrema may be
	lost with certain <factor> parameters.

*** Function TANGO:PATH_SCALE (TANGOpath_scale()):

	(TANGO:PATH_SCALE <path> <scale>)
		==> returns a TANGO_PATH node.
	
	<path> is a TANGO_PATH as returned by other TANGO:PATH_* routines.
	<scale> is a COMPLEX number #C(<dx> <dy>) where <dx> <dy> are FLONUMs.
	
	This routine returns a path in which each offset is scaled by the
	given factors in X and Y.  That is, each offsets' X and Y values are
	mulitplied by the respective <dx> and <dy> factors specified in the
	COMPLEX <scale> argument. So, for example, to return a path that
	would be the reflection of a path across an imaginary vertical line,
	<scale> == #C(-1.0 1.0).

*** Function TANGO:PATH_EXTEND (TANGOpath_extend()):

	(TANGO:PATH_EXTEND <path> <extension>)
		==> returns a TANGO_PATH node.
	
	<path> is a TANGO_PATH as returned by other TANGO:PATH_* routines.
	<extension> is a COMPLEX number #C(<dx> <dy>) where <dx> <dy>
		 are FLONUMs.
	
	This routine returns a path in which each offset is extended by the
	given factors in X and Y.  That is, each offsets' X and Y values have
	the respective <dx> and <dy> factors (specified in the COMPLEX
	<extension>) added to them.

*** Function TANGO:PATH_COPY (TANGOpath_copy()):

	(TANGO:PATH_COPY <path>)
		==> returns a TANGO_PATH node.
	
	<path> is a TANGO_PATH as returned by other TANGO:PATH_* routines.
	
	This routine returns a new path that has an exact duplicate list of
	offsets as the given <path>.

*** Function TANGO:PATH_ITERATE (TANGOpath_iterate()):

	(TANGO:PATH_ITERATE <path> <factor>)
		==> returns a TANGO_PATH node.
	
	<path> is a TANGO_PATH as returned by other TANGO:PATH_* routines.
	<factor> is a FLONUM
	
	This routine returns a path which is an iteration of a given <path>.
	The <factor> FLONUM parameter provides how many times the given path
	should be repeated in the path to be created.

*** Function TANGO:PATH_CONCATENATE (TANGOpath_concatenate()):

	(TANGO:PATH_CONCATENATE <path-0> <path-1> <path-2> ...)
		==> returns a TANGO_PATH node.
	
	<path-i> is a TANGO_PATH as returned by other TANGO:PATH_* routines.
	
	This routine creates a path which is the concatenation of some number
	of other paths.  The paths will be concatenated in order from the
	<path-0> position on to the last <path-n> position. The first offset
	of a path is relative to the last offset of the previous path.

*** Function TANGO:PATH_COMPOSE (TANGOpath_compose()):

	(TANGO:PATH_COMPOSE <path-0> <path-1> <path-2> ...)
		==> returns a TANGO_PATH node.
	
	<path-i> is a TANGO_PATH as returned by other TANGO:PATH_* routines.
	
	This routine returns a path which is the composition of the paths
	given in the <path-0> to <path-n> parameters.  By composition, we
	mean a cumulative combination on an offset by offset basis. If a path
	is thought of as a vector, the composition of paths produces a new
	vector that has the same length as the originals and is like the
	vector sum of the original path vectors.  Only paths with an equal
	number of offsets can be composed.  Otherwise, an error is signalled.
	
	Essentially, path composition takes all the first relative <x> <y>
	offsets and adds them together to make a new cumulative first <x>,<y>
	offset. This is done for each offset in the paths.

*** Function TANGO:PATH_DISTANCE (TANGOpath_distance()):

	 (TANGO:PATH_DISTANCE <from_loc> <to_loc> <distance>)
	 	==> returns a TANGO_PATH node.
	 
	 <from_loc> is a COMPLEX number #C(<from_x> <from_y>), 
	 	where <from_x>, <from_y> are FLONUMs.
	 <to_loc> is a COMPLEX number #C(<to_x> <to_y>),
	 	 where <to_x>, <to_y> are FLONUMs.
	 <distance> is a FLONUM.
	 
	 This routine returns a path that proceeds in a straight line from the
	 given <from_loc> to the given <to_loc> with the condition that the
	 path will have an offset every time the given <distance> has been
	 covered.  If the given distance is larger than the distance between
	 the <from_loc> and <to_loc>, the path is only given one offset.  This
	 routine is useful to create paths that will make images move at the
	 same velocity.

*** Function TANGO:PATH_EXAMPLE (TANGOpath_example()):

	(TANGO:PATH_EXAMPLE <from_loc> <to_loc> <path>)
		==> returns a TANGO_PATH node.
	
	<from_loc> is a COMPLEX number #C(<from_x> <from_y>), 
		where <from_x>, <from_y> are FLONUMs.
	<to_loc> is a COMPLEX number #C(<to_x> <to_y>),
		 where <to_x>, <to_y> are FLONUMs.
	<path> is a TANGO_PATH as returned by other TANGO:PATH_* routines.
	
	This routine returns a path which "looks like" the given example
	<path>, but which would move from the logical <from_loc> to the
	logical <to_loc>.  The created path will have the same number of
	offsets as the given path.  The general flow of movement in the
	example path is followed as closely as possible by maintaining the
	same ratios between control points in both paths. Clearly, however,
	if the two paths move in opposite directions, they will not look much
	alike.  Typically, this routine will be used when one wants an image
	to end up in some specific position, with the image following some
	rough, given trajectory path in order to get there.

*** Function TANGO:PATH_MOTION (TANGOpath_motion()):

	 (TANGO:PATH_MOTION <from_loc> <to_loc> <path_type>)
	 	==> returns a TANGO_PATH node.
	 
	 <from_loc> is a COMPLEX number #C(<from_x> <from_y>), 
	 	where <from_x>, <from_y> are FLONUMs.
	 <to_loc> is a COMPLEX number #C(<to_x> <to_y>),
	 	 where <to_x>, <to_y> are FLONUMs.
	 <path_type> is a keyword, either :STRAIGHT,
	 	:CLOCKWISE, or :COUNTERCLOCKWISE.
	 
	 This routine returns a path with movement characteristics of the
	 given <path_type>, but that also begins at the location with logical
	 X and Y coordinates of <from_loc> and proceeds to the location with
	 logical X and Y coordinates of the <to_loc>.  Note that the provided
	 from and to locations need not have absolute screen coordinate
	 meaning.  Because a path is made up of a group of relative offsets,
	 these locations are provided just as necessary aids in the path
	 creation.  For example, the same path will be created using from ==
	 #C(0.2 0.2) and to == #C(0.4 0.4) as using from == #C(0.7 0.7) and to
	 == #C(0.9 0.9). Most often however, the provided locations will be
	 specific window coordinates chosen to move a certain image to a
	 specific location.
	 
	 The created path will contain 20 offsets and will be modelled to fit
	 the given <path_type>, which may be one of the following keywords
	 :STRAIGHT, :CLOCKWISE, or :COUNTERCLOCKWISE.  The straight option
	 creates a path that is a direct line from {\em fromloc} to {\em
	 toloc} with equally spaced offsets.  The two clock motions will
	 create a path that curves in the given clock motion direction.
	 
	 Essentially, this routine is just
	 (TANGO:PATH_EXAMPLE <from_loc> <to_loc>
			     (TANGO:PATH_TYPE <path_type>)).

*** Function TANGO:PATH_SMOOTH (TANGOpath_smooth()):

	(TANGO:PATH_SMOOTH <path>)
		==> returns a TANGO_PATH node.
	
	<path> is a TANGO_PATH as returned by other TANGO:PATH_* routines.
	
	
	This routine returns a path which is a "smoother" version of the
	given <path>.  Essentially, each offsets' value is determined by
	averaging in the neighboring offsets' values. Currently, we use 2
	times the designated offset plus one time the previous and subsequent
	offsets.

*** Function TANGO:PATH_FREE (TANGOpath_free()):

	 (TANGO:PATH_FREE <path>)
	 	==> returns NIL
	 
	 <path> is a TANGO_PATH as returned by other TANGO:PATH_* routines.
	 
	 This routine frees the memory space occupied by the TANGO_PATH arg
	 <path>.
	 
	 Note that WINTERP automatically frees any TANGO_PATH node which is no
	 longer referenced. If you happen to store a TANGO_PATH on a global
	 variable, or within a closure (on function, method, lambda, etc) it
	 will not get garbage collected, so you may want to use this function
	 to explicitly free it.
	 
	 If very long paths are being created, but garbage collections are
	 happening infrequently, the process size will grow larger than it
	 needs to be because memory taken up by TANGO_PATH's will not be able
	 to be reused until a garbage collection occurs.
	 
	 Calling TANGO:PATH_FREE frees the Xtango storage used by
	 <path>. Subsequent references of the node passed to this function via
	 <path> will signal an error indicating that the path has been
	 freed. This might happen, for example, when you use the <path> as an
	 argument to a :TX_* TANGO_IMAGE_CLASS method.

** TANGO Transitions (TANGO_TRANS):

	A transition is a data-type representing a graphics action to be 
	performed on a Tango Image object. A transition action is comprised of
	1) the actual type of the transition such as fill style change,
	   visibility change, color change, motion, resizing, and so forth, or
	   some combination thereof;
	2) the image to which it applies, and
	3) A path along which to apply the transition. A sequence of
	   values, each element of which becomes a single frame of animation.

	The TANGO_TRANS type is returned by the following methods on
	TANGO:IMAGE_CLASS (and subclasses thereof) when they are called
	without the :PERFORM keyword: :TX_MOVE, :TX_VISIBLE, :TX_COLOR, 
	:TX_RAISE, :TX_LOWER, :TX_DELAY, :TX_REFRESH, :TX_DELETE, :TX_ZOOM,
	:TX_FILL, :TX_RESIZE, :TX_RESIZE1... :TX_RESIZE7, :TX_GRAB1...
	:TX_GRAB7, and :TX_SHUFFLE. See below for details on the transition
	methods and the particular subclasses of TANGO:IMAGE_CLASS to which
	they apply.

	The results of the methods returning TANGO_TRANS can be operated on by
	a variety of functions:

*** Function TANGO:TX_ITERATE (TANGOtrans_iterate()):

	(TANGO:TX_ITERATE [:PERFORM] <tango_trans> <num-iterations>)
		==> returns <tango_trans> object, or NIL if :PERFORM keyword
		    given.
	
	This routine returns a transition which corresponds to performing the
	given <tango_trans> <num> times, one immediately after the other.
	One example use of this routine is to make an image repeat a given
	behavior.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	The <tango_trans> argument is of type TANGO_TRANS, which is produced
	by one of the :TX_* methods on TANGO:IMAGE_CLASS and its subclasses.
	
	The <num-iterations> argument is a FIXNUM representing the number of
	times to iterate..

*** Function TANGO:TX_CONCATENATE (TANGOtrans_concatenate()):

	(TANGO:TX_CONCATENATE [:PERFORM] <trans-1>
					[<trans-2> [<trans-3> [...]]])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.
	
	This routine returns a transition which corresponds to the
	concatenation of the transitions in the <trans-i> parameters. The
	order of the incoming transitions corresponds to the order that they
	will be performed in the concatenation, with transition <trans-1>
	being first.  This one logical transition can then be composed,
	iterated, etc., with other transitions to achieve various desired
	animations.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	Each <trans-i> argument is of type TANGO_TRANS, which is produced by
	one of the :TX_* methods on TANGO:IMAGE_CLASS and its subclasses.

*** Function TANGO:TX_COMPOSE (TANGOtrans_compose()):

	(TANGO:TX_COMPOSE [:PERFORM] <trans-1> [<trans-2> [<trans-3> [...]]])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.
	
	This routine is very important because it provides the ability to
	have many images moving and changing around the screen at the same
	time. It returns a transition which is the composition of the
	<trans-i> arguments. By composition, we mean the "concurrent"
	execution of all the transitions involved.  When transitions are
	composed, individual frames of the transition are combined, e.g., the
	first frames, the second frames, etc.  For transitions, each offset
	in the path utilized corresponds to one frame.  Transitions of
	unequal "length" can be composed.  Transitions shorter than the
	longest transition will simply have null action frames added to their
	tails.  Consequently, all the action will start together but will
	finish according to how many frames are in the transition. Note: to
	compose more than 50 transitions, you need to call this routine twice
	with the result of the first call as a parameter to the second call.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	Each <trans-i> argument is of type TANGO_TRANS, which is produced by
	one of the :TX_* methods on TANGO:IMAGE_CLASS and its subclasses.

*** Function TANGO:TX_PERFORM (TANGOtrans_perform()):

	(TANGO:TX_PERFORM <tango_trans>)
		==> returns NIL
	
	TANGO:TX_PERFORM actually carries out the given transition which has
	been created via one of the transition creation routines (:TX_*
	methods).  All the involved graphical images are animated in the ways
	specified in the transition when it was created.
	
	The <tango_trans> argument is of type TANGO_TRANS, which is produced
	by one of the :TX_* methods on TANGO:IMAGE_CLASS and its subclasses.
	
	Note that simple transitions may be achieved via the :PERFORM keyword
	on the TANGO:IMAGE_CLASS :TX_* methods -- the :PERFORM keyword allows
	:TX_* method to directly invoke the functionality of
	TANGO:TX_PERFORM.  More complex transitions require calls to
	TANGO:TX_PERFORM; these transitions are stored in the user's program
	and performed later; alternately the transitions may be the result of
	functions like TANGO:TX_ITERATE, TANGO:TX_CONCATENATE,
	TANGO:TX_COMPOSE.

*** Function TANGO:TX_FREE (TANGOtrans_free()):

	(TANGO:TX_FREE <tango_trans>)
		==> returns NIL.
	
	This routine frees the space associated with <tango_trans>. Calling
	this routine is not absolutely necessary, since WINTERP's garbage
	collector will automatically free up any TANGO_TRANS data. However,
	if you are creating many transitions which are briefly used, then
	discarded, you may be able to prevent un-necessary memory-size growth
	by explicitly freeing TANGO_TRANS objects -- in the worst case, where
	the only "garbage" being generated is TANGO_TRANS objects, you may
	end up allocating 2000 (default) nodes before any of the space gets
	freed by the garbage collector. The XLISP ALLOC function allows the
	2000 default to be changed.
	
	The <tango_trans> argument is of type TANGO_TRANS, which is produced
	by one of the :TX_* methods on TANGO:IMAGE_CLASS and its subclasses.

** TANGO:WIDGET_CLASS -- the Xtango 2-D animation/graphics widget

*** equivalent Xt 'WidgetClass':

	xmDrawingAreaWidgetClass --

	TANGO:WIDGET_CLASS is a Motif XmDrawingArea widget subclass which
	interfaces to Stasko&Hayes' XTANGO 2-D Animation Package
	(xtangovararg, VERSION 1.52). All resources, callbacks, and behavior
	of this widget are documented in XmDrawingArea(3x).

	xmDrawnButtonWidgetClass --

	If the widget is created with the optional :BUTTON argument,
	then then Xtango functionality will be available
	in a Motif XmDrawnButton subclass. All resources, callbacks, and
	 behavior of this widget are documented in XmDrawnButton(3x).

*** TANGO:WIDGET_CLASS Method :NEW/:ISNEW (XtCreateWidget()):

	(send TANGO:WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> XtCreateWidget(... xmDrawingAreaWidgetClass ...)

	(send TANGO:WIDGET_CLASS :new [:managed/:unmanaged] :BUTTON ...)
		--> XtCreateWidget(... xmDrawnButtonWidgetClass ...)

	See WIDGET_CLASS :NEW method for information on the standard
	widget creation parameters depicted by "..." above.
	
	The optional :BUTTON argument causes the Xtango drawing area
	semantics to be included in a Motif XmDrawnButton widget.
	This is useful for pushbuttons, menu entries, etc in which
	you want to have graphics and/or animations appear.

*** TANGO:WIDGET_CLASS Method :ADD_CALLBACK/:SET_CALLBACK (XtAddCallback()):

	(send <tangowidget> :ADD_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ
	(send <tangowidget> :SET_CALLBACK ...)
		--> returns: <callback_id_object> of type CALLBACKOBJ

	These methods work just like the :ADD_CALLBACK/:SET_CALLBACK
	methods on WIDGET_CLASS except that this method knows
	how to get call_data values from the XmDrawingAreaCallbackStruct:

		typedef struct
		{
			int     reason;
			XEvent  *event;
			Window  window;
		} XmDrawingAreaCallbackStruct;

	or, if created with the :BUTTON submessage,
	XmDrawnButtonCallbackStruct:

		typedef struct
		{
		    int     reason;
		    XEvent  *event;
		    Window  window;
		#ifdef MOTIF_1.1
		    int	    click_count;  /* FIELD EXISTS ONLY IN MOTIF 1.1 */
		#endif MOTIF_1.1
		} XmDrawnButtonCallbackStruct;

	If the <tangowidget> was created without the :BUTTON submessage,
	the following symbols are valid for the callback
	bindings list; When the callback fires, it will bind that symbol's
	value in the lexical environment of the callback:
		CALLBACK_WIDGET -- the WIDGETOBJ of the callback
		CALLBACK_REASON -- the reason symbol for the callback
		CALLBACK_XEVENT -- the XEvent* that caused the callback
		CALLBACK_WINDOW -- the Window of the callback

	If the <tangowidget. was created with the :BUTTON submessage, then
	the following callback symbols are valid:
		CALLBACK_WIDGET -- the WIDGETOBJ of the callback
		CALLBACK_REASON -- the reason symbol for the callback
		CALLBACK_XEVENT -- the XEvent* that caused the callback
		CALLBACK_WINDOW -- the Window of the callback
	   #ifdef MOTIF_1.1
		CALLBACK_CLICK_COUNT -- a FIXNUM representing the number of
					clicks upon the button. The click count
					will only be > 1 when resource 
					:XMN_MULTI_CLICK == :MULTICLICK_KEEP
	   #endif /* MOTIF_1.1 */

*** TANGO:WIDGET_CLASS Method :BEGIN_DRAWING (animate_begin()):

	(send <tango-widget> :BEGIN_DRAWING)
		==> returns NIL.

	You must call this routine prior to doing any drawing in a
	TANGO:WIDGET_CLASS instance, but after the widget's windows have
	been created. Typically, one should call this on the first expose
	event received by the widget -- use an :XMN_EXPOSE_CALLBACK.

	XTANGO-WIDGET-CLASS, and XTANGO-BUTTON-WIDGET-CLASS are subclasses
	of TANGO:WIDGET_CLASS which automatically call this method in an
	:XMN_EXPOSE_CALLBACK. To get those subclasses, do:
		(require "xtango/cls-widget")
		(require "xtango/cls-image")

*** TANGO:WIDGET_CLASS Method :PAN :

	(send <tango-widget> :PAN <direction> [<pan-amount-flonum>])
		==> returns NIL.
	
	<direction> can be one of
		:UP	-- pans the xtango view-window up.
		:DOWN	-- pans the xtango view-window down.
		:LEFT	-- pans the xtango view-window left.
		:RIGHT	-- pans the xtango view-window right.
	
	<pan-amount-flonum> is an optional flonum indicating amount to
		pan the viewer. If ommitted, it defaults to 0.2.

	This method pans the viewing area such that the top/left corner
	of the viewing area is no longer #C(0.0 0.0) and the bottom/right
	corner is no longer located at #C(1.0 1.0).

	To reset the viewing area back to the default, call:
		(send <tango-wdiget> :SET_COORD 0.0 1.0 1.0 0.0)
	The current coordinates associated with the viewing area may be
	retrieved via
		(send <tango-wdiget> :INQ_COORD)

*** TANGO:WIDGET_CLASS Method :ZOOM :

	(send <tango-widget> :ZOOM <direction> [<zoom-amount-flonum>])
		==> returns NIL.
	
	<direction> can be one of
		:IN	-- zoom in
		:OUT	-- zoom out
	
	<zoom-amount-flonum> is an optional FLONUM indicating amount to
		zoom the viewer. If ommitted, it defaults to 0.8

	This method zooms the viewing area in or out, causing the images
	displayed within to change in size. Note that the current version
	of WINTERP/Xtango has a bug -- bitmap, text, and gif images don't
	resize upon zooming. After zooming, the top/left corner	of the viewing
	area is no longer #C(0.0 0.0) and the bottom/right corner is no longer
	located at #C(1.0 1.0).

	To reset the viewing area back to the default, call:
		(send <tango-wdiget> :SET_COORD 0.0 1.0 1.0 0.0)
	The current coordinates associated with the viewing area may be
	retrieved via
		(send <tango-wdiget> :INQ_COORD)

*** TANGO:WIDGET_CLASS Method :SET_COORD (TANGOset_coord()):

	(send <tango-widget> :SET_COORD <lx> <by> <rx> <ty>)
		==> returns NIL.
	
		where:	<lx> - left x coord (flonum)	(default, 0.0)
			<by> - bottom y coord (flonum)	(default, 1.0)
			<rx> - right x coord (flonum)   (default, 1.0)
			<ty> - top y coord (flonum)	(default, 0.0)

	This method is used to manually set the window boundary coordinates
	which start by default at 0.0 to 1.0 in both directions (origin is at
	upper left corner).  This routine then allows you to zoom or pan the
	display from with an animation file.  It is advisable to maintain the
	same aspect ratio between <x> and <y> or weird things may happen.  A
	sequence of calls to this routine with gradually tightening window
	coordinates will provide a very nice smooth zooming functionality.

*** TANGO:WIDGET_CLASS Method :INQ_COORD (TANGOinq_coord()):

	(send <tango-widget> :INQ_COORD)
		==> returns list of FLONUMs (<lx> <by> <rx> <ty>) 
		(this data can subsequently be APPLY'd to :SET_COORD)

	This routine returns the current value of the window's boundary
	coordinates. 

*** TANGO:WIDGET_CLASS Method :SET_ANIMATION_EVENT_PROCESSING :

	(send <tango-widget> :SET_ANIMATION_EVENT_PROCESSING <event_mask>)
		--> returns NIL.

	<event_mask> is a FIXNUM, created by taking the LOGIOR of
	KEY_PRESS_MASK BUTTON_PRESS_MASK, and EXPOSURE_MASK. Any other mask
	values (as used perhaps by :ADD_EVENT_HANDLER/:SET_EVENT_HANDLER
	methods) are ignored.
	
		KEY_PRESS_MASK:	   interrupts running animation when Control-C
				   entered in the window running the animation.
		BUTTON_PRESS_MASK  interrupts running animation when any mouse
				   button is clicked within the window running
				   the animation.
		EXPOSURE_MASK:     if the window running the animation is
				   obscured then exposed, LOGIORing this value
				   to the event mask will cause the entire
				   window to refresh its graphics. When not
				   set, animation windows will not completely
				   refresh themselves until the current
				   animation's transition has finished.

	NOTE: By default, all TANGO:WIDGET_CLASS instances are created with
	 the following setting:
		(send <tango-widget> :SET_ANIMATION_EVENT_PROCESSING 
			             (logior KEY_PRESS_MASK EXPOSURE_MASK))

*** TANGO:WIDGET_CLASS Method :SET_DELAY :

	(send <tango-widget> :SET_DELAY <sleep_usecs_fixnum>)
		==> returns NIL.

	This method slows down an animation if it is running too fast on
	your host/display. <sleep_usecs_fixnum> is a FIXNUM representing
	the number of miscroseconds to sleep between frames of the
	animation. If the value is 0, then no delay occurs between
	frames of animation. The default value is 0.

*** TANGO:WIDGET_CLASS Method :SET_DEBUG :

	(send <tango-widget> :SET_DEBUG <debug_p>)
		==> returns NIL.
	
	When <debug_p> is non-NIL, this method turns on Xtango's internal
	debugging output -- prints out names of Xtango functions being called
	during the course of an animation. The output is sent to *TRACE-OUTPUT*
	which defaults to *TERMINAL-IO* unless redirected.

*** TANGO:WIDGET_CLASS Method :MONO_PATTERN_REPRESENTATION :

	(send <tango-widget> :MONO_PATTERN_REPRESENTATION <kind>)
		--> returns NIL if <tango-widget> is on a color screen, and
		    doesn't make any changes.
		--> returns T if <tango-widget> is on a monochrome screen,
	
	where <kind> can be
		:COLORS	-- patterns represent colors on mono displays.
		:FILLS	-- patterns represent fill-styles on mono displays.

*** TANGO:WIDGET_CLASS Method :REFRESH (TANGO_refresh()):

	(send <tango-widget> :REFRESH)
		==> returns NIL.

	This method redraws all the tango images visible in <tango-widget>.
	Typically, one calls :REFRESH from an :XMN_EXPOSE_CALLBACK on
	<tango-widget>. One might also call :REFRESH to force the next frame
	of animation to be displayed thereby displaying any images or
	transitions that have not yet been displayed via a call to TANGO_IMAGE
	method :TAP_SHOW...

*** TANGO:WIDGET_CLASS Method :INPUT_COORD (TANGOinput_coord()):

	(send <tango-widget> :INPUT_COORD)
		==> on success, returns a COMPLEX FLONUM number #C(<x> <y>).
		==> on failure, returns NIL.

	This method prompts the user to select a coordinate from the animation
	window.  If a successful choice is made, the routine returns
	#C(<x> <y>). If for some reason the selection was not successful
	(e.g., the mouse selection was made outside <tango-widget>), the
	routine returns NIL.

*** TANGO:WIDGET_CLASS Method :INPUT_IMAGE (TANGOinput_image()):

	(send <tango-widget> :INPUT_IMAGE)
		==> returns <tango_image> on success, NIL on failure

	This routine prompts the user to select an image from <tango-widget>.
	The user clicks down the mouse and this routine returns the uppermost
	visible image object whose bounding box (with a little padding, hence
	you can select vertical and horizontal lines) encloses the point of
	the mouse selection. If a successful image choice is made, the
	routine returns the TANGOIMAGEOBJ. If no image was selected, the
	routine returns NIL.  Be careful with lines; they often have big
	bounding boxes.  The :TX_RAISE and :TX_LOWER transitions are often
	useful aids for inputting images.

*** TANGO:WIDGET_CLASS Method :GET_EVENT_IMAGE (TANGOget_event_image()):

	(send <tango-widget> :GET_EVENT_IMAGE <xevent>)
		==> returns <tango_image> on success, NIL on failure

	<xevent> is typically taken from the CALLBACK_XEVENT or
	EVHANDLER_XEVENT values set within widget-class methods
	:SET_CALLBACK/:ADD_CALLBACK or :SET_EVHANDLER/:ADD_EVHANDLER.
	<xevent> is used to determine the x,y location of a KeyPress,
	KeyRelease, ButtonPress, ButtonRelease, MotionNotify, EnterNotify,
	or LeaveNotify type event. 

	Note that if you use the TANGO:WIDGET_CLASS's :XMN_INPUT_CALLBACK
	(set by :SET_CALLBACK/:ADD_CALLBACK method), you'll achieve the
	semi-useless result of calling the callback function on all
	ButtonPress, ButtonRelease, KeyPress, and KeyRelease events.
	Instead, you should call the action procedure
		Lisp(send ACTION_WIDGET :GET_EVENT_IMAGE ACTION_XEVENT)
	from a translation table set-up on <tango-widget> by method
	:OVERRIDE_TRANSLATIONS.

		(defun printit (act-w act-e)
		       (print (send act-w :GET_EVENT_IMAGE act-e)))
		(send <tango-widget> :override_translations
	              "<Btn1Down>,<Btn1Up>: Lisp(printit ACTION_WIDGET ACTION_XEVENT)")

	One may also use standard event handlers without having to alter the
	translation table. Use :SET_EVHANDLER/:ADD_EVHANDLER while specifying
	the desired event-mask. (e.g. BUTTON_PRESS_MASK, BUTTON_RELEASE_MASK,
	KEY_PRESS_MASK, KEY_RELEASE_MASK).

	For example, the following event-handler flashes the tango-image
	which was clicked via mouse, as specified by the event-mask
	BUTTON_PRESS_MASK.

	 (send tango_w :set_event_handler BUTTON_PRESS_MASK
		'(EVHANDLER_WIDGET EVHANDLER_XEVENT)
		'(
		  (let ((timage (send EVHANDLER_WIDGET :get_event_image 
						       EVHANDLER_XEVENT)))
		    (if timage
			(send timage :tap_flash :perform 1)
		      ))
		  ))

*** TANGO:WIDGET_CLASS Method :GET_EVENT_COORD (TANGOget_event_coord()):

	(send <tango-widget> :GET_EVENT_COORD <xevent>)
		==> returns #C(<x> <y>) on success, NIL on failure
	
	<xevent> is typically taken from the CALLBACK_XEVENT or
	EVHANDLER_XEVENT values set within widget-class methods
	:SET_CALLBACK/:ADD_CALLBACK or :SET_EVHANDLER/:ADD_EVHANDLER. <xevent>
	is used to determine the x,y location of a KeyPress, KeyRelease,
	ButtonPress, ButtonRelease, MotionNotify, EnterNotify, or
	LeaveNotify type event. 
	
	See method :GET_EVENT_IMAGE above for other useage details.

*** TANGO:WIDGET_CLASS Method :LOAD_COLOR :

	(send <tango-widget> :LOAD_COLOR <color-str>)
		==> returns a FIXNUM representing a new TANGO_COLOR pixel
		    value.

	<color-str> is a STRING name of a color, typically a name
	from /usr/lib/X11/rgb.txt, e.g. "red". One may also specify a
	hexadecimal value for the color, e.g. "#FF0000".

	See also <<TANGO Colors (TANGO_COLOR):>> for details on
	colors in Xtango.

*** TANGO:WIDGET_CLASS Method :SET_BGCOLOR (TANGOset_bgcolor()):

	(send <tango-widget> :SET_BGCOLOR <color-str>)
		==> returns NIL.

	Method :SET_BGCOLOR sets the background color of <tango-widget>
	to <color-str>. <color-str> is a STRING name of a color, typically
	a name from /usr/lib/X11/rgb.txt, e.g. "red". One may also specify a
	hexadecimal value for the color, e.g. "#FF0000".

*** TANGO:WIDGET_CLASS Method :GET_IMAGES :

	(send <tango-widget> :GET_IMAGES [<visibility_kwd>])
		==> returns a LIST of TANGOIMAGEOBJs.
	
	[<visibility_kwd>] is an optional argument; if the argument is absent,
		all the images are returned, both visible and invisible. If
		:VISIBLE, then only visible images are returned; if :INVISIBLE,
		then only invisible images are returned.

	This method queries <tango-widget> returning the desired list
	of TANGOIMAGEOBJs, instances of TANGO:IMAGE_CLASS. This
	method can be used to save the set of images being displayed
	by calling :COLORS_STOREON to save the colormap, followed by
	calling :STOREON method on each image...

*** TANGO:WIDGET_CLASS Method :COLORS_STOREON :

	(send <tango-widget> :COLORS_STOREON)
		 ==> returns LIST of s-expressions representing calls to 
		     method :LOAD_COLOR which when evaluated, recreates
		     the colormap of <tango-widget>.
	
	An example of the output LIST from :COLORS_STOREON:
	(
		(SEND *TANGO_WIDGET* :LOAD_COLOR "black")
		(SEND *TANGO_WIDGET* :LOAD_COLOR "maroon")
		(SEND *TANGO_WIDGET* :LOAD_COLOR "red")
		(SEND *TANGO_WIDGET* :LOAD_COLOR "orange")
		(SEND *TANGO_WIDGET* :LOAD_COLOR "blue")
		(SEND *TANGO_WIDGET* :LOAD_COLOR "green")
		(SEND *TANGO_WIDGET* :LOAD_COLOR "yellow")
		(SEND *TANGO_WIDGET* :LOAD_COLOR "white")
		...
	)

	Note: this method should be used prior to 'eval'ing results of
	:STOREON on any TANGO:IMAGE_CLASS subclasses. For an example
	of using :COLOR_STOREON and :STOREON, see 
		<winterp-top-dir>/examples/xtango/cls-widget.lsp
	which defines a subclass of TANGO:WIDGET_CLASS, 
	XTANGO-WIDGET-CLASS, and methods :SAVE-IMAGES and :LOAD-IMAGES.

*** TANGO:WIDGET_CLASS Method :COPY_TO_2D_BITMAP_ARRAY :

	(send <tango-widget> :COPY_TO_2D_BITMAP_ARRAY <x> <y> <width> <height>)
		==> returns ARRAY of TANGO_COLOR values of the form:
	 	    #(#( <0,0>		... <width-1,0> )
           		.
           		.
           		.
		      #( <0,height-1>	... <width-1,height-1>)
	             )

	<x> <y> <width> and <height> are FLONUM's representing the area of
	the <tango-widget> to copy into a 2D_BITMAP_ARRAY. The size of the
	returned array is the integer size represented by those args.

	USAGE: (send <tango-w> :COPY_TO_2D_BITMAP_ARRAY 0.0 0.0 1.0 1.0)
	returns a bitmap representing all the images in <tango-w> (where
	values 0.0,1.0 represent default initial :PAN/:ZOOM factors.  To
	reset <tango-widget> to defaults prior to calling this routine,
	evaluate the following:
		(send <tango-widget> :SET_COORD 0.0 1.0 1.0 0.0)

	NOTE: you should 'eval' the results of :COLORS_STOREON prior to
	creating a new bitmap image with the results of
	:COPY_TO_2D_BITMAP_ARRAY.

** TANGO Images (TANGO_IMAGE):

	The TANGOIMAGEOBJ is an object describing a particular
	graphical image being displayed within a TANGO:WIDGET_CLASS
	instance.  In this implementation an image can be a line,
	rectangle, circle, ellipse, polyline, polygon, spline,
	bitmap, GIF, text, or a composite of the previous types.
	Rectangles, circles, ellipses, and polygons can have varying fill
	styles. Lines can have different thicknesses and styles. Currently,
	this base set of images is limited to provide a simpler basis to
	design animations.

	The WINTERP interface to XTANGO allows programmers to use the XLISP
	object system to create new images with new functionality and
	encapsulated animation capabilities by subclassing and/or composing the
	previously mentioned image types. 

*** Function TANGO:IMAGEOBJP:

	(TANGOIMAGEOBJP <expr>)
		==> returns T if argument is a TANGOIMAGEOBJ, else NIL.

*** Function TANGO:TAP_EXCHANGE (TAPexchange()):

	(TANGO:TAP_EXCHANGE [:PERFORM] <image-1> <image-2>)
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.

	This function exchanges the positions of TANGOIMAGEOBJs
	<image-1> and <image-2>. It is similar to TANGO:TAP_SWITCH,
	however, it moves each image over a path of length 20 using
	TANGO:PATH_MOTION, causing the positions to switch "smoothly".

*** Function TANGO:TAP_SWITCH (TAPswitch()):

	(TANGO:TAP_SWITCH [:PERFORM] <image-1> <image-2>)
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.

	This routine swaps two images; that is, <image-1> will acquire
	<image-2>'s location and vice versa.  The path that each image
	follows has a length of one, so the two images will appear to "jump"
	to their new locations. For a "smooth" version of this functionality,
	see TANGO:TAP_EXCHANGE.

*** TANGO:IMAGE_CLASS -- the xtango image base class

	All other WINTERP/Xtango image classes are subclasses of this class.

**** TANGO:IMAGE_CLASS method :NEW/:ISNEW :

	TANGO:IMAGE_CLASS is not instantiable. An error will occur if
	you try to instantiate this class. Subclasses of this class
	are instantiable.

**** TANGO:IMAGE_CLASS method :EXISTS_P :

	(send <tiobj> :EXISTS_P)
		==> returns T if the TANGOIMAGEOBJ exists (hasn't been
		    destroyed)
		==> returns NIL if the TANGOIMAGEOBJ has been destroyed
		    or has never been initialized.

**** TANGO:IMAGE_CLASS method :IMAGE_COPY (TANGOimage_copy()):

	(send <tiobj> :IMAGE_COPY)
		==> returns a TANGOIMAGEOBJ.
	
	This method returns a new instance of TANGO:IMAGE_CLASS (or a
	subclass thereof) which is an exact copy of the one given as a
	parameter <tiobj> (at that instant in time).  The new image will not
	appear until a transition is performed, or until a :REFRESH message
	is sent to the TANGO:WIDGET_CLASS instance in which the image
	resides. This behavior is similar to other cases of TANGO:IMAGE_CLASS
	instance creation (method :NEW).

**** TANGO:IMAGE_CLASS method :TX_MOVE (TANGO_TRANS_TYPE_MOVE):

	(send <t-image-obj> :TX_MOVE [:PERFORM] [<path>])
		==> returns <tango_trans> object, or NIL if :PERFORM given

	The MOVE transition moves the given <t-image-obj> along the given
	<path> (see below).  The first movement of the image corresponds to
	the first relative offset in the path. All these relative offsets are
	with respect to the image's previous position on the screen.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	The [<path>] argument is optional, and may be of multiple types:
	* if the <path> argument is omitted, then a path of length one with
		both x and y offsets set to 0.0 is used as the path for the
		transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type TANGO_PATH, then that is used as the path
		for the transition to take. TANGO:PATH_CREATE, and other
		TANGO:PATH_* functions return such TANGO_PATH typed results;
	* else, if <path> is of type FIXNUM, then a path of length <path> with
		both x and y offsets set to 0.0 is used as the path for the
		transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type COMPLEX (e.g. #C(<x> <y>), then a path of
		length one is used with x and y offsets set to <x> and <y>.)
	* else, if <path> is a sequence (LIST or ARRAY) of COMPLEX #C(<x> <y>),
		then a path of the same length as the sequence is created,
		with the x and y offsets set to the corresponding <x> <y>.

	Note: all <path> arg types other than TANGO_PATH are used here for
	convenience in creating transitions over simple, unique
	paths. "Simple cases" constitute paths which don't need to be be
	re-used, or altered via calls to TANGO:PATH_* functions.

**** TANGO:IMAGE_CLASS method :TX_VISIBLE (TANGO_TRANS_TYPE_VISIBLE):

	(send <t-image-obj> :TX_VISIBLE [:PERFORM] [<path>])
		==> returns <tango_trans> object, or NIL if :PERFORM given

	The VISIBLE transition switches the visibility of the given
	<t-image-obj> for each offset in the given <path>.  At each offset in
	the path, if the image is visible, it will become invisible, and
	vice-versa. Note that the actual <x>,<y> offsets in the path are
	ignored for this transition, therefore the optional <path> argument
	could be ommitted (to create a "null" path of length 1) or a FIXNUM
	(to create a "null" path of length of the FIXNUM).
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	The [<path>] argument is optional, and may be of multiple types:
	* if the <path> argument is omitted, then a path of length one with
		both x and y offsets set to 0.0 is used as the path for the
		transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type TANGO_PATH, then that is used as the path
		for the transition to take. TANGO:PATH_CREATE, and other
		TANGO:PATH_* functions return such TANGO_PATH typed results;
	* else, if <path> is of type FIXNUM, then a path of length <path> with
		both x and y offsets set to 0.0 is used as the path for the
		transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type COMPLEX (e.g. #C(<x> <y>), then a path of
		length one is used with x and y offsets set to <x> and <y>.)
	* else, if <path> is a sequence (LIST or ARRAY) of COMPLEX #C(<x> <y>),
		then a path of the same length as the sequence is created,
		with the x and y offsets set to the corresponding <x> <y>.
	
	Note: all <path> arg types other than TANGO_PATH are used here for
	convenience in creating transitions over simple, unique
	paths. "Simple cases" constitute paths which don't need to be be
	re-used, or altered via calls to TANGO:PATH_* functions.

**** TANGO:IMAGE_CLASS method :TX_RAISE (TANGO_TRANS_TYPE_RAISE):

	(send <t-image-obj> :TX_RAISE [:PERFORM] [<path>])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.

	The RAISE transition brings the given <t-image-obj> to the viewing
	plane closest to the viewer. The image's position is not changed,
	only its relative ordering (top to bottom) with respect to other
	images. Note that the actual <x>,<y> offsets in the path are ignored
	for this transition, therefore the optional <path> argument could be
	ommitted (to create a "null" path of length 1) or a FIXNUM (to create
	a "null" path of length of the FIXNUM).
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	

**** TANGO:IMAGE_CLASS method :TX_LOWER (TANGO_TRANS_TYPE_LOWER):)

	(send <t-image-obj> :TX_LOWER [:PERFORM] [<path>])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.
	
	The LOWER transition pushes the given <t-image-obj> to the viewing
	plane farthest from the viewer.  The image's position is not changed,
	only its relative ordering (top to bottom) with respect to other
	images.  It will possibly be obscured by every other image. Note that
	the actual <x>,<y> offsets in the path are ignored for this
	transition, therefore the optional <path> argument could be ommitted
	(to create a "null" path of length 1) or a FIXNUM (to create a "null"
	path of length of the FIXNUM).
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	

**** TANGO:IMAGE_CLASS method :TX_DELAY (TANGO_TRANS_TYPE_DELAY):

	(send <t-image-obj> :TX_DELAY [:PERFORM] [<path>])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.

	The DELAY transition creates a transition which has a null frame for
	each offset in the path.  By null frame, we mean that no action or
	modification is performed.  This transition is helpful when combined
	with concatenation in order to produce actions that commence at
	varying times.  The image used in this transition does not matter.
	Note that the actual <x>,<y> offsets in the path are ignored for this
	transition, therefore the optional <path> argument could be ommitted
	(to create a "null" path of length 1) or a FIXNUM (to create a "null"
	path of length of the FIXNUM).
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	

**** TANGO:IMAGE_CLASS method :TX_REFRESH (TANGO_TRANS_TYPE_REFRESH):

	(send <t-image-obj> :TX_REFRESH [:PERFORM] [<path>])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.

	The REFRESH transition redraws the entire animation window, restoring
	it to a pristine state.  This is useful when running TANGO in fast
	mode (non-total frame by frame refresh) and you would like to clean
	up damage to the screen.  A refresh is done for each offset in the
	path, i.e., there's no need for more than one offset in the path.
	The image used in this transition does not matter. Note that the
	actual <x>,<y> offsets in the path are ignored for this transition,
	therefore the optional <path> argument could be ommitted (to create a
	"null" path of length 1) or a FIXNUM (to create a "null" path of
	length of the FIXNUM).
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	

**** TANGO:IMAGE_CLASS method :TX_DELETE (TANGO_TRANS_TYPE_DELETE):

	(send <t-image-obj> :TX_DELETE [:PERFORM] [<path>])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.

	The DELETE transition makes an image invisible (if not already) and
	removes it from any possible later usage.  Any attempts to use this
	image as a parameter in subsequent TANGO calls will result in error
	messages.  Also, pre-existing transitions with this image as a
	parameter should not be performed (they'll be ignored in
	WINTERP). Note that the actual <x>,<y> offsets in the path are
	ignored for this transition, therefore the optional <path> argument
	may be ommitted, to create a "null" path of length 1.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	

**** TANGO:IMAGE_CLASS method :TX_ZOOM (TANGO_TRANS_TYPE_ZOOM):

	(send <t-image-obj> :TX_ZOOM [:PERFORM] [<path>])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.
	
	The ZOOM transition zooms the window in or out on the positional
	location of the image argument <t-image-obj>.  The <x> and <y>
	components of a path element #C(<x> <y>) determine how the zooming
	should occur.  They should be between 0.0 and 1.0.  Values close to
	1.0 will zoom in very tight.  Values near 0.0 do a slow zoom.  To get
	a nice slow, smooth zoom in on an object, use a path with quite a few
	offsets all of equal ``small'' offset values, such as #C(0.1 0.1).
	Positive offset values zoom the display in, negative offset values
	pull the display back out.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	The [<path>] argument is optional, and may be of multiple types:
	
	* if the <path> argument is omitted, then a path of length one with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type TANGO_PATH, then that is used as the path
	  for the transition to take. TANGO:PATH_CREATE, and other
	  TANGO:PATH_* functions return such TANGO_PATH typed results;
	* else, if <path> is of type FIXNUM, then a path of length <path> with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type COMPLEX (e.g. #C(<x> <y>), then a path of
	  length one is used with x and y offsets set to <x> and <y>.
	* else, if <path> is a sequence (LIST or ARRAY) of COMPLEX #C(<x> <y>),
	  then a path of the same length as the sequence is created,
	  with the x and y offsets set to the corresponding <x> <y>.
	
	Note: all <path> arg types other than TANGO_PATH are used here for
	convenience in creating transitions over simple, unique
	paths. "Simple cases" constitute paths which don't need to be be
	re-used, or altered via calls to TANGO:PATH_* functions.

**** TANGO:IMAGE_CLASS method :TAP_SHOW (TAPshow()):

	(send <tiobj> :TAP_SHOW)
		==> returns NIL
	
	This method simply displays the <tiobj> (i.e. uses a delay transition
	to display the object -- see method :TX_DELAY).  Creating a
	TANGO:IMAGE_CLASS instance will not cause the image to appear on the
	display until until a subsequent animation occurs, therefore this
	routine is useful for making sure that an image is properly displayed.

	Note that including the optional :SHOW keyword during xtango
	image creation does the equivalent of calling this function
	after the tango image object gets created.
	
	Note that if a large number of images are to be displayed, it is more
	efficient to do a :REFRESH on the TANGO:WIDGET_CLASS instance after
	all the images have been created. The same applies to using
	the optional :SHOW keyword for image creation.

**** TANGO:IMAGE_CLASS method :TAP_FILL (TAPfill()):

	(send <tiobj> :TAP_FILL [:PERFORM])
		==> returns <tango_trans> object
		    or NIL if :PERFORM keyword given.

	This method creates (and optionally :PERFORMs) the transition needed
	to fill the given image to a solid color. The color being the
	color specified during image creation, or the color specified
	by a subsequent transition, caused by :TAP_COLOR or
	:TX_COLOR. This method is similar to :TX_FILL, except that it
	changes the fill value to 100%...

**** TANGO:IMAGE_CLASS method :TAP_COLOR (TAPcolor()):

	(send <tiobj> :TAP_COLOR [:PERFORM] <tango-color>)
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.

	<tango-color> gives the color to which the image is changed when the
	transition is performed. This method is a short-hand version of
	:TX_COLOR. <tango-color> can either be a string color name (e.g. 
	"white" "black" "red" "orange" "yellow" "green" "blue" or "maroon".).
	
	Alternately, <tango-color> can be a FIXNUM [0-7] representing the
	tango-color pixel value. FIXNUM values for the standard Xtango colors
	are specified via the constants TANGO_COLOR_WHITE, TANGO_COLOR_BLACK,
	TANGO_COLOR_RED, TANGO_COLOR_ORANGE, TANGO_COLOR_YELLOW,
	TANGO_COLOR_GREEN, TANGO_COLOR_BLUE, or TANGO_COLOR_MAROON.
	
	Note that :TAP_COLOR, :TX_COLOR, and TANGO:PATH_COLOR only work with
	the eight "basic" tango colors mentioned above. Using colors other
	than the eight aforementioned colors, or using colors generated by
	TANGO:WIDGET_CLASS method :LOAD_COLOR will signal an error.

**** TANGO:IMAGE_CLASS method :TAP_VIS_TOGGLE (TAPvis_toggle()):

	(send <tiobj> :TAP_VIS_TOGGLE [:PERFORM])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.

	This method creates (and optionally :PERFORMs) the transition needed
	to toggle the visibility of <tiobj> and returns this transition.
	This method is a short-hand version of method :TX_VISIBLE.

**** TANGO:IMAGE_CLASS method :TAP_JUMP (TAPjump()):

	(send <tiobj> :TAP_JUMP [:PERFORM] <image_part_kwd> <location>)
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.

	<image_part_kwd> is a keyword argument, one of:
		:CTR	-- center
		:NW	-- north west
		:NE	-- north east
		:E	-- east
		:SE	-- south east
		:S	-- south
		:SW     -- south west
		:W      -- west
	<location> is a COMPLEX FLONUM #C(<x> <y>) representing the x/y
		coordinates of a location.

	This method sets up a transition to move <tiobj> to the given
	<location> using the specified <image_part_kwd> as a "handle."  The
	transition uses a path of length one, so essentially, the image will
	appear to "jump" from its current location to the new location.  The
	necessary transition is returned.

**** TANGO:IMAGE_CLASS method :TAP_MOVE (TAPmove()):

	(send <tiobj> :TAP_MOVE [:PERFORM] <image_part_kwd> <location>)
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.

	<image_part_kwd> is a keyword argument, one of:
		:CTR	-- center
		:NW	-- north west
		:NE	-- north east
		:E	-- east
		:SE	-- south east
		:S	-- south
		:SW     -- south west
		:W      -- west
	<location> is a COMPLEX FLONUM #C(<x> <y>) representing the x/y
		coordinates of a location.

	This method sets up a transition to move <tiobj> from the location of
	its indicated <image_part_kwd> to the given <location>.  This method
	is similar to method :TAP_JUMP; however, instead of using a path of
	length one to create the transition, it uses TANGO:PATH_MOTION to
	create the transition, which means that the path length is 20.  The
	required transition is returned.

**** TANGO:IMAGE_CLASS method :TAP_TRAVERSE (TAPtraverse()):

	(send <tiobj> :TAP_TRAVERSE [:PERFORM]
	      <image_part_kwd>
	      <location>
	      <path_motion_kwd>)
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.

	<image_part_kwd> is a keyword argument, one of:
		:CTR	-- center
		:NW	-- north west
		:NE	-- north east
		:E	-- east
		:SE	-- south east
		:S	-- south
		:SW     -- south west
		:W      -- west

	<location> is a COMPLEX FLONUM #C(<x> <y>) representing the x/y
		coordinates of a location.

	<path_motion_kwd> is a keyword, either :STRAIGHT, :CLOCKWISE,
		or :COUNTERCLOCKWISE.

	This routine creates the transition necessary to move an object
	(using the specified <image_part_kwd> of the object) from its current
	position to <location>.  The type of path that the object follows is
	given by the parameter <path_motion_kwd>; <path_motion_kwd> is simply
	a path type, i.e.  it is of the same form as the path types for the
	TANGO:PATH_MOTION routine.

**** TANGO:IMAGE_CLASS method :TAP_FLASH (TAPflash()):

	(send <tiobj> :TAP_FLASH [:PERFORM] <num_flash_fixnum>)
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.

	This method causes <tiobj> to toggle between visible and invisible
	for the given number of times.  This makes an object appear
	to flash. This method is a short-hand version of method :TX_VISIBLE.

*** TANGO:BITMAP_IMAGE_CLASS (TANGO_IMAGE_TYPE_BITMAP)

**** TANGO:BITMAP_IMAGE_CLASS method :NEW/:ISNEW (TANGOimage_create()):

	(send TANGO:BITMAP_IMAGE_CLASS :new
	      [:show] [<visible_kwd>] <tango_widget>
	      <location_coord>
	      <bitmap_array>
	      )
		==> RETURNS an <tango_image> object.

	[:show] -- OPTIONAL :show keyword. If present, displays image
	immediately, else the image will be displayed along with the next
	animation frame. See :TAP_SHOW :TX_DELAY.

	[<visible_kwd>] -- OPTIONAL :VISIBLE or :INVISIBLE keyword. If
	omitted, :VISIBLE is assumed. See also :TX_VISIBLE, :TAP_VIS_TOGGLE.

	<tango_widget> -- an instance of TANGO:WIDGET_CLASS.

	<location_coord> -- the location for placing the bitmap image. A
	COMPLEX number, of form #C(<loc_x> <loc_y>), where
	<loc_x> is a FLONUM, typically [0.0 - 1.0] representing the X-axis
	location; <loc_y> is a FLONUM, typically [0.0 - 1.0] representing the
	Y-axis location. See <<TANGO Locations and Coordinates (TANGO_LOC):>>
	section above.

	<bitmap_array> -- a 3-D array of FIXNUMs (TANGO_COLOR). Each FIXNUM
	represents a Pixel (TANGO_COLOR) value. For example, a "movie"
	consisting of 3 4x4 bitmaps is represented by the following:
                 #(#(#(1 1 1 1)
		     #(7 7 7 7) 
		     #(7 7 7 7) 
 		     #(7 7 7 7)) 
 		   #(#(7 7 7 1) 
 		     #(7 7 1 7) 
 		     #(7 1 7 7) 
 		     #(1 7 7 7)) 
 		   #(#(7 7 7 1) 
 		     #(7 7 7 1) 
 		     #(7 7 7 1) 
 		     #(7 7 7 1)))

**** TANGO:BITMAP_IMAGE_CLASS method :STOREON

	(send <bitmap-image> :STOREON)
		==> returns list
		    (send TANGO:BITMAP_IMAGE_CLASS :new <visibility_kwd>
			  *TANGO_WIDGET*
			  #C(<location-x> <location-y)
			  #( <bitmap-array-1> <bitmap-array-2> ... ))

	See <<TANGO:BITMAP_IMAGE_CLASS method :NEW/:ISNEW...>>
	for details on the returned data.
	
	Evaluating the results of this method will create a copy of the given
	image at a later time. Printing the results of this method to a file
	enables one to store a persistent copy of the given image to
	disk. See also TANGO:WIDGET_CLASS method :GET_IMAGES and
	:COLORS_STOREON.

**** TANGO:BITMAP_IMAGE_CLASS method :TX_SHUFFLE

	(send <bitmap-image> :TX_SHUFFLE [:PERFORM] [<path>])
		==> returns <tango_trans> object, or NIL if :PERFORM keyword given
	
	The SHUFFLE transition affects only the TANGO:BITMAP_IMAGE_CLASS.  For
	each offset in the <path> argument, the next 2-d bitmap in the image's
	series will be displayed.  The series is considered circular, i.e.,
	the successor of the last bitmap is the first bitmap.  This transition
	is useful to get a certain effect such as a door opening.  To do this,
	define a BITMAP image with a series of individual bitmaps showing the
	various stages of the door opening.  Then run a SHUFFLE transition to
	animate that occurrance. Note that the actual <x>,<y> offsets in the
	path are ignored for this transition, therefore the optional <path>
	argument could be ommitted (to create a "null" path of length 1) or a
	FIXNUM (to create a "null" path of length of the FIXNUM).
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for 
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	The [<path>] argument is optional, and may be of multiple types:
	
		* if the <path> argument is omitted, then a path of length one 
		  with both x and y offsets set to 0.0 is used as the path for
		  the transition (see TANGOpath_null() in doc/xtangodoc.tex);
		* else, if <path> is of type TANGO_PATH, then that is used as
		  the path for the transition to take. TANGO:PATH_CREATE, and
		  other TANGO:PATH_* functions return such TANGO_PATH typed
		  results;
		* else, if <path> is of type FIXNUM, then a path of length
		  <path> with both x and y offsets set to 0.0 is used as the
		  path for the transition (see TANGOpath_null() in 
		  doc/xtangodoc.tex);
		* else, if <path> is of type COMPLEX (e.g. #C(<x> <y>), then
		  a path of length one is used with x and y offsets set to <x>
		  and <y>.)
		* else, if <path> is a sequence (LIST or ARRAY) of COMPLEX 
		  #C(<x> <y>), then a path of the same length as the sequence
		  is created, with the x and y offsets set to the corresponding
		 <x> <y>.

	Note: all <path> arg types other than TANGO_PATH are used here for 
	convenience in creating transitions over simple, unique paths.
	"Simple cases" constitute paths which don't need to be be re-used, or
	altered via calls to TANGO:PATH_* functions.

**** TANGO:BITMAP_IMAGE_CLASS method :IMAGE_LOC (TANGOimage_loc()):

	(send <tiobj> :IMAGE_LOC <image_part_kwd>)
		==> returns a COMPLEX number #C(<x> <y>), where <x> and <y>
		    are FLONUMS representing the location of the image
	
		<image_part_kwd> is a keyword argument, one of:
			:CTR	-- center
			:NW	-- north west
			:NE	-- north east
			:E	-- east
			:SE	-- south east
			:S	-- south
			:SW     -- south west
			:W      -- west
	
	This routine returns a COMPLEX FLONUM #C(<x> <y>) that corresponds to
	the location of the given <image_part_kwd> of the given <tiobj>.

	Valid <image_part_kwd> include :CTR (center), and the compass
	directions :NW, :N, :NE, :E, :SE, :S, :SW, :W. Given that the
	bitmap is a rectangular image, the locations specified by
	<image_part_kwd> represent the actual boundaries of the image.

*** TANGO:CIRCLE_IMAGE_CLASS (TANGO_IMAGE_TYPE_CIRCLE):

**** TANGO:CIRCLE_IMAGE_CLASS method :NEW/:ISNEW (TANGOimage_create()):

	(send TANGO:CIRCLE_IMAGE_CLASS :new
	      [:show] [<visible_kwd>] <tango_widget>
	      <location_coord>
              <size_coord>
	      <tango_color>
	      <fill_float>
	      )
		==> RETURNS an <tango_image> object.

	[:show] -- OPTIONAL :show keyword. If present, displays image
	immediately, else the image will be displayed along with the next
	animation frame. See :TAP_SHOW :TX_DELAY.

	[<visible_kwd>] -- OPTIONAL :VISIBLE or :INVISIBLE keyword. If
	omitted, :VISIBLE is assumed. See also :TX_VISIBLE, :TAP_VIS_TOGGLE.

	<tango_widget> -- an instance of TANGO:WIDGET_CLASS.

	<location_coord> -- the location for placing the circle image. A
	COMPLEX number, of form #C(<loc_x> <loc_y>), where
	<loc_x> is a FLONUM, typically [0.0 - 1.0] representing the X-axis
	location; <loc_y> is a FLONUM, typically [0.0 - 1.0] representing the
	Y-axis location. See <<TANGO Locations and Coordinates (TANGO_LOC):>>
	section above.

	<size_coord> -- The radius of the circle image, COMPLEX or
	FLONUM. If COMPLEX, then the 'realpart' is taken as the radius.
	Type COMPLEX is accepted for this parameter for consistency
	with TANGO:RECTANGLE_IMAGE_CLASS and TANGO:ELLIPSE_IMAGE_CLASS
	
	<tango_color> -- The color of the image; it can either be a string
	color name, or a FIXNUM representing the tango pixel value. If given
	a string, it is looked up in the X11 file /usr/lib/X11/rgb.txt. 
	See <<TANGO Colors (TANGO_COLOR):>> section above for details.

	<fill_float> -- the fill value of the image, a FLONUM between
	0.0 and 1.0. 0.0 corresponds to an unfilled outline and 1.0
	corresponds to 100 per cent fill in the given color.
	(Forty graduated fill styles are actually implemented.)

**** TANGO:CIRCLE_IMAGE_CLASS method :STOREON

	(send <circle-image> :STOREON)
		==> returns list
		    (send TANGO:CIRCLE_IMAGE_CLASS :new <visibility_kwd>
			  *TANGO_WIDGET*
			  #C(<location-x> <location-y)
			  <radius_float>
			  <tango_color>
			  <fill_float>)

	See <<TANGO:CIRCLE_IMAGE_CLASS method :NEW/:ISNEW...>>
	for details on the returned data.
	
	Evaluating the results of this method will create a copy of the given
	image at a later time. Printing the results of this method to a file
	enables one to store a persistent copy of the given image to
	disk. See also TANGO:WIDGET_CLASS method :GET_IMAGES and
	:COLORS_STOREON.

**** TANGO:CIRCLE_IMAGE_CLASS method :IMAGE_LOC (TANGOimage_loc()):

	(send <tiobj> :IMAGE_LOC <image_part_kwd>)
		==> returns a COMPLEX number #C(<x> <y>), where <x> and <y>
		    are FLONUMS representing the location of the image
	
		<image_part_kwd> is a keyword argument, one of:
			:CTR	-- center
			:NW	-- north west
			:NE	-- north east
			:E	-- east
			:SE	-- south east
			:S	-- south
			:SW     -- south west
			:W      -- west
	
	This routine returns a COMPLEX FLONUM #C(<x> <y>) that corresponds to
	the location of the given <image_part_kwd> of the given <tiobj>.

	Valid <image_part_kwd> include :CTR (center), and the compass
	directions :NW, :N, :NE, :E, :SE, :S, :SW, :W. Given that the
	bitmap is a circle, the locations specified by
	<image_part_kwd> represent the actual boundaries of the image.

**** TANGO:CIRCLE_IMAGE_CLASS method :TX_COLOR (TANGO_TRANS_TYPE_COLOR):

	(send <t-image-obj> :TX_COLOR [:PERFORM] [<path>])
		==> returns <tango_trans> object, 
		    or NIL if :PERFORM keyword given.
	
	The COLOR transition changes the given <t-image-obj> to the color
	indicated by the given <path>.  See the routine TANGO:PATH_COLOR to
	create a special path which will change the image to a certain
	color. Using an arbitrary TANGO_PATH type argument, or using one of
	the other alternatives for the <path> argument list (as used
	in other :TX_* methods) will generate undefined results.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.

**** TANGO:CIRCLE_IMAGE_CLASS method :TX_FILL (TANGO_TRANS_TYPE_FILL):

	(send <t-image-obj> :TX_FILL [:PERFORM] [<path>])
		==> returns <tango_trans> object, 
		    or NIL if :PERFORM keyword given.
	
	The FILL transition changes the "fill" component of the given image
	<t-image-obj>. This transition alters the image's fill style value by
	the <x> value of the offsets in <path>.  The <x> value is simply
	added to the existing fill value of <t-image-obj>, the <y> value is
	ignored.  If the image's fill value goes below 0.0, it is
	automatically set back to 0.0.  If it goes above 1.0, it is set back
	to 1.0.  Actually, the full range of values between 0.0 and 1.0 is
	not available.  We currently implement 40 different fills that range
	between the two extremes.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	The [<path>] argument is optional, and may be of multiple types:
	* if the <path> argument is omitted, then a path of length one with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type TANGO_PATH, then that is used as the path
	  for the transition to take. TANGO:PATH_CREATE, and other
	  TANGO:PATH_* functions return such TANGO_PATH typed results;
	* else, if <path> is of type FIXNUM, then a path of length <path> with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type COMPLEX (e.g. #C(<x> <y>), then a path of
	  length one is used with x and y offsets set to <x> and <y>.
	* else, if <path> is a sequence (LIST or ARRAY) of COMPLEX #C(<x> <y>),
	  then a path of the same length as the sequence is created,
	  with the x and y offsets set to the corresponding <x> <y>.
	
	Note: all <path> arg types other than TANGO_PATH are used here for
	convenience in creating transitions over simple, unique
	paths. "Simple cases" constitute paths which don't need to be be
	re-used, or altered via calls to TANGO:PATH_* functions.

**** TANGO:CIRCLE_IMAGE_CLASS method :TX_RESIZE (TANGO_TRANS_TYPE_RESIZE):

	(send <t-image-obj> :TX_RESIZE [:PERFORM] [<path>])
		==> returns <tango_trans> object, 
		    or NIL if :PERFORM keyword given.
	
	The RESIZE transition resizes the given <t-image-obj> along the given
	<path>. TANGO:CIRCLE_IMAGE_CLASS instances are resized by modifying
	the circle's radius by the amount given in the <x> component of each
	offset in the <path>. The <y> component of <path> is ignored.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	The [<path>] argument is optional, and may be of multiple types:
	* if the <path> argument is omitted, then a path of length one with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type TANGO_PATH, then that is used as the path
	  for the transition to take. TANGO:PATH_CREATE, and other
	  TANGO:PATH_* functions return such TANGO_PATH typed results;
	* else, if <path> is of type FIXNUM, then a path of length <path> with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type COMPLEX (e.g. #C(<x> <y>), then a path of
	  length one is used with x and y offsets set to <x> and <y>.
	* else, if <path> is a sequence (LIST or ARRAY) of COMPLEX #C(<x> <y>),
	  then a path of the same length as the sequence is created,
	  with the x and y offsets set to the corresponding <x> <y>.
	
	Note: all <path> arg types other than TANGO_PATH are used here for
	convenience in creating transitions over simple, unique
	paths. "Simple cases" constitute paths which don't need to be be
	re-used, or altered via calls to TANGO:PATH_* functions.

*** TANGO:COMPOSITE_IMAGE_CLASS (TANGO_IMAGE_TYPE_COMPOSITE):

**** TANGO:COMPOSITE_IMAGE_CLASS method :NEW/:ISNEW (TANGOimage_create()):

	(send TANGO:COMPOSITE_IMAGE_CLASS :new
	      [:show] [<visible_kwd>] <tango_widget>
	      <location_coord>
	      <class-specific-image-instance-creation-arg>
	      [<class-specific-image-instance-creation-arg>
		...
	      [<class-specific-image-instance-creation-arg>]]
	      )
		==> RETURNS an <tango_image> object.

	[:show] -- OPTIONAL :show keyword. If present, displays image
	immediately, else the image will be displayed along with the next
	animation frame. See :TAP_SHOW :TX_DELAY.

	[<visible_kwd>] -- OPTIONAL :VISIBLE or :INVISIBLE keyword. If
	omitted, :VISIBLE is assumed. See also :TX_VISIBLE, :TAP_VIS_TOGGLE.

	<tango_widget> -- an instance of TANGO:WIDGET_CLASS.

	<location_coord> -- the location for placing the composite image. A
	COMPLEX number, of form #C(<loc_x> <loc_y>), where <loc_x> is a FLONUM,
	typically [0.0 - 1.0] representing the X-axis location; <loc_y> is a
	FLONUM, typically [0.0 - 1.0] representing the Y-axis location. See
	<<TANGO Locations and Coordinates (TANGO_LOC):>> section above.

	[class-specific-image-instance-creation-arg> is a sequence of
	arguments representing the image-class-specific data needed to create
	an instance of the specified class, e.g.

		TANGO:TEXT_IMAGE_CLASS #C(0.25 0.25) :ctr "text image class"
			               TANGO_COLOR_MAROON "6x13"

	Each sequence [class-specific-image-instance-creation-args...] becomes
	an element displayed in the composite image. The order, types and
	numbers of parameters correspond to the arguments used in creating a
	tango-image (see :NEW method descriptions for all the other subclasses
	of TANGO:IMAGE_CLASS).  For example, if some images were created with
	the following code

		(send TANGO:CIRCLE_IMAGE_CLASS :new :show tango_w
		      #C(0.25 0.25) 0.2 t TANGO_COLOR_MAROON 1.0)
		(send TANGO:POLYGON_IMAGE_CLASS :new :show tango_w
		      #C(0.50 0.50) #C(0.10 0.10) #C(0.10 0.10)
		      "red" 1.0)

	then you might use the following to create a composite image containing
	the above images with the following call:

		(send TANGO:COMPOSITE_IMAGE_CLASS :new
		      :show tango_w #C(0.25 0.25)
	              TANGO:CIRCLE_IMAGE_CLASS
			#C(0.25 0.25) 0.2 TANGO_COLOR_MAROON 1.0
		      TANGO:POLYGON_IMAGE_CLASS
			#C(0.50 0.50) #C(0.10 0.10)#C(0.10 0.10) "red" 1.0
		)

**** TANGO:COMPOSITE_IMAGE_CLASS method :STOREON

	(send <composite_image> :STOREON)
		==> returns list of form
		(send TANGO:COMPOSITE_IMAGE_CLASS :new <visibility_kwd>
		      *TANGO_WIDGET*
		      #C(<location-x> <location-y>)
		      [class-specific-image-instance-creation-args...]
		      [class-specific-image-instance-creation-args...]
		      ...)

	See <<TANGO:COMPOSITE_IMAGE_CLASS method :NEW/:ISNEW ...>> for details
	on the returned data.
	
	Evaluating the results of this method will create a copy of the given
	image at a later time. Printing the results of this method to a file
	enables one to store a persistent copy of the given image to
	disk. See also TANGO:WIDGET_CLASS method :GET_IMAGES and
	:COLORS_STOREON.

**** TANGO:COMPOSITE_IMAGE_CLASS method :IMAGE_LOC (TANGOimage_loc()):

	(send <composite_image> :IMAGE_LOC <image_part_kwd>)
		==> returns a COMPLEX number #C(<x> <y>), where <x> and <y>
		    are FLONUMS representing the location of the image
	
		<image_part_kwd> is a keyword argument, one of:
			:CTR	-- center
			:NW	-- north west
			:NE	-- north east
			:E	-- east
			:SE	-- south east
			:S	-- south
			:SW     -- south west
			:W      -- west
	
	This routine returns a COMPLEX FLONUM #C(<x> <y>) that corresponds to
	the location of the given <image_part_kwd> of the given <tiobj>.

	Valid <image_part_kwd> include :CTR (center), and the compass
	directions :NW, :N, :NE, :E, :SE, :S, :SW, :W. These
	represent locations on the bounding box surrounding the set
	of images contained in the TANGO:COMPOSITE_IMAGE_CLASS instance.

**** TANGO:COMPOSITE_IMAGE_CLASS method :TX_COLOR (TANGO_TRANS_TYPE_COLOR):

	(send <composite_image> :TX_COLOR [:PERFORM] [<path>])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.
	
	The COLOR transition changes the given <composite_image> to the color
	indicated by the given <path>.  See the routine TANGO:PATH_COLOR to
	create a special path which will change the image to a certain
	color. Using an arbitrary TANGO_PATH type argument, or using one of
	the other alternatives for the <path> argument list will generate
	undefined results.

	For composite images, method :TX_COLOR will apply :TX_COLOR
	to all the subimages contained in the given composite image.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.

**** TANGO:COMPOSITE_IMAGE_CLASS method :TX_FILL (TANGO_TRANS_TYPE_FILL):

	(send <composite_image> :TX_FILL [:PERFORM] [<path>])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.
	
	This method alters the fill value of each subimage of <composite_image>
	This will affect different subimage types differently:
	
	For instances of TANGO:RECTANGLE_IMAGE_CLASS,
	TANGO:CIRCLE_IMAGE_CLASS, TANGO:ELLIPSE_IMAGE_CLASS, and
	TANGO:POLYGON_IMAGE_CLASS, this transition alters the image's fill
	style value by the <x> value of the offsets in <path>.  The <x> value
	is simply added to the existing fill value of <composite_image>, the
	<y> value is ignored.  If the image's fill value goes below 0.0, it is
	automatically set back to 0.0.  If it goes above 1.0, it is set back
	to 1.0.  Actually, the full range of values between 0.0 and 1.0 is
	not available.  We currently implement 40 different fills that range
	between the two extremes.
	
	For instances of TANGO:LINE_IMAGE_CLASS, TANGO:POLYLINE_IMAGE_CLASS,
	and TANGO:SPLINE_IMAGE_CLASS, the <x> value of each offset in <path>
	is added to the line's <width> parameter value, and the <y> value is
	added to the line's <style> parameter value (see the documentation
	accompanying the :NEW method on the associated tango image classes
	for further information on <width> and <style>).  Extreme values are
	reset to 0.0 and 1.0 as in rectangles and circles.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	The [<path>] argument is optional, and may be of multiple types:
	
	* if the <path> argument is omitted, then a path of length one with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type TANGO_PATH, then that is used as the path
	  for the transition to take. TANGO:PATH_CREATE, and other
	  TANGO:PATH_* functions return such TANGO_PATH typed results;
	* else, if <path> is of type FIXNUM, then a path of length <path> with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type COMPLEX (e.g. #C(<x> <y>), then a path of
	  length one is used with x and y offsets set to <x> and <y>.
	* else, if <path> is a sequence (LIST or ARRAY) of COMPLEX #C(<x> <y>),
	  then a path of the same length as the sequence is created,
	  with the x and y offsets set to the corresponding <x> <y>.
	
	Note: all <path> arg types other than TANGO_PATH are used here for
	convenience in creating transitions over simple, unique
	paths. "Simple cases" constitute paths which don't need to be be
	re-used, or altered via calls to TANGO:PATH_* functions.

**** TANGO:COMPOSITE_IMAGE_CLASS method :TX_RESIZE (TANGO_TRANS_TYPE_RESIZE):

	(send <composite_image> :TX_RESIZE [:PERFORM] [<path>])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.
	
	The RESIZE transition resizes the given <composite_image> along the
	given <path>. For composite images, a resize transition will be passed
	on to all the subimages of <composite_image>, each handling resize
	differently:
		* TANGO:LINE_IMAGE_CLASS instances can have positive or
		  negative sizes, they are resized by altering the line's
		  size for each offset in the path.
		* TANGO:RECTANGLE_IMAGE_CLASS instances can have only
		  positive sizes, so resizing a rectangle corresponds to
		  "dragging" the lower right corner of the rectangle along
		  the given path. If one of the rectangle's dimensions would
		  become negative, it is set to 0.
		* TANGO:CIRCLE_IMAGE_CLASS instances are resized by modifying
		  the circle's radius by the amount given in the <x>
		  component of each offset in the <path>. The <y> component
		  of <path> is ignored.
		* TANGO:ELLIPSE_IMAGE_CLASS instances are resized by adding
		  the <x> part of <path> value to the ellipse's <x> radius
		  and the <y> part of <path> to the <y> radius.
		* other subimage types ignore :TX_RESIZE...

	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	The [<path>] argument is optional, and may be of multiple types:
	* if the <path> argument is omitted, then a path of length one with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type TANGO_PATH, then that is used as the path
	  for the transition to take. TANGO:PATH_CREATE, and other
	  TANGO:PATH_* functions return such TANGO_PATH typed results;
	* else, if <path> is of type FIXNUM, then a path of length <path> with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type COMPLEX (e.g. #C(<x> <y>), then a path of
	  length one is used with x and y offsets set to <x> and <y>.
	* else, if <path> is a sequence (LIST or ARRAY) of COMPLEX #C(<x> <y>),
	  then a path of the same length as the sequence is created,
	  with the x and y offsets set to the corresponding <x> <y>.
	
	Note: all <path> arg types other than TANGO_PATH are used here for
	convenience in creating transitions over simple, unique
	paths. "Simple cases" constitute paths which don't need to be be
	re-used, or altered via calls to TANGO:PATH_* functions.

**** TANGO:COMPOSITE_IMAGE_CLASS method :TX_RESIZE[1-7]:

	(send <composite_image> :TX_RESIZE1 [:PERFORM] [<path>])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.
		.
		.
		.
	(send <composite_image> :TX_RESIZE7 [:PERFORM] [<path>])
		==> returns <tango_trans> object, 
		    or NIL if :PERFORM keyword given.
	
	For <composite_image>, the transitions :TX_RESIZE1-:TX_RESIZE7 are
	passed on to any subimages that are instances of instance of class
	TANGO:POLYLINE_IMAGE_CLASS, TANGO:POLYGON_IMAGE_CLASS, or
	TANGO:SPLINE_IMAGE_CLASS. The transitions :TX_RESIZE1-:TX_RESIZE7
	modify the relative positions of the respective vertex number, plus
	all others after it in numerical order, by the relative <x> <y>
	offsets of <path>.  These transitions are useful, for example, with a
	forward arrow polyline that has many of its edges compressed down to
	start.  They can subsequently be grown out in all different
	directions, one at a time.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	The [<path>] argument is optional, and may be of multiple types:
	
	* if the <path> argument is omitted, then a path of length one with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type TANGO_PATH, then that is used as the path
	  for the transition to take. TANGO:PATH_CREATE, and other
	  TANGO:PATH_* functions return such TANGO_PATH typed results;
	* else, if <path> is of type FIXNUM, then a path of length <path> with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type COMPLEX (e.g. #C(<x> <y>), then a path of
	  length one is used with x and y offsets set to <x> and <y>.
	* else, if <path> is a sequence (LIST or ARRAY) of COMPLEX #C(<x> <y>),
	  then a path of the same length as the sequence is created,
	  with the x and y offsets set to the corresponding <x> <y>.
	
	Note: all <path> arg types other than TANGO_PATH are used here for
	convenience in creating transitions over simple, unique
	paths. "Simple cases" constitute paths which don't need to be be
	re-used, or altered via calls to TANGO:PATH_* functions.

**** TANGO:COMPOSITE_IMAGE_CLASS method :TX_GRAB[1-7]:

	(send <composite_image> :TX_GRAB1 [:PERFORM] [<path>])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.
		.
		.
		.
	(send <composite_image> :TX_GRAB7 [:PERFORM] [<path>])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.
	
	For <composite_image>, the transitions :TX_GRAB1-:TX_GRAB7 are passed
	on to any subimages that are instances of instance of class
	TANGO:POLYLINE_IMAGE_CLASS, TANGO:POLYGON_IMAGE_CLASS, or
	TANGO:SPLINE_IMAGE_CLASS. The transitions :TX_GRAB1-:TX_GRAB7 modify
	the relative position of a particular vertex on the image (except the
	one denoting the image's position) by the relative offsets of the
	path.  As opposed to :TX_RESIZE[1-7], the transitions :TX_GRAB[1-7]
	alter only one particular vertex in the image's definition. Think of
	grabbing that vertex and swinging it around while all the other
	points stay anchored.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	The [<path>] argument is optional, and may be of multiple types:
	* if the <path> argument is omitted, then a path of length one with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type TANGO_PATH, then that is used as the path
	  for the transition to take. TANGO:PATH_CREATE, and other
	  TANGO:PATH_* functions return such TANGO_PATH typed results;
	* else, if <path> is of type FIXNUM, then a path of length <path> with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type COMPLEX (e.g. #C(<x> <y>), then a path of
	  length one is used with x and y offsets set to <x> and <y>.
	* else, if <path> is a sequence (LIST or ARRAY) of COMPLEX #C(<x> <y>),
	  then a path of the same length as the sequence is created,
	  with the x and y offsets set to the corresponding <x> <y>.
	
	Note: all <path> arg types other than TANGO_PATH are used here for
	convenience in creating transitions over simple, unique
	paths. "Simple cases" constitute paths which don't need to be be
	re-used, or altered via calls to TANGO:PATH_* functions.

*** TANGO:ELLIPSE_IMAGE_CLASS (TANGO_IMAGE_TYPE_ELLIPSE):

**** TANGO:ELLIPSE_IMAGE_CLASS method :NEW/:ISNEW (TANGOimage_create()):

	(send TANGO:ELLIPSE_IMAGE_CLASS :new
	      [:show] [<visible_kwd>] <tango_widget>
	      <location_coord>
	      <size_coord>
	      <tango_color>
	      <fill_float>
	      )
		==> RETURNS an <tango_image> object.
	
	[:show] -- OPTIONAL :show keyword. If present, displays image
	immediately, else the image will be displayed along with the next
	animation frame. See :TAP_SHOW :TX_DELAY.
	
	[<visible_kwd>] -- OPTIONAL :VISIBLE or :INVISIBLE keyword. If
	omitted, :VISIBLE is assumed. See also :TX_VISIBLE, :TAP_VIS_TOGGLE.
	
	<tango_widget> -- an instance of TANGO:WIDGET_CLASS.
	
	<location_coord> -- the location for placing the ellipse image. A
	COMPLEX number, of form #C(<loc_x> <loc_y>), where <loc_x> is a
	FLONUM, typically [0.0 - 1.0] representing the X-axis location;
	<loc_y> is a FLONUM, typically [0.0 - 1.0] representing the Y-axis
	location. See <<TANGO Locations and Coordinates (TANGO_LOC):>>
	section above.
	
	<size_coord> -- The size of the ellipse image, a COMPLEX number of
	form #C(<size_x> <size_y>), where <size_x> is a FLONUM, typically
	[0.0 - 1.0] representing the X-axis radius; <size_y> is a FLONUM,
	typically [0.0 - 1.0] representing the Y-axis radius.
		
	<tango_color> -- The color of the image; it can either be a string
	color name, or a FIXNUM representing the tango pixel value. If given
	a string, it is looked up in the X11 file /usr/lib/X11/rgb.txt.  See
	<<TANGO Colors (TANGO_COLOR):>> section above for details.
	
	<fill_float> -- the fill value of the image, a FLONUM between 0.0 and
	1.0. 0.0 corresponds to an unfilled outline and 1.0 corresponds to
	100 per cent fill in the given color.  (Forty graduated fill styles
	are actually implemented.)

**** TANGO:ELLIPSE_IMAGE_CLASS method :STOREON

	(send <ellipse-image> :STOREON)
		==> returns list
		(send TANGO:ELLIPSE_IMAGE_CLASS :new <visibility_kwd>
		      *TANGO_WIDGET*
		      #C(<location-x> <location-y)
		      #C(<radius-x> <radius-y>)
		      <tango_color>
		      <fill_float>)

	See <<TANGO:ELLIPSE_IMAGE_CLASS method :NEW/:ISNEW...>>
	for details on the returned data.
	
	Evaluating the results of this method will create a copy of the given
	image at a later time. Printing the results of this method to a file
	enables one to store a persistent copy of the given image to
	disk. See also TANGO:WIDGET_CLASS method :GET_IMAGES and
	:COLORS_STOREON.

**** TANGO:ELLIPSE_IMAGE_CLASS method :IMAGE_LOC (TANGOimage_loc()):

	(send <tiobj> :IMAGE_LOC <image_part_kwd>)
		==> returns a COMPLEX number #C(<x> <y>), where <x> and <y>
		    are FLONUMS representing the location of the image
	
		<image_part_kwd> is a keyword argument, one of:
			:CTR	-- center
			:NW	-- north west
			:NE	-- north east
			:E	-- east
			:SE	-- south east
			:S	-- south
			:SW     -- south west
			:W      -- west
	
	This routine returns a COMPLEX FLONUM #C(<x> <y>) that corresponds to
	the location of the given <image_part_kwd> of the given <tiobj>.

	Valid <image_part_kwd> include :CTR (center), and the compass
	directions :NW, :N, :NE, :E, :SE, :S, :SW, :W. These
	represent locations on the bounding box of the ellipse.

**** TANGO:ELLIPSE_IMAGE_CLASS method :TX_COLOR (TANGO_TRANS_TYPE_COLOR):

	(send <t-image-obj> :TX_COLOR [:PERFORM] [<path>])
		==> returns <tango_trans> object, 
		    or NIL if :PERFORM keyword given.
	
	The COLOR transition changes the given <t-image-obj> to the color
	indicated by the given <path>.  See the routine TANGO:PATH_COLOR to
	create a special path which will change the image to a certain
	color. Using an arbitrary TANGO_PATH type argument, or using one of
	the other alternatives for the <path> argument list (as used
	in other :TX_* methods) will generate undefined results.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.

**** TANGO:ELLIPSE_IMAGE_CLASS method :TX_FILL (TANGO_TRANS_TYPE_FILL):

	(send <t-image-obj> :TX_FILL [:PERFORM] [<path>])
		==> returns <tango_trans> object, 
		    or NIL if :PERFORM keyword given.
	
	The FILL transition changes the "fill" component of the given image
	<t-image-obj>. This transition alters the image's fill style value by
	the <x> value of the offsets in <path>.  The <x> value is simply
	added to the existing fill value of <t-image-obj>, the <y> value is
	ignored.  If the image's fill value goes below 0.0, it is
	automatically set back to 0.0.  If it goes above 1.0, it is set back
	to 1.0.  Actually, the full range of values between 0.0 and 1.0 is
	not available.  We currently implement 40 different fills that range
	between the two extremes.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	The [<path>] argument is optional, and may be of multiple types:
	* if the <path> argument is omitted, then a path of length one with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type TANGO_PATH, then that is used as the path
	  for the transition to take. TANGO:PATH_CREATE, and other
	  TANGO:PATH_* functions return such TANGO_PATH typed results;
	* else, if <path> is of type FIXNUM, then a path of length <path> with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type COMPLEX (e.g. #C(<x> <y>), then a path of
	  length one is used with x and y offsets set to <x> and <y>.
	* else, if <path> is a sequence (LIST or ARRAY) of COMPLEX #C(<x> <y>),
	  then a path of the same length as the sequence is created,
	  with the x and y offsets set to the corresponding <x> <y>.
	
	Note: all <path> arg types other than TANGO_PATH are used here for
	convenience in creating transitions over simple, unique
	paths. "Simple cases" constitute paths which don't need to be be
	re-used, or altered via calls to TANGO:PATH_* functions.

**** TANGO:ELLIPSE_IMAGE_CLASS method :TX_RESIZE (TANGO_TRANS_TYPE_RESIZE):

	(send <t-image-obj> :TX_RESIZE [:PERFORM] [<path>])
		==> returns <tango_trans> object, 
		    or NIL if :PERFORM keyword given.
	
	The RESIZE transition resizes the given <t-image-obj> along the given
	<path>. TANGO:ELLIPSE_IMAGE_CLASS instances are resized by adding the
	<x> part of <path> value to the ellipse's <x> radius and the <y> part
	of <path> to the <y> radius.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	The [<path>] argument is optional, and may be of multiple types:
	* if the <path> argument is omitted, then a path of length one with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type TANGO_PATH, then that is used as the path
	  for the transition to take. TANGO:PATH_CREATE, and other
	  TANGO:PATH_* functions return such TANGO_PATH typed results;
	* else, if <path> is of type FIXNUM, then a path of length <path> with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type COMPLEX (e.g. #C(<x> <y>), then a path of
	  length one is used with x and y offsets set to <x> and <y>.
	* else, if <path> is a sequence (LIST or ARRAY) of COMPLEX #C(<x> <y>),
	  then a path of the same length as the sequence is created,
	  with the x and y offsets set to the corresponding <x> <y>.
	
	Note: all <path> arg types other than TANGO_PATH are used here for
	convenience in creating transitions over simple, unique
	paths. "Simple cases" constitute paths which don't need to be be
	re-used, or altered via calls to TANGO:PATH_* functions.

*** TANGO:GIF_IMAGE_CLASS (TANGO_IMAGE_TYPE_PIXMAP):

**** TANGO:GIF_IMAGE_CLASS method :NEW/:ISNEW (TANGOimage_create()):

	(send TANGO:GIF_IMAGE_CLASS :new
	      [:show] [<visible_kwd>] <tango_widget>
	      <location_coord>
	      <gif_file_name>
	      [:VERBOSE|:NOVERBOSE]
	      )
		==> RETURNS an <tango_image> object.
	
	[:show] -- OPTIONAL :show keyword. If present, displays image
	immediately, else the image will be displayed along with the next
	animation frame. See :TAP_SHOW :TX_DELAY.
	
	[<visible_kwd>] -- OPTIONAL :VISIBLE or :INVISIBLE keyword. If
	omitted, :VISIBLE is assumed. See also :TX_VISIBLE, :TAP_VIS_TOGGLE.
	
	<tango_widget> -- an instance of TANGO:WIDGET_CLASS.
	
	<location_coord> -- the location for placing the image. A
	COMPLEX number, of form #C(<loc_x> <loc_y>), where <loc_x> is a
	FLONUM, typically [0.0 - 1.0] representing the X-axis location;
	<loc_y> is a FLONUM, typically [0.0 - 1.0] representing the Y-axis
	location. See <<TANGO Locations and Coordinates (TANGO_LOC):>>
	section above.

	<gif_file_name> -- a STRING, the full path to the GIF file.

	[:VERBOSE|:NOVERBOSE] -- optional keyword. If :NOVERBOSE or
	no argument passed, information on the GIF is not printed.
	If :VERBOSE argument passed, then information on the size of
	the GIF, number of colors allocated exactly and number of colors
	approximated, is printed to stdout.

	Note: GIF colormaps are allocated exactly if your global colormap has
	enough free colors. If not, then it attempts to substitute the
	closest fit of colors from the global colormap.  For the applications
	the author has considered, it was decided not to allocate a private
	colormap for GIF images so that exact colors could be achieved on an
	8 bit system. This is because the GIF image is just one image among
	many other tango images and Motif widgets that need to share a
	colormap. For such situations, having the system colors go
	"technicolor" in order to display GIF colors exactly was deemed
	inappropriate... (Yes, there are solutions for this, but at the
	current time, they are not portable across platforms).
	
	Automatic memory/resource management note: colors allocated for a
	particular GIF image are deallocated when the GIF image is
	:TX_DELETE'd or when the TANGO:WIDGET_CLASS instance displaying the
	GIF image gets destroyed. Likewise, the GIF data is also destroyed.
	If you are running out of colors, you may find that you can reclaim
	colors by explicitly destroying the image and forcing a garbage
	collect. Likewise, if you are running out of client-side or
	server-side memory, you will aslo want to destroy uneeded images.
	Here's what you need to do:
		(send <gif-image> :tx_delete :perform)
		(gc)

**** TANGO:GIF_IMAGE_CLASS method :STOREON

	TODO: This method still needs to be implemented! (Sorry...)

**** TANGO:GIF_IMAGE_CLASS method :IMAGE_LOC (TANGOimage_loc()):

	(send <tiobj> :IMAGE_LOC <image_part_kwd>)
		==> returns a COMPLEX number #C(<x> <y>), where <x> and <y>
		    are FLONUMS representing the location of the image
	
		<image_part_kwd> is a keyword argument, one of:
			:CTR	-- center
			:NW	-- north west
			:NE	-- north east
			:E	-- east
			:SE	-- south east
			:S	-- south
			:SW     -- south west
			:W      -- west
	
	This routine returns a COMPLEX FLONUM #C(<x> <y>) that corresponds to
	the location of the given <image_part_kwd> of the given <tiobj>.

	Valid <image_part_kwd> include :CTR (center), and the compass
	directions :NW, :N, :NE, :E, :SE, :S, :SW, :W.  Given that the
	GIF is a rectangular image, the locations specified by
	<image_part_kwd> represent the actual boundaries of the image.

*** TANGO:LINE_IMAGE_CLASS (TANGO_IMAGE_TYPE_LINE):

**** TANGO:LINE_IMAGE_CLASS method :NEW/:ISNEW (TANGOimage_create()):

	(send TANGO:LINE_IMAGE_CLASS :new
	      [:show] [<visible_kwd>] <tango_widget>
	      <location_coord>
	      <size_coord>
	      <tango_color>
	      <line_width_float>
	      <line_style>
	      <arrow_kwd>)
		==> RETURNS an <tango_image> object.
	
	[:show] -- OPTIONAL :show keyword. If present, displays image
	immediately, else the image will be displayed along with the next
	animation frame. See :TAP_SHOW :TX_DELAY.
	
	[<visible_kwd>] -- OPTIONAL :VISIBLE or :INVISIBLE keyword. If
	omitted, :VISIBLE is assumed. See also :TX_VISIBLE, :TAP_VIS_TOGGLE.
	
	<tango_widget> -- an instance of TANGO:WIDGET_CLASS.
	
	<location_coord> -- the location for placing the image. A
	COMPLEX number, of form #C(<loc_x> <loc_y>), where <loc_x> is a
	FLONUM, typically [0.0 - 1.0] representing the X-axis location;
	<loc_y> is a FLONUM, typically [0.0 - 1.0] representing the Y-axis
	location. See <<TANGO Locations and Coordinates (TANGO_LOC):>>
	section above.

	<size_coord> -- a COMPLEX number of form #C(<size-x> #<size-y>)
	where <size-x> represents the x-offset and <size-y> represents
	the y-offset of line/arrow destination; the source being at
	<location_coor>. Line sizes can be either positive or negative.

	<tango_color> -- The color of the image; it can either be a string
	color name, or a FIXNUM representing the tango pixel value. If given
	a string, it is looked up in the X11 file /usr/lib/X11/rgb.txt.  See
	<<TANGO Colors (TANGO_COLOR):>> section above for details.

	<line_width_float> -- defines the width of the line; it can range
	from 0.0 to 1.0 (corresponding roughly to percentages).  0.0
	corresponds to a thin line, and 1.0 corresponds to the thickest line.
	Currently, we have implemented three thicknesses that are achieved by
	values in the range 0.0 to 0.333, 0.333 to 0.667, and 0.667 to 1.0,
	respectively.

	<line_style> -- defines the line's style.  It ranges from 0.0 to 1.0
	also.  We have implemented three styles: 0.0 to 0.333 defines a dotted
	line, 0.333 to 0.667 defines a dashed line, and 0.667 to 1.0 defines a
	solid line.

	<arrow_kwd> -- one of the following keywords :NO_ARROW, :FORW_ARROW,
	:BACK_ARROW, or :BOTH_ARROW .

**** TANGO:LINE_IMAGE_CLASS method :STOREON

	(send <line-image> :STOREON)
		==> returns list
		  (send TANGO:LINE_IMAGE_CLASS :new <visibility_kwd>
			*TANGO_WIDGET*
			#C(<location-x> <location-y)
			#C(<size-x> <size-y>)
			<tango_color>
			<line_width_float>
			<line_style>
			<arrow-kwd>)

	See <<TANGO:LINE_IMAGE_CLASS method :NEW/:ISNEW...>>
	for details on the returned data.
	
	Evaluating the results of this method will create a copy of the given
	image at a later time. Printing the results of this method to a file
	enables one to store a persistent copy of the given image to
	disk. See also TANGO:WIDGET_CLASS method :GET_IMAGES and
	:COLORS_STOREON.

**** TANGO:LINE_IMAGE_CLASS method :IMAGE_LOC (TANGOimage_loc()):

	(send <tiobj> :IMAGE_LOC <image_part_kwd>)
		==> returns a COMPLEX number #C(<x> <y>), where <x> and <y>
		    are FLONUMS representing the location of the image
	
		<image_part_kwd> is a keyword argument, one of:
			:CTR	-- center
			:NW	-- north west
			:NE	-- north east
			:E	-- east
			:SE	-- south east
			:S	-- south
			:SW     -- south west
			:W      -- west
	
	This routine returns a COMPLEX FLONUM #C(<x> <y>) that corresponds to
	the location of the given <image_part_kwd> of the given <tiobj>.

	Valid <image_part_kwd> include :CTR (center), and the compass
	directions :NW, :N, :NE, :E, :SE, :S, :SW, :W. These
	represent locations on the bounding box of the line.

**** TANGO:LINE_IMAGE_CLASS method :TX_COLOR (TANGO_TRANS_TYPE_COLOR):

	(send <t-image-obj> :TX_COLOR [:PERFORM] [<path>])
		==> returns <tango_trans> object, 
		    or NIL if :PERFORM keyword given.
	
	The COLOR transition changes the given <t-image-obj> to the color
	indicated by the given <path>.  See the routine TANGO:PATH_COLOR to
	create a special path which will change the image to a certain
	color. Using an arbitrary TANGO_PATH type argument, or using one of
	the other alternatives for the <path> argument list (as used
	in other :TX_* methods) will generate undefined results.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.

**** TANGO:LINE_IMAGE_CLASS method :TX_FILL (TANGO_TRANS_TYPE_FILL):

	(send <t-image-obj> :TX_FILL [:PERFORM] [<path>])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.

	The FILL transition changes the "fill" component of the given image
	<t-image-obj>. For line images, this method takes the <x> value of each
	offset in <path> and adds it to the line's <width> parameter value;
	the <y> value is added to the line's <style> parameter value (see
	<<TANGO:LINE_IMAGE_CLASS method :NEW (TANGOimage_create()):>> for
	information on <line_width_float> and <line_style>.  Extreme values
	are reset to 0.0 and 1.0 as in rectangles and circles.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	The [<path>] argument is optional, and may be of multiple types:
	* if the <path> argument is omitted, then a path of length one with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type TANGO_PATH, then that is used as the path
	  for the transition to take. TANGO:PATH_CREATE, and other
	  TANGO:PATH_* functions return such TANGO_PATH typed results;
	* else, if <path> is of type FIXNUM, then a path of length <path> with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type COMPLEX (e.g. #C(<x> <y>), then a path of
	  length one is used with x and y offsets set to <x> and <y>.
	* else, if <path> is a sequence (LIST or ARRAY) of COMPLEX #C(<x> <y>),
	  then a path of the same length as the sequence is created,
	  with the x and y offsets set to the corresponding <x> <y>.
	
	Note: all <path> arg types other than TANGO_PATH are used here for
	convenience in creating transitions over simple, unique
	paths. "Simple cases" constitute paths which don't need to be be
	re-used, or altered via calls to TANGO:PATH_* functions.

**** TANGO:LINE_IMAGE_CLASS method :TX_RESIZE (TANGO_TRANS_TYPE_RESIZE):

	(send <t-image-obj> :TX_RESIZE [:PERFORM] [<path>])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.

	The RESIZE transition resizes the given <t-image-obj> along the given
	<path>. For TANGO:LINE_IMAGE_CLASS instances the path elements can
	have positive or negative sizes; Line images are resized by altering
	the line's size for each offset in the path.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	The [<path>] argument is optional, and may be of multiple types:
	* if the <path> argument is omitted, then a path of length one with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type TANGO_PATH, then that is used as the path
	  for the transition to take. TANGO:PATH_CREATE, and other
	  TANGO:PATH_* functions return such TANGO_PATH typed results;
	* else, if <path> is of type FIXNUM, then a path of length <path> with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type COMPLEX (e.g. #C(<x> <y>), then a path of
	  length one is used with x and y offsets set to <x> and <y>.
	* else, if <path> is a sequence (LIST or ARRAY) of COMPLEX #C(<x> <y>),
	  then a path of the same length as the sequence is created,
	  with the x and y offsets set to the corresponding <x> <y>.
	
	Note: all <path> arg types other than TANGO_PATH are used here for
	convenience in creating transitions over simple, unique
	paths. "Simple cases" constitute paths which don't need to be be
	re-used, or altered via calls to TANGO:PATH_* functions.

*** TANGO:POLYGON_IMAGE_CLASS (TANGO_IMAGE_TYPE_POLYGON):

**** TANGO:POLYGON_IMAGE_CLASS method :NEW/:ISNEW (TANGOimage_create()):

	(send TANGO:POLYGON_IMAGE_CLASS :new
	      [:show] [<visible_kwd>] <tango_widget>
	      <location_coord>
	      <vertex-offset-coord-0>
	      [<vertex-offset-coord-1> [<vertex-offset-coord-2>
				       ...
				       [<vertex-offset-coord-N>]]]
	      <tango_color>
	      <fill_float>)
		==> RETURNS an <tango_image> object.
	
	[:show] -- OPTIONAL :show keyword. If present, displays image
	immediately, else the image will be displayed along with the next
	animation frame. See :TAP_SHOW :TX_DELAY.
	
	[<visible_kwd>] -- OPTIONAL :VISIBLE or :INVISIBLE keyword. If
	omitted, :VISIBLE is assumed. See also :TX_VISIBLE, :TAP_VIS_TOGGLE.
	
	<tango_widget> -- an instance of TANGO:WIDGET_CLASS.
	
	<location_coord> -- the location for placing the image. A
	COMPLEX number, of form #C(<loc_x> <loc_y>), where <loc_x> is a
	FLONUM, typically [0.0 - 1.0] representing the X-axis location;
	<loc_y> is a FLONUM, typically [0.0 - 1.0] representing the Y-axis
	location. See <<TANGO Locations and Coordinates (TANGO_LOC):>>
	section above.

	<vertex-offset-coord-N> -- for i=0 to 6, this represents a COMPLEX
	number of form #C(<offset-x> #<offset-y>) where <offset-x> represents
	the x-offset and <offset-y> represents the y-offset of the polygon
	vertex from its <location_coor>. These offsets can be either
	positive or negative. Xtango polygon images support polygons with
	eight or less sides.  Therefore the sequence of offsets must be <= 7
	elements -- the first vertex is implicity <0,0> and is not to be
	included in the sequence.

	<tango_color> -- The color of the image; it can either be a string
	color name, or a FIXNUM representing the tango pixel value. If given
	a string, it is looked up in the X11 file /usr/lib/X11/rgb.txt.  See
	<<TANGO Colors (TANGO_COLOR):>> section above for details.

	<fill_float> -- the fill value of the image, a FLONUM between 0.0 and
	1.0. 0.0 corresponds to an unfilled outline and 1.0 corresponds to
	100 per cent fill in the given color.  (Forty graduated fill styles
	are actually implemented.)

**** TANGO:POLYGON_IMAGE_CLASS method :STOREON

	(send <tango_polygon_image> :STOREON)
		==> returns list
		  (send TANGO:POLYGON_IMAGE_CLASS :new <visibility_kwd>
			*TANGO_WIDGET*
			<location_coord>
			<vertex-offset-coord-0>
			[<vertex-offset-coord-1> [<vertex-offset-coord-2>
						 ...
						 [<vertex-offset-coord-N>]]]
			<tango_color>
			<fill_float>)

	See <<TANGO:POLYGON_IMAGE_CLASS method :NEW/:ISNEW...>>
	for details on the returned data.
	
	Evaluating the results of this method will create a copy of the given
	image at a later time. Printing the results of this method to a file
	enables one to store a persistent copy of the given image to
	disk. See also TANGO:WIDGET_CLASS method :GET_IMAGES and
	:COLORS_STOREON.

**** TANGO:POLYGON_IMAGE_CLASS method :IMAGE_LOC (TANGOimage_loc()):

	(send <tango_polygon_image> :IMAGE_LOC <image_part>)
		==> returns a COMPLEX number #C(<x> <y>), where <x> and 
		    <y> are FLONUMS representing the location of the image.

	<image_part> is either a KEYWORD SYMBOL or FIXNUM [0-7]
		0	-- the "location", aka, the 0th vertex.
		1	-- the 1st vertex
		...        ...
		7	-- the 7th vertex
	
		:CTR	-- center
		:NW	-- north west
		:NE	-- north east
		:E	-- east
		:SE	-- south east
		:S	-- south
		:SW     -- south west
		:W      -- west
	
	This routine returns a COMPLEX FLONUM #C(<x> <y>) that corresponds to
	the location of the given <image_part> of the given
	<tango_polygon_image>.  Valid <image_part> include :CTR (center),
	and the compass directions :NW, :N, :NE, :E, :SE, :S, :SW, :W. These
	locations represent points on the bounding box of the polygon. If
	<image_part> is a FIXNUM [0..7], then the location returned is the
	actual location of the vertex, where vertex 0 is <location_coord> and
	vertex 1 thru 7 represent the locations of the other vertices.

**** TANGO:POLYGON_IMAGE_CLASS method :TX_COLOR (TANGO_TRANS_TYPE_COLOR):

	(send <t-image-obj> :TX_COLOR [:PERFORM] [<path>])
		==> returns <tango_trans> object, 
		    or NIL if :PERFORM keyword given.
	
	The COLOR transition changes the given <t-image-obj> to the color
	indicated by the given <path>.  See the routine TANGO:PATH_COLOR to
	create a special path which will change the image to a certain
	color. Using an arbitrary TANGO_PATH type argument, or using one of
	the other alternatives for the <path> argument list (as used
	in other :TX_* methods) will generate undefined results.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.

**** TANGO:POLYGON_IMAGE_CLASS method :TX_FILL (TANGO_TRANS_TYPE_FILL):

	(send <t-image-obj> :TX_FILL [:PERFORM] [<path>])
		==> returns <tango_trans> object, 
		    or NIL if :PERFORM keyword given.
	
	The FILL transition changes the "fill" component of the given image
	<t-image-obj>. This transition alters the image's fill style value by
	the <x> value of the offsets in <path>.  The <x> value is simply
	added to the existing fill value of <t-image-obj>, the <y> value is
	ignored.  If the image's fill value goes below 0.0, it is
	automatically set back to 0.0.  If it goes above 1.0, it is set back
	to 1.0.  Actually, the full range of values between 0.0 and 1.0 is
	not available.  We currently implement 40 different fills that range
	between the two extremes.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	The [<path>] argument is optional, and may be of multiple types:
	* if the <path> argument is omitted, then a path of length one with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type TANGO_PATH, then that is used as the path
	  for the transition to take. TANGO:PATH_CREATE, and other
	  TANGO:PATH_* functions return such TANGO_PATH typed results;
	* else, if <path> is of type FIXNUM, then a path of length <path> with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type COMPLEX (e.g. #C(<x> <y>), then a path of
	  length one is used with x and y offsets set to <x> and <y>.
	* else, if <path> is a sequence (LIST or ARRAY) of COMPLEX #C(<x> <y>),
	  then a path of the same length as the sequence is created,
	  with the x and y offsets set to the corresponding <x> <y>.
	
	Note: all <path> arg types other than TANGO_PATH are used here for
	convenience in creating transitions over simple, unique
	paths. "Simple cases" constitute paths which don't need to be be
	re-used, or altered via calls to TANGO:PATH_* functions.

**** TANGO:POLYGON_IMAGE_CLASS method :TX_RESIZE[1-7]:

	(send <polygon_image> :TX_RESIZE1 [:PERFORM] [<path>])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.
		.
		.
		.
	(send <polygon_image> :TX_RESIZE7 [:PERFORM] [<path>])
		==> returns <tango_trans> object, 
		    or NIL if :PERFORM keyword given.
	
	The transitions :TX_RESIZE1-:TX_RESIZE7 modify the relative
	positions of the respective vertex number, plus all others after it
	in numerical order, by the relative <x> <y> offsets of <path>.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	The [<path>] argument is optional, and may be of multiple types:
	
	* if the <path> argument is omitted, then a path of length one with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type TANGO_PATH, then that is used as the path
	  for the transition to take. TANGO:PATH_CREATE, and other
	  TANGO:PATH_* functions return such TANGO_PATH typed results;
	* else, if <path> is of type FIXNUM, then a path of length <path> with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type COMPLEX (e.g. #C(<x> <y>), then a path of
	  length one is used with x and y offsets set to <x> and <y>.
	* else, if <path> is a sequence (LIST or ARRAY) of COMPLEX #C(<x> <y>),
	  then a path of the same length as the sequence is created,
	  with the x and y offsets set to the corresponding <x> <y>.
	
	Note: all <path> arg types other than TANGO_PATH are used here for
	convenience in creating transitions over simple, unique
	paths. "Simple cases" constitute paths which don't need to be be
	re-used, or altered via calls to TANGO:PATH_* functions.

**** TANGO:POLYGON_IMAGE_CLASS method :TX_GRAB[1-7]:

	(send <polygon_image> :TX_GRAB1 [:PERFORM] [<path>])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.
		.
		.
		.
	(send <polygon_image> :TX_GRAB7 [:PERFORM] [<path>])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.
	
	The transitions :TX_GRAB1-:TX_GRAB7 modify the relative position of
	a particular vertex on the image (except the one denoting the image's
	position) by the relative offsets of the path.  As opposed to
	:TX_RESIZE[1-7], the transitions :TX_GRAB[1-7] alter only one
	particular vertex in the image's definition. Think of grabbing that
	vertex and swinging it around while all the other points stay anchored.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	The [<path>] argument is optional, and may be of multiple types:
	* if the <path> argument is omitted, then a path of length one with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type TANGO_PATH, then that is used as the path
	  for the transition to take. TANGO:PATH_CREATE, and other
	  TANGO:PATH_* functions return such TANGO_PATH typed results;
	* else, if <path> is of type FIXNUM, then a path of length <path> with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type COMPLEX (e.g. #C(<x> <y>), then a path of
	  length one is used with x and y offsets set to <x> and <y>.
	* else, if <path> is a sequence (LIST or ARRAY) of COMPLEX #C(<x> <y>),
	  then a path of the same length as the sequence is created,
	  with the x and y offsets set to the corresponding <x> <y>.
	
	Note: all <path> arg types other than TANGO_PATH are used here for
	convenience in creating transitions over simple, unique
	paths. "Simple cases" constitute paths which don't need to be be
	re-used, or altered via calls to TANGO:PATH_* functions.

*** TANGO:POLYLINE_IMAGE_CLASS (TANGO_IMAGE_TYPE_POLYLINE):

**** TANGO:POLYLINE_IMAGE_CLASS method :NEW/:ISNEW (TANGOimage_create()):

	(send TANGO:POLYLINE_IMAGE_CLASS :new
	      [:show] [<visible_kwd>] <tango_widget>
	      <location_coord>
	      <vertex-offset-coord-0>
	      [<vertex-offset-coord-1> [<vertex-offset-coord-2>
				       ...
				       [<vertex-offset-coord-N>]]]
	      <tango_color>
	      <line_width_float>
	      <line_style>
	      <arrow_kwd>)
		==> RETURNS an <tango_image> object.
	
	[:show] -- OPTIONAL :show keyword. If present, displays image
	immediately, else the image will be displayed along with the next
	animation frame. See :TAP_SHOW :TX_DELAY.
	
	[<visible_kwd>] -- OPTIONAL :VISIBLE or :INVISIBLE keyword. If
	omitted, :VISIBLE is assumed. See also :TX_VISIBLE, :TAP_VIS_TOGGLE.
	
	<tango_widget> -- an instance of TANGO:WIDGET_CLASS.
	
	<location_coord> -- the location for placing the image. A
	COMPLEX number, of form #C(<loc_x> <loc_y>), where <loc_x> is a
	FLONUM, typically [0.0 - 1.0] representing the X-axis location;
	<loc_y> is a FLONUM, typically [0.0 - 1.0] representing the Y-axis
	location. See <<TANGO Locations and Coordinates (TANGO_LOC):>>
	section above.

	<vertex-offset-coord-N> -- for i=0 to 6, this represents a COMPLEX
	number of form #C(<offset-x> #<offset-y>) where <offset-x> represents
	the x-offset and <offset-y> represents the y-offset of the polyline
	vertex from its <location_coor>. These offsets can be either
	positive or negative. Xtango polyline images support polylines with
	eight or less sides.  Therefore the sequence of offsets must be <= 7
	elements -- the first vertex is implicity <0,0> and is not to be
	included in the sequence.

	<tango_color> -- The color of the image; it can either be a string
	color name, or a FIXNUM representing the tango pixel value. If given
	a string, it is looked up in the X11 file /usr/lib/X11/rgb.txt.  See
	<<TANGO Colors (TANGO_COLOR):>> section above for details.

	<line_width_float> -- defines the width of the polyline; it can range
	from 0.0 to 1.0 (corresponding roughly to percentages).  0.0
	corresponds to a thin line, and 1.0 corresponds to the thickest line.
	Currently, we have implemented three thicknesses that are achieved by
	values in the range 0.0 to 0.333, 0.333 to 0.667, and 0.667 to 1.0,
	respectively.

	<line_style> -- defines the line's style.  It ranges from 0.0 to 1.0
	also.  We have implemented three styles: 0.0 to 0.333 defines a dotted
	line, 0.333 to 0.667 defines a dashed line, and 0.667 to 1.0 defines a
	solid line.

	<arrow_kwd> -- one of the following keywords :NO_ARROW, :FORW_ARROW,
	:BACK_ARROW, or :BOTH_ARROW .

**** TANGO:POLYLINE_IMAGE_CLASS method :STOREON

	(send <tango_polyline_image> :STOREON)
		==> returns list
		  (send TANGO:POLYLINE_IMAGE_CLASS :new <visibility_kwd>
			*TANGO_WIDGET*
			<location_coord>
			<vertex-offset-coord-0>
			[<vertex-offset-coord-1> [<vertex-offset-coord-2>
						 ...
						 [<vertex-offset-coord-N>]]]
			<tango_color>
			<line_width_float>
			<line_style>
			<arrow_kwd>)

	See <<TANGO:POLYLINE_IMAGE_CLASS method :NEW/:ISNEW...>>
	for details on the returned data.
	
	Evaluating the results of this method will create a copy of the given
	image at a later time. Printing the results of this method to a file
	enables one to store a persistent copy of the given image to
	disk. See also TANGO:WIDGET_CLASS method :GET_IMAGES and
	:COLORS_STOREON.

**** TANGO:POLYLINE_IMAGE_CLASS method :IMAGE_LOC (TANGOimage_loc()):

	(send <tango_polyline_image> :IMAGE_LOC <image_part>)
		==> returns a COMPLEX number #C(<x> <y>), where <x> and <y>
		    are FLONUMS representing the location of the image.
	
	<image_part> is either a KEYWORD SYMBOL or FIXNUM [0-7]
		0	-- the "location", aka, the 0th vertex.
		1	-- the 1st vertex
		...        ...
		7	-- the 7th vertex
	
		:CTR	-- center
		:NW	-- north west
		:NE	-- north east
		:E	-- east
		:SE	-- south east
		:S	-- south
		:SW     -- south west
		:W      -- west
	
	This routine returns a COMPLEX FLONUM #C(<x> <y>) that corresponds to
	the location of the given <image_part> of the given
	<tango_polyline_image>.  Valid <image_part> include :CTR (center),
	and the compass directions :NW, :N, :NE, :E, :SE, :S, :SW, :W. These
	locations represent points on the bounding box of the polyline. If
	<image_part> is a FIXNUM [0..7], then the location returned is the
	actual location of the vertex, where vertex 0 is <location_coord> and
	vertex 1 thru 7 represent the locations of the other vertices.

**** TANGO:POLYLINE_IMAGE_CLASS method :TX_COLOR (TANGO_TRANS_TYPE_COLOR):

	(send <t-image-obj> :TX_COLOR [:PERFORM] [<path>])
		==> returns <tango_trans> object, 
		    or NIL if :PERFORM keyword given.
	
	The COLOR transition changes the given <t-image-obj> to the color
	indicated by the given <path>.  See the routine TANGO:PATH_COLOR to
	create a special path which will change the image to a certain
	color. Using an arbitrary TANGO_PATH type argument, or using one of
	the other alternatives for the <path> argument list (as used
	in other :TX_* methods) will generate undefined results.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.

**** TANGO:POLYLINE_IMAGE_CLASS method :TX_FILL (TANGO_TRANS_TYPE_FILL):

	(send <t-image-obj> :TX_FILL [:PERFORM] [<path>])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.

	The FILL transition changes the "fill" component of the given image
	<t-image-obj>. For polyline images, this method takes the <x> value of
	each offset in <path> and adds it to the polyline's <line_width_float>
	parameter value; the <y> value is added to the polyline's <line_style>
	parameter value (see
	<<TANGO:POLYLINE_IMAGE_CLASS method :NEW (TANGOimage_create()):>>
	for information on <line_width_float> and <line_style>.  Extreme
	values are reset to 0.0 and 1.0 as in rectangles and circles.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	The [<path>] argument is optional, and may be of multiple types:
	* if the <path> argument is omitted, then a path of length one with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type TANGO_PATH, then that is used as the path
	  for the transition to take. TANGO:PATH_CREATE, and other
	  TANGO:PATH_* functions return such TANGO_PATH typed results;
	* else, if <path> is of type FIXNUM, then a path of length <path> with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type COMPLEX (e.g. #C(<x> <y>), then a path of
	  length one is used with x and y offsets set to <x> and <y>.
	* else, if <path> is a sequence (LIST or ARRAY) of COMPLEX #C(<x> <y>),
	  then a path of the same length as the sequence is created,
	  with the x and y offsets set to the corresponding <x> <y>.
	
	Note: all <path> arg types other than TANGO_PATH are used here for
	convenience in creating transitions over simple, unique
	paths. "Simple cases" constitute paths which don't need to be be
	re-used, or altered via calls to TANGO:PATH_* functions.

**** TANGO:POLYLINE_IMAGE_CLASS method :TX_RESIZE[1-7]:

	(send <polyline_image> :TX_RESIZE1 [:PERFORM] [<path>])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.
		.
		.
		.
	(send <polyline_image> :TX_RESIZE7 [:PERFORM] [<path>])
		==> returns <tango_trans> object, 
		    or NIL if :PERFORM keyword given.
	
	The transitions :TX_RESIZE1-:TX_RESIZE7 modify the relative
	positions of the respective vertex number, plus all others after it
	in numerical order, by the relative <x> <y> offsets of <path>.
	These transitions are useful, for example, with a forward arrow
	polyline that has many of its edges compressed down to start.
	They can subsequently be grown out in all different directions, one
	at a time.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	The [<path>] argument is optional, and may be of multiple types:
	
	* if the <path> argument is omitted, then a path of length one with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type TANGO_PATH, then that is used as the path
	  for the transition to take. TANGO:PATH_CREATE, and other
	  TANGO:PATH_* functions return such TANGO_PATH typed results;
	* else, if <path> is of type FIXNUM, then a path of length <path> with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type COMPLEX (e.g. #C(<x> <y>), then a path of
	  length one is used with x and y offsets set to <x> and <y>.
	* else, if <path> is a sequence (LIST or ARRAY) of COMPLEX #C(<x> <y>),
	  then a path of the same length as the sequence is created,
	  with the x and y offsets set to the corresponding <x> <y>.
	
	Note: all <path> arg types other than TANGO_PATH are used here for
	convenience in creating transitions over simple, unique
	paths. "Simple cases" constitute paths which don't need to be be
	re-used, or altered via calls to TANGO:PATH_* functions.

**** TANGO:POLYLINE_IMAGE_CLASS method :TX_GRAB[1-7]:

	(send <polyline_image> :TX_GRAB1 [:PERFORM] [<path>])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.
		.
		.
		.
	(send <polyline_image> :TX_GRAB7 [:PERFORM] [<path>])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.
	
	The transitions :TX_GRAB1-:TX_GRAB7 modify the relative position of
	a particular vertex on the image (except the one denoting the image's
	position) by the relative offsets of the path.  As opposed to
	:TX_RESIZE[1-7], the transitions :TX_GRAB[1-7] alter only one
	particular vertex in the image's definition. Think of grabbing that
	vertex and swinging it around while all the other points stay anchored.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	The [<path>] argument is optional, and may be of multiple types:
	* if the <path> argument is omitted, then a path of length one with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type TANGO_PATH, then that is used as the path
	  for the transition to take. TANGO:PATH_CREATE, and other
	  TANGO:PATH_* functions return such TANGO_PATH typed results;
	* else, if <path> is of type FIXNUM, then a path of length <path> with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type COMPLEX (e.g. #C(<x> <y>), then a path of
	  length one is used with x and y offsets set to <x> and <y>.
	* else, if <path> is a sequence (LIST or ARRAY) of COMPLEX #C(<x> <y>),
	  then a path of the same length as the sequence is created,
	  with the x and y offsets set to the corresponding <x> <y>.
	
	Note: all <path> arg types other than TANGO_PATH are used here for
	convenience in creating transitions over simple, unique
	paths. "Simple cases" constitute paths which don't need to be be
	re-used, or altered via calls to TANGO:PATH_* functions.

*** TANGO:RECTANGLE_IMAGE_CLASS (TANGO_IMAGE_TYPE_RECTANGLE):

**** TANGO:RECTANGLE_IMAGE_CLASS method :NEW/:ISNEW (TANGOimage_create()):

	(send TANGO:RECTANGLE_IMAGE_CLASS :new
	      [:show] [<visible_kwd>] <tango_widget>
	      <location_coord>
	      <size_coord>
	      <tango_color>
	      <fill_float>
	      )
		==> RETURNS an <tango_image> object.
	
	[:show] -- OPTIONAL :show keyword. If present, displays image
	immediately, else the image will be displayed along with the next
	animation frame. See :TAP_SHOW :TX_DELAY.
	
	[<visible_kwd>] -- OPTIONAL :VISIBLE or :INVISIBLE keyword. If
	omitted, :VISIBLE is assumed. See also :TX_VISIBLE, :TAP_VIS_TOGGLE.
	
	<tango_widget> -- an instance of TANGO:WIDGET_CLASS.
	
	<location_coord> -- the location for placing the rectangle
	image, corresponds to the upper left corner. <location_coord> is
	COMPLEX number, of form #C(<loc_x> <loc_y>), where <loc_x> is a
	FLONUM, typically [0.0 - 1.0] representing the X-axis location;
	<loc_y> is a FLONUM, typically [0.0 - 1.0] representing the Y-axis
	location. See <<TANGO Locations and Coordinates (TANGO_LOC):>>
	section above.
	
	<size_coord> -- The size of the rectangle image, a COMPLEX number of
	form #C(<size_x> <size_y>), where <size_x> is a FLONUM, typically
	[0.0 - 1.0] representing the X-axis size; <size_y> is a FLONUM,
	typically [0.0 - 1.0] representing the Y-axis size. 
		
	<tango_color> -- The color of the image; it can either be a string
	color name, or a FIXNUM representing the tango pixel value. If given
	a string, it is looked up in the X11 file /usr/lib/X11/rgb.txt.  See
	<<TANGO Colors (TANGO_COLOR):>> section above for details.
	
	<fill_float> -- the fill value of the image, a FLONUM between 0.0 and
	1.0. 0.0 corresponds to an unfilled outline and 1.0 corresponds to
	100 per cent fill in the given color.  (Forty graduated fill styles
	are actually implemented.)

**** TANGO:RECTANGLE_IMAGE_CLASS method :STOREON

	(send <rectangle-image> :STOREON)
		==> returns list
		  (send TANGO:RECTANGLE_IMAGE_CLASS :new <visibility_kwd>
			*TANGO_WIDGET*
			#C(<location-x> <location-y)
			#C(<size-x> <size-y>)
			<tango_color>
			<fill_float>)

	See <<TANGO:RECTANGE_IMAGE_CLASS method :NEW/:ISNEW...>>
	for details on the returned data.
	
	Evaluating the results of this method will create a copy of the given
	image at a later time. Printing the results of this method to a file
	enables one to store a persistent copy of the given image to
	disk. See also TANGO:WIDGET_CLASS method :GET_IMAGES and
	:COLORS_STOREON.

**** TANGO:RECTANGLE_IMAGE_CLASS method :IMAGE_LOC (TANGOimage_loc()):

	(send <tiobj> :IMAGE_LOC <image_part_kwd>)
		==> returns a COMPLEX number #C(<x> <y>), where <x> and <y>
		    are FLONUMS representing the location of the image
	
		<image_part_kwd> is a keyword argument, one of:
			:CTR	-- center
			:NW	-- north west
			:NE	-- north east
			:E	-- east
			:SE	-- south east
			:S	-- south
			:SW     -- south west
			:W      -- west
	
	This routine returns a COMPLEX FLONUM #C(<x> <y>) that corresponds to
	the location of the given <image_part_kwd> of the given <tiobj>.

	Valid <image_part_kwd> include :CTR (center), and the compass
	directions :NW, :N, :NE, :E, :SE, :S, :SW, :W.  These
	locations represent the actual boundaries of the rectangle.

**** TANGO:POLYLINE_IMAGE_CLASS method :TX_COLOR (TANGO_TRANS_TYPE_COLOR):

	(send <t-image-obj> :TX_COLOR [:PERFORM] [<path>])
		==> returns <tango_trans> object, 
		    or NIL if :PERFORM keyword given.
	
	The COLOR transition changes the given <t-image-obj> to the color
	indicated by the given <path>.  See the routine TANGO:PATH_COLOR to
	create a special path which will change the image to a certain
	color. Using an arbitrary TANGO_PATH type argument, or using one of
	the other alternatives for the <path> argument list (as used
	in other :TX_* methods) will generate undefined results.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.

**** TANGO:RECTANGLE_IMAGE_CLASS method :TX_FILL (TANGO_TRANS_TYPE_FILL):

	(send <t-image-obj> :TX_FILL [:PERFORM] [<path>])
		==> returns <tango_trans> object, 
		    or NIL if :PERFORM keyword given.
	
	The FILL transition changes the "fill" component of the given image
	<t-image-obj>. This transition alters the image's fill style value by
	the <x> value of the offsets in <path>.  The <x> value is simply
	added to the existing fill value of <t-image-obj>, the <y> value is
	ignored.  If the image's fill value goes below 0.0, it is
	automatically set back to 0.0.  If it goes above 1.0, it is set back
	to 1.0.  Actually, the full range of values between 0.0 and 1.0 is
	not available.  We currently implement 40 different fills that range
	between the two extremes.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	The [<path>] argument is optional, and may be of multiple types:
	* if the <path> argument is omitted, then a path of length one with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type TANGO_PATH, then that is used as the path
	  for the transition to take. TANGO:PATH_CREATE, and other
	  TANGO:PATH_* functions return such TANGO_PATH typed results;
	* else, if <path> is of type FIXNUM, then a path of length <path> with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type COMPLEX (e.g. #C(<x> <y>), then a path of
	  length one is used with x and y offsets set to <x> and <y>.
	* else, if <path> is a sequence (LIST or ARRAY) of COMPLEX #C(<x> <y>),
	  then a path of the same length as the sequence is created,
	  with the x and y offsets set to the corresponding <x> <y>.
	
	Note: all <path> arg types other than TANGO_PATH are used here for
	convenience in creating transitions over simple, unique
	paths. "Simple cases" constitute paths which don't need to be be
	re-used, or altered via calls to TANGO:PATH_* functions.

**** TANGO:RECTANGLE_IMAGE_CLASS method :TX_RESIZE (TANGO_TRANS_TYPE_RESIZE):

	(send <t-image-obj> :TX_RESIZE [:PERFORM] [<path>])
		==> returns <tango_trans> object, 
		    or NIL if :PERFORM keyword given.
	
	The RESIZE transition resizes the given <t-image-obj> along the given
	<path>. TANGO:RECTANGLE_IMAGE_CLASS instances are resized by adding the
	<x> part of <path> value to the rectangle's <x> size and the <y> part
	of <path> to the <y> size. Rectangles can have only positive sizes,
	so resizing a rectangle corresponds to "dragging" the lower right
	corner of the rectangle along the given path. If one of the rectangle's
	dimensions would become negative, it is set to 0.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	The [<path>] argument is optional, and may be of multiple types:
	* if the <path> argument is omitted, then a path of length one with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type TANGO_PATH, then that is used as the path
	  for the transition to take. TANGO:PATH_CREATE, and other
	  TANGO:PATH_* functions return such TANGO_PATH typed results;
	* else, if <path> is of type FIXNUM, then a path of length <path> with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type COMPLEX (e.g. #C(<x> <y>), then a path of
	  length one is used with x and y offsets set to <x> and <y>.
	* else, if <path> is a sequence (LIST or ARRAY) of COMPLEX #C(<x> <y>),
	  then a path of the same length as the sequence is created,
	  with the x and y offsets set to the corresponding <x> <y>.
	
	Note: all <path> arg types other than TANGO_PATH are used here for
	convenience in creating transitions over simple, unique
	paths. "Simple cases" constitute paths which don't need to be be
	re-used, or altered via calls to TANGO:PATH_* functions.

*** TANGO:SPLINE_IMAGE_CLASS (TANGO_IMAGE_TYPE_SPLINE):

**** TANGO:SPLINE_IMAGE_CLASS method :NEW/:ISNEW (TANGOimage_create()):

	(send TANGO:SPLINE_IMAGE_CLASS :new
	      [:show] [<visible_kwd>] <tango_widget>
	      <location_coord>
	      <vertex-offset-coord-0>
	      [<vertex-offset-coord-1> [<vertex-offset-coord-2>
				       ...
				       [<vertex-offset-coord-N>]]]
	      <tango_color>
	      <line_width_float>
	      <line_style>
	      )
		==> RETURNS an <tango_image> object.
	
	[:show] -- OPTIONAL :show keyword. If present, displays image
	immediately, else the image will be displayed along with the next
	animation frame. See :TAP_SHOW :TX_DELAY.
	
	[<visible_kwd>] -- OPTIONAL :VISIBLE or :INVISIBLE keyword. If
	omitted, :VISIBLE is assumed. See also :TX_VISIBLE, :TAP_VIS_TOGGLE.
	
	<tango_widget> -- an instance of TANGO:WIDGET_CLASS.
	
	<location_coord> -- the location for placing the image. A
	COMPLEX number, of form #C(<loc_x> <loc_y>), where <loc_x> is a
	FLONUM, typically [0.0 - 1.0] representing the X-axis location;
	<loc_y> is a FLONUM, typically [0.0 - 1.0] representing the Y-axis
	location. See <<TANGO Locations and Coordinates (TANGO_LOC):>>
	section above.

	<vertex-offset-coord-N> -- for i=0 to 6, this represents a COMPLEX
	number of form #C(<offset-x> #<offset-y>) where <offset-x> represents
	the x-offset and <offset-y> represents the y-offset of the spline
	vertex from its <location_coor>. These offsets can be either
	positive or negative. Xtango spline images support splines with
	eight or less vertices.  Therefore the sequence of offsets must be <= 7
	elements -- the first vertex is implicity <0,0> and is not to be
	included in the sequence.

	<tango_color> -- The color of the image; it can either be a string
	color name, or a FIXNUM representing the tango pixel value. If given
	a string, it is looked up in the X11 file /usr/lib/X11/rgb.txt.  See
	<<TANGO Colors (TANGO_COLOR):>> section above for details.

	<line_width_float> -- defines the width of the spline; it can range
	from 0.0 to 1.0 (corresponding roughly to percentages).  0.0
	corresponds to a thin line, and 1.0 corresponds to the thickest line.
	Currently, we have implemented three thicknesses that are achieved by
	values in the range 0.0 to 0.333, 0.333 to 0.667, and 0.667 to 1.0,
	respectively.

	<line_style> -- defines the line's style.  It ranges from 0.0 to 1.0
	also.  We have implemented three styles: 0.0 to 0.333 defines a dotted
	line, 0.333 to 0.667 defines a dashed line, and 0.667 to 1.0 defines a
	solid line.

**** TANGO:SPLINE_IMAGE_CLASS method :STOREON

	(send <tango_spline_image> :STOREON)
		==> returns list
		  (send TANGO:SPLINE_IMAGE_CLASS :new <visibility_kwd>
			*TANGO_WIDGET*
			<location_coord>
			<vertex-offset-coord-0>
			[<vertex-offset-coord-1> [<vertex-offset-coord-2>
						 ...
						 [<vertex-offset-coord-N>]]]
			<tango_color>
			<line_width_float>
			<line_style>
			)

	See <<TANGO:SPLINE_IMAGE_CLASS method :NEW/:ISNEW...>>
	for details on the returned data.
	
	Evaluating the results of this method will create a copy of the given
	image at a later time. Printing the results of this method to a file
	enables one to store a persistent copy of the given image to
	disk. See also TANGO:WIDGET_CLASS method :GET_IMAGES and
	:COLORS_STOREON.

**** TANGO:SPLINE_IMAGE_CLASS method :IMAGE_LOC (TANGOimage_loc()):

	(send <tango_spline_image> :IMAGE_LOC <image_part>)
		==> returns a COMPLEX number #C(<x> <y>), where <x> and <y>
		    are FLONUMS representing the location of the image.
	
	<image_part> is either a KEYWORD SYMBOL or FIXNUM [0-7]
		0	-- the "location", aka, the 0th vertex.
		1	-- the 1st vertex
		...        ...
		7	-- the 7th vertex
	
		:CTR	-- center
		:NW	-- north west
		:NE	-- north east
		:E	-- east
		:SE	-- south east
		:S	-- south
		:SW     -- south west
		:W      -- west
	
	This routine returns a COMPLEX FLONUM #C(<x> <y>) that corresponds to
	the location of the given <image_part> of the given
	<tango_spline_image>.  Valid <image_part> include :CTR (center),
	and the compass directions :NW, :N, :NE, :E, :SE, :S, :SW, :W. These
	locations represent points on the bounding box of the spline. If
	<image_part> is a FIXNUM [0..7], then the location returned is the
	actual location of the vertex, where vertex 0 is <location_coord> and
	vertex 1 thru 7 represent the locations of the other vertices.

**** TANGO:SPLINE_IMAGE_CLASS method :TX_COLOR (TANGO_TRANS_TYPE_COLOR):

	(send <t-image-obj> :TX_COLOR [:PERFORM] [<path>])
		==> returns <tango_trans> object, 
		    or NIL if :PERFORM keyword given.
	
	The COLOR transition changes the given <t-image-obj> to the color
	indicated by the given <path>.  See the routine TANGO:PATH_COLOR to
	create a special path which will change the image to a certain
	color. Using an arbitrary TANGO_PATH type argument, or using one of
	the other alternatives for the <path> argument list (as used
	in other :TX_* methods) will generate undefined results.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.

**** TANGO:SPLINE_IMAGE_CLASS method :TX_FILL (TANGO_TRANS_TYPE_FILL):

	(send <t-image-obj> :TX_FILL [:PERFORM] [<path>])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.

	The FILL transition changes the "fill" component of the given image
	<t-image-obj>. For spline images, this method takes the <x> value of
	each offset in <path> and adds it to the spline's <line_width_float>
	parameter value; the <y> value is added to the spline's <line_style>
	parameter value
	(see <<TANGO:POLYLINE_IMAGE_CLASS method :NEW (TANGOimage_create()):>>
	for information on <line_width_float> and <line_style>.  Extreme
	values are reset to 0.0 and 1.0 as in rectangles and circles.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	The [<path>] argument is optional, and may be of multiple types:
	* if the <path> argument is omitted, then a path of length one with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type TANGO_PATH, then that is used as the path
	  for the transition to take. TANGO:PATH_CREATE, and other
	  TANGO:PATH_* functions return such TANGO_PATH typed results;
	* else, if <path> is of type FIXNUM, then a path of length <path> with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type COMPLEX (e.g. #C(<x> <y>), then a path of
	  length one is used with x and y offsets set to <x> and <y>.
	* else, if <path> is a sequence (LIST or ARRAY) of COMPLEX #C(<x> <y>),
	  then a path of the same length as the sequence is created,
	  with the x and y offsets set to the corresponding <x> <y>.
	
	Note: all <path> arg types other than TANGO_PATH are used here for
	convenience in creating transitions over simple, unique
	paths. "Simple cases" constitute paths which don't need to be be
	re-used, or altered via calls to TANGO:PATH_* functions.

**** TANGO:SPLINE_IMAGE_CLASS method :TX_RESIZE[1-7]:

	(send <spline_image> :TX_RESIZE1 [:PERFORM] [<path>])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.
		.
		.
		.
	(send <spline_image> :TX_RESIZE7 [:PERFORM] [<path>])
		==> returns <tango_trans> object, 
		    or NIL if :PERFORM keyword given.
	
	The transitions :TX_RESIZE1-:TX_RESIZE7 modify the relative
	positions of the respective vertex number, plus all others after it
	in numerical order, by the relative <x> <y> offsets of <path>.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	The [<path>] argument is optional, and may be of multiple types:
	
	* if the <path> argument is omitted, then a path of length one with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type TANGO_PATH, then that is used as the path
	  for the transition to take. TANGO:PATH_CREATE, and other
	  TANGO:PATH_* functions return such TANGO_PATH typed results;
	* else, if <path> is of type FIXNUM, then a path of length <path> with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type COMPLEX (e.g. #C(<x> <y>), then a path of
	  length one is used with x and y offsets set to <x> and <y>.
	* else, if <path> is a sequence (LIST or ARRAY) of COMPLEX #C(<x> <y>),
	  then a path of the same length as the sequence is created,
	  with the x and y offsets set to the corresponding <x> <y>.
	
	Note: all <path> arg types other than TANGO_PATH are used here for
	convenience in creating transitions over simple, unique
	paths. "Simple cases" constitute paths which don't need to be be
	re-used, or altered via calls to TANGO:PATH_* functions.

**** TANGO:SPLINE_IMAGE_CLASS method :TX_GRAB[1-7]:

	(send <spline_image> :TX_GRAB1 [:PERFORM] [<path>])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.
		.
		.
		.
	(send <spline_image> :TX_GRAB7 [:PERFORM] [<path>])
		==> returns <tango_trans> object,
		    or NIL if :PERFORM keyword given.
	
	The transitions :TX_GRAB1-:TX_GRAB7 modify the relative position of
	a particular vertex on the image (except the one denoting the image's
	position) by the relative offsets of the path.  As opposed to
	:TX_RESIZE[1-7], the transitions :TX_GRAB[1-7] alter only one
	particular vertex in the image's definition. Think of grabbing that
	vertex and swinging it around while all the other points stay anchored.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
	
	The [<path>] argument is optional, and may be of multiple types:
	* if the <path> argument is omitted, then a path of length one with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type TANGO_PATH, then that is used as the path
	  for the transition to take. TANGO:PATH_CREATE, and other
	  TANGO:PATH_* functions return such TANGO_PATH typed results;
	* else, if <path> is of type FIXNUM, then a path of length <path> with
	  both x and y offsets set to 0.0 is used as the path for the
	  transition (see TANGOpath_null() in doc/xtangodoc.tex);
	* else, if <path> is of type COMPLEX (e.g. #C(<x> <y>), then a path of
	  length one is used with x and y offsets set to <x> and <y>.
	* else, if <path> is a sequence (LIST or ARRAY) of COMPLEX #C(<x> <y>),
	  then a path of the same length as the sequence is created,
	  with the x and y offsets set to the corresponding <x> <y>.
	
	Note: all <path> arg types other than TANGO_PATH are used here for
	convenience in creating transitions over simple, unique
	paths. "Simple cases" constitute paths which don't need to be be
	re-used, or altered via calls to TANGO:PATH_* functions.

*** TANGO:TEXT_IMAGE_CLASS (TANGO_IMAGE_TYPE_TEXT):

**** TANGO:TEXT_IMAGE_CLASS method :NEW/:ISNEW (TANGOimage_create()):

	(send TANGO:TEXT_IMAGE_CLASS :new
	      [:show] [<visible_kwd>] <tango_widget>
	      <location_coord> [:CTR]
	      <text_str>
	      <tango_color>
	      <font_str>
	      )
		==> RETURNS an <tango_image> object.

	[:show] -- OPTIONAL :show keyword. If present, displays image
	immediately, else the image will be displayed along with the next
	animation frame. See :TAP_SHOW :TX_DELAY.

	[<visible_kwd>] -- OPTIONAL :VISIBLE or :INVISIBLE keyword. If
	omitted, :VISIBLE is assumed. See also :TX_VISIBLE, :TAP_VIS_TOGGLE.

	<tango_widget> -- an instance of TANGO:WIDGET_CLASS

	<location_coord> -- the location for placing the text image. A
	COMPLEX number, of form #C(<loc_x> <loc_y>), where
	<loc_x> is a FLONUM, typically [0.0 - 1.0] representing the X-axis
	location; <loc_y> is a FLONUM, typically [0.0 - 1.0] representing the
	Y-axis location. See <<TANGO Locations and Coordinates (TANGO_LOC):>>
	section above.

	[:CTR] -- an optional KEYWORD. If this keyword is supplied,
	then <location_coord> above refers to the center of the text image.
	If :CTR keyword not supplied, then <location_coord> refers
	to the lower left corner of the text image.

	<text_string> is the text to be displayed by the the tango image.
	Special characters such as tab, newline, carriage-return, etc
	are rendered by the associated character specified by <font_string>
	rather than tabbing, or starting a new line of text. See
	"note" below for hints on creating multiline text.

	<tango_color> -- The color of the image; it can either be a string
	color name, or a FIXNUM representing the tango pixel value. If given
	a string, it is looked up in the X11 file /usr/lib/X11/rgb.txt.  See
	<<TANGO Colors (TANGO_COLOR):>> section above for details.

	<font_string> a STRING representing the font used for drawing.
	If the value of <font_string> is NIL, then Xtango's default
	font is used.

	NOTE: to display multi-line text, one might consider using function
	below to render the multiline text string <str> via multiple
	text images stored as a composite image containing multiple
	single-line text images. (Probably makes more sense to create
	a new class TANGO:MULTILINE_TEXT_IMAGE_CLASS, feel free to
	use the code below as a starting point...):

	   (require "xtango/cls-image")
	   (require "xtango/cls-widget")

	   ;; for each line of text, create a TANGO:TEXT_IMAGE_CLASS
	   ;; if multiple lines of text, group all the images
	   ;; into one composite image
	   (defun create-multiline-text-image (str location_coord
					       tango_color font_string)
	     (let (pos
	  	  (imgs '())
	  	  )
	       (loop
	        (setq pos (search "\n" str))
	        (setq imgs
	  	     (cons
	  	      (send TANGO:TEXT_IMAGE_CLASS :new :show tango_w
	  		    location_coord
	  		    (subseq str 0 pos) ;text_string
	  		    tango_color
	  		    font_string
	  		    )
	  	      imgs))
	        (if (null pos) (return))
	        (setq str
	  	     (subseq str (1+ pos) nil))
	        (setq coords
	  	     (+ coords (- (send (car imgs) :IMAGE_LOC :s)
	  			  (send (car imgs) :IMAGE_LOC :n))))
	        )
	       (if (> (length imgs) 1)
	  	  (progn ;group multiline text into one object
	  	    (send tango_w :set-multi-selected-images imgs)
	  	    (send tango_w :group-selected-images)
	  	    )
	  	(send tango_w :set-selected-image (car imgs)))
	       )
	    )

**** TANGO:TEXT_IMAGE_CLASS method :STOREON

	(send <text-image> :STOREON)
		==> returns list
		  (send TANGO:TEXT_IMAGE_CLASS :new <visibility_kwd>
			*TANGO_WIDGET*
			#C(<location-x> <location-y) [:ctr]
			<text_str>
			<tango_color>
			<font_str>)

	See <<TANGO:TEXT_IMAGE_CLASS method :NEW/:ISNEW...>>
	for details on the returned data.
	
	Evaluating the results of this method will create a copy of the given
	image at a later time. Printing the results of this method to a file
	enables one to store a persistent copy of the given image to
	disk. See also TANGO:WIDGET_CLASS method :GET_IMAGES and
	:COLORS_STOREON.

**** TANGO:TEXT_IMAGE_CLASS method :IMAGE_LOC (TANGOimage_loc()):

	(send <tiobj> :IMAGE_LOC <image_part_kwd>)
		==> returns a COMPLEX number #C(<x> <y>), where <x> and <y>
		    are FLONUMS representing the location of the image
	
		<image_part_kwd> is a keyword argument, one of:
			:CTR	-- center
			:NW	-- north west
			:NE	-- north east
			:E	-- east
			:SE	-- south east
			:S	-- south
			:SW     -- south west
			:W      -- west
	
	This routine returns a COMPLEX FLONUM #C(<x> <y>) that corresponds to
	the location of the given <image_part_kwd> of the given <tiobj>.

	Valid <image_part_kwd> include :CTR (center), and the compass
	directions :NW, :N, :NE, :E, :SE, :S, :SW, :W. These
	represent locations on the bounding box of the text.

**** TANGO:TEXT_IMAGE_CLASS method :TX_COLOR (TANGO_TRANS_TYPE_COLOR):

	(send <t-image-obj> :TX_COLOR [:PERFORM] [<path>])
		==> returns <tango_trans> object, 
		    or NIL if :PERFORM keyword given.
	
	The COLOR transition changes the given <t-image-obj> to the color
	indicated by the given <path>.  See the routine TANGO:PATH_COLOR to
	create a special path which will change the image to a certain
	color. Using an arbitrary TANGO_PATH type argument, or using one of
	the other alternatives for the <path> argument list (as used
	in other :TX_* methods) will generate undefined results.
	
	The optional :PERFORM keyword argument specifies that the transition
	is to be performed immediately (see TANGO:TRANS_PERFORM). If :PERFORM
	is omitted, then a <tango_trans> object is returned (useful for
	storing- or operating-on- complex transitions via TANGO:TX_ITERATE,
	TANGO:TX_CONCATENATE, TANGO:TX_COMPOSE.
#endif /* WINTERP_XTANGO_WIDGET */

=============================================================================
#ifdef HP_GRAPH_WIDGET

* XM_GRAPH_WIDGET_CLASS:

	The XmGraph widget provides the application developer with the
	ability to display any group of widgets as a graph, with each widget
	representing a node. The graph can be disconnected, as well as
	contain cycles.  The arcs used to connect the nodes are instances of
	an XmArc widget, developed specifically for use with the XmGraph
	widget. Arc may be undirected, directed or bidirected. Note that the
	XmGraph widget does not understand the semantics of arc direction,
	ie. for layout and editing purposes, an arc will always have a parent
	and a child regardless of its direction.  The XmGraph widget has the
	ability to arrange all nodes either horizontally or vertically
	according to an internal layout algorithm, and supports an edit mode
	in which arcs and nodes may be interactively repositioned as well as
	created, and a read-only mode in which all events are passed directly
	to the children of the Graph widget. In edit mode, the XmGraph takes
	over all device events for editing commands. For details on this
	widget, see <winterp-top-dir>/doc/XmGraph.doc (or XmGraph.man).

	Some examples using XM_GRAPH_WIDGET_CLASS include:
	    * <winterp-top-dir>/<examples/grph-whier.lsp: Click on a WINTERP
	      generated top-level window, and this will use XmGraph to display
	      a tree of the widget hierarchy displayed in the window. Click
	      on graph node to see more information on the corresponding
	      widget.
	    * <winterp-top-dir>/examples/grph-sexpr.lsp: Click on a widget
	      and this will present a tree display of each method's code on
	      that widget. Only interesting on widgets containing
	      Winterp-Lisp methods, e.g. click on the text editor widget in
	      the WINTERP Control Panel. Can you say hack?
	    * <winterp-top-dir>/examples/graphcalc.lsp: Yet another hack.
	      A calculator with "direct manipulation" graphic display of
	      previous results (a sort of graphical spreadsheet, perhaps). 
	      Users may also enter expressions in infix notation and these
	      will be displayed with disambiguation provided by precedence
	      rules -- Non-numeric entries are treated as "variables" and
	      are rendered as a slider widget...

	Special useage note courtesy of Niels: For XmGraph widget with resource
	:XMN_EDITABLE set to 'T', any children nodes should have the following
	resources set:

		    :XMN_HIGHLIGHT_ON_ENTER 	nil
		    :XMN_HIGHLIGHT_THICKNESS	1	;greater than 0

	The highlight on node widgets in the graph is used to display the
	selection status of the node. Having :XMN_HIGHLIGHT_ON_ENTER set
	to 't' interferes with display of the selected node, so turn it off;
	:XMN_HIGHLIGHT_THICKNESS should be set to a value greater than 1 so
	that the selection status is visible.

** Compilation option "-DHP_GRAPH_WIDGET"

	If WINTERP has been compiled with "-DHP_GRAPH_WIDGET"
	then you have XmGraph and XmArc functionality built into WINTERP. To
	enable/disable this functionality, you may add/remove
	"-DHP_GRAPH_WIDGET" via (1) changing the machine/os-appropriate
	makefile in <winterp-top-dir>/src-server/Makefile.*; or (2) make
	equivalent change to the Imakefile or its generated Makefile in
	that directory; or (3) edit <winterp-top-dir>/src-server/config.h...

	If you use methods (2) or (3) to add/delete HP_GRAPH_WIDGET
	features, you must make sure to delete all the
	<winterp-top-dir>/src-server/*.o files, or at least delete the
	following: tic_*.o, wc_Xtango.o, wc_DropPockt.o, wc_XmGraph.o, 
	wc_Table.o, winterp.o, w_resources.o, w_funtab.o, w_callbacks.o...
	If you add/remove the feature by editing the appropriate
	<winterp-top-dir>/src-server/Makefile.* files, then the appropriate
	files will get remade automatically.

** equivalent Xt 'WidgetClass':

	xmGraphWidgetClass

** equivalent creation convenience function:

	(send XM_GRAPH_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateGraph()

	(send XM_GRAPH_WIDGET_CLASS :new [:managed/:unmanaged] :SCROLLED ...)
		--> XmCreateScrolledGraph()

	NOTE: -- the :SCROLLED XmGraph widget created by 
	XmCreateScrolledGraph() is anomalous, since it returns a graph widget
	containing two hidden parent widgets, a XmScrolledWindow and
	a XmDrawingArea widget. This can cause problems with other
	widgets doing geometry management on a scrolled XmGraph widget; Motif
	managers have a few special cases for Motif's own anomalous :SCROLLED
	widgets (e.g. XmText, XmList), but blows when other new	anomalous
	widgets are managed....	For such situations, or situations where you
	encounter problems in layout using the :SCROLLED XmGraph widget,
	you should pass
		(send (send <graph-w> :parent) :parent)
	as the reference widget for layout attachments.

	NOTE: -- you may create a XmGraph widget and wrap your own
	XM_SCROLLED_WINDOW_WIDGET_CLASS instance around the XmGraph widget.
	However, the Graph widget does extensive optimizations based on the
	existence of the ScrolledWindow's clipWindow. Changing the way in
	which the ScrolledWindow is configured will eliminate these
	optimizations.

** XM_GRAPH_WIDGET_CLASS :ADD_CALLBACK/:SET_CALLBACK (XtAddCallback()):

	(send <xmgraph-w> :ADD_CALLBACK	<name> <call_data_binding_names_list>
	      				<code>)
		--> returns: <callback_id_object> of type CALLBACKOBJ

	(send <xmgraph-w> :SET_CALLBACK	<name> <call_data_binding_names_list>
					<code>)
		--> returns: <callback_id_object> of type CALLBACKOBJ

	These methods work just like the :ADD_CALLBACK/:SET_CALLBACK
	methods on WIDGET_CLASS except that these methods understand
	how to retrieve XmGraph-specific callback data from the
	XmGraphCallbackStruct.

	At the time of the callback, a set of symbols may be bound to values
	taken from the callback structure. These symbols may be passed in
	<call_data_binding_names_list> for :ADD_CALLBACK/:SET_CALLBACK. The
	following lists the callback symbols associated with a particular
	callback <name>:

	    :XMN_DESTROY_CALLBACK --
		CALLBACK_WIDGET

	    :XMN_NEW_ARC_CALLBACK --
		CALLBACK_WIDGET CALLBACK_REASON CALLBACK_XEVENT
		CALLBACK_GRAPH_ELT
		CALLBACK_SELECTED_WIDGETS CALLBACK_NUM_SELECTED_WIDGETS
		CALLBACK_SELECTED_ARCS CALLBACK_NUM_SELECTED_ARCS
		CALLBACK_NEW_TO CALLBACK_NEW_FROM CALLBACK_DOIT

	    :XMN_NEW_NODE_CALLBACK --
		CALLBACK_WIDGET CALLBACK_REASON CALLBACK_XEVENT
		CALLBACK_GRAPH_ELT
		CALLBACK_SELECTED_WIDGETS CALLBACK_NUM_SELECTED_WIDGETS
		CALLBACK_SELECTED_ARCS CALLBACK_NUM_SELECTED_ARCS CALLBACK_DOIT

	    :XMN_ARC_MOVED_CALLBACK --
		CALLBACK_WIDGET CALLBACK_REASON CALLBACK_XEVENT
		CALLBACK_GRAPH_ELT
		CALLBACK_SELECTED_WIDGETS CALLBACK_NUM_SELECTED_WIDGETS
		CALLBACK_SELECTED_ARCS CALLBACK_NUM_SELECTED_ARCS
		CALLBACK_OLD_TO CALLBACK_OLD_FROM
		CALLBACK_NEW_TO CALLBACK_NEW_FROM
		CALLBACK_DOIT

	    :XMN_SELECT_NODE_CALLBACK, :XMN_SELECT_ARC_CALLBACK,
	    :XMN_SELECT_SUBGRAPH_CALLBACK, :XMN_DEFAULT_ACTION_CALLBACK,
	    :XMN_DESELECT_CALLBACK, :XMN_NODE_MOVED_CALLBACK:
		CALLBACK_WIDGET CALLBACK_REASON CALLBACK_XEVENT
		CALLBACK_GRAPH_ELT
		CALLBACK_SELECTED_WIDGETS CALLBACK_NUM_SELECTED_WIDGETS
		CALLBACK_SELECTED_ARCS CALLBACK_NUM_SELECTED_ARCS

	    :XMN_HELP_CALLBACK -- 
		CALLBACK_WIDGET CALLBACK_REASON CALLBACK_XEVENT

	The following describes the various symbols that can be included
	in <call_data_binding_names_list>:

	    CALLBACK_WIDGET -- <xmgraph-w>, the XmGraph widget of the callback.
	
	    CALLBACK_REASON -- indicates why the callback was invoked. 
			       See WIDGET_CLASS :ADD_CALLBACK/:SET_CALLBACK
			       method for Motif's default callback reasons.
		               The XmGraph widget also defines a new set of
			       values specific to XmGraph callbacks:
	          CR_NEW_ARC (:XMN_NEW_ARC_CALLBACK):
			A new arc has been created.
	          CR_NEW_NODE (:XMN_NEW_NODE_CALLBACK):
			A new arc has been created.
	          CR_NODE_MOVED (:XMN_NODE_MOVED_CALLBACK):
			One node has been moved.
		  CR_NODES_MOVED (:XMN_NODE_MOVED_CALLBACK):
			Multiple-selected nodes have been moved.
	          CR_ARC_MOVED (:XMN_ARC_MOVED_CALLBACK):
			An arc has been moved. This implies the arc has
			changed the nodes it points to, not a physical change
			in the location of the arcs. This would be indicated
			by a :XMN_NODE_MOVED_CALLBACK.
	          CR_SELECT_NODE (:XMN_SELECT_NODE_CALLBACK):
			A node has been selected.
		  CR_SELECT_NODES (:XMN_SELECT_NODE_CALLBACK):
			Multiple nodes have been selected. 
	          CR_SELECT_ARC (:XMN_SELECT_ARC_CALLBACK):
			An arc has been selected.
		  CR_SELECT_ARCS (:XMN_SELECT_ARC_CALLBACK):
			Multiple arcs have been selected.
	          CR_SELECT_SUBGRAPH (:XMN_SELECT_SUBGRAPH_CALLBACK):
			A subgraph has been selected.
		  CR_RELEASE (:XMN_DEFAULT_ACTION_CALLBACK):
			A release action has occured.
	          CR_NODE_DOUBLE_CLICK (:XMN_DEFAULT_ACTION_CALLBACK):
			 A double click on a node.
	          CR_ARC_DOUBLE_CLICK (:XMN_DEFAULT_ACTION_CALLBACK):
			A double click on an Arc widget.
	          CR_DOUBLE_CLICK (:XMN_DEFAULT_ACTION_CALLBACK):
			A double click not over a node or arc has occurred.
	          CR_DESELECT (:XMN_DESELECT_CALLBACK):
			One or more arcs or nodes has been deselected.
		  CR_SELECT_ARCS_AND_NODES (:XMN_SELECT_NODE_CALLBACK,
				           :XMN_SELECT_ARC_CALLBACK):
			Multiple nodes or arcs have been selected.

	    CALLBACK_XEVENT -- the XEvent that triggered the callback.

	    CALLBACK_GRAPH_ELT -- Indicates the current arc or node widget
		associated with this callback.

	    CALLBACK_SELECTED_WIDGETS -- If not NIL, multiple node widgets are
		currently selected. This is an array containing
		CALLBACK_NUM_SELECTED_WIDGETS number of node WIDGETOBJs which
		have been selected in the XmGraph widget. If only one node
		selected, then only one widget will be on this list.

	    CALLBACK_NUM_SELECTED_WIDGETS -- the number of selected node
		widgets.

	    CALLBACK_SELECTED_ARCS -- if this member is not NIL, then one or
		more widgets are currently selected.  This is an array
		containing CALLBACK_NUM_SELECTED_ARCS number of XmArc
		WIDGETOBJs which have been selected. If only one arc has been
		selected, one arc will be one this list.

	    CALLBACK_NUM_SELECTED_ARCS -- the number of selected arc widgets.

	    CALLBACK_OLD_TO, CALLBACK_OLD_FROM, CALLBACK_NEW_TO,
		CALLBACK_NEW_FROM: If an arc has been moved, the values of
		CALLBACK_OLD_TO, CALLBACK_OLD_FROM represent the nodes
		formerly connected, and CALLBACK_NEW_TO, CALLBACK_NEW_FROM
		represent the new nodes to which the arc will now connect.
		These are only valid for XmArc's :XMN_ARC_EDITED_CALLBACK and
		for XmGraph's :XMN_ARC_MOVED_CALLBACK.

	    CALLBACK_DOIT -- this member is initialized to 'T'. If the
		application wishes to abort or disallow certain operations,
		this field can be set (via SETQ/SETF) to 'NIL' before the
		callback returns. An example of how this might be used is if
		the application wishes to create a different type of node
		widget than the default. If this member is set to 'NIL' in an
		:XMN_NEW_NODE_CALLBACK, the XmGraph widget will destroy the
		node widget it has created. The application can them create a
		new node at the position of the interactively created widget.
		Only used with :XMN_ARC_EDITED_CALLBACK,
		:XMN_ARC_MOVED_CALLBACK, :XMN_NEW_NODE_CALLBACK,
		and :XMN_NEW_ARC_CALLBACK lists.

** XM_GRAPH_WIDGET_CLASS :CENTER_AROUND_WIDGET (XmGraphCenterAroundWidget()):

	(send <graph-w> :CENTER_AROUND_WIDGET <node-w>)
		--> returns <graph-w>.

	This method makes <node-w> the center of the "display region" in
	the graph. It is typically used to ensure the visibility of the
	given <node-w>. If <graph-w> is created with :SCROLLED option,
	then this method will scroll the display such that <node-w> is
	centered in the display.

** XM_GRAPH_WIDGET_CLASS :DESTROY_ALL_ARCS (XmGraphDestroyAllArcs()):

	(send <graph-w> :DESTROY_ALL_ARCS)
		--> returns <graph-w>.

	This method calls :DESTROY (XtDestroyWidget()) on all arcs. If the
	arcs have :XMN_DESTROY_CALLBACKs, they will be called.

** XM_GRAPH_WIDGET_CLASS :DESTROY_ALL_NODES (XmGraphDestroyAllNodes()):

	(send <graph-w> :DESTROY_ALL_NODES)
		--> returns <graph-w>.

	This method calls :DESTROY (XtDestroyWidget()) on all node widgets. If
	the nodes have :XMN_DESTROY_CALLBACKs, they will be called.

** XM_GRAPH_WIDGET_CLASS :DESTROY_SELECTED_ARCS_OR_NODES (XmGraphDestroySelectedArcsOrNodes()):

	(send <graph-w> :DESTROY_SELECTED_ARCS_OR_NODES)
		--> returns <graph-w>.

	This method calls :DESTROY (XtDestroyWidget()) on all selected arcs or
	nodes.  If the nodes/arcs have :XMN_DESTROY_CALLBACKs, they will be
	called.

** XM_GRAPH_WIDGET_CLASS :GET_ARCS (XmGraphGetArcs()):

	(send <graph-w> :GET_ARCS)
		--> returns an ARRAY of XmArc widgets.

	This method returns an ARRAY of all the XmArc widgets in <graph-w>.

** XM_GRAPH_WIDGET_CLASS :GET_NODES (XmGraphGetNodes()):

	(send <graph-w> :GET_NODES)
		--> returns an ARRAY of node WIDGETOBJs.

	This method returns an ARRAY of all the Node widgets in <graph-w>.

** XM_GRAPH_WIDGET_CLASS :GET_ARCS_BETWEEN_NODES (XmGraphGetArcsBetweenNodes()):

	(send <graph-w> :GET_ARCS_BETWEEN_NODES <from-node-w> <to-node-w>)
		--> returns an ARRAY of XmArc widgets.

	This method returns an ARRAY of XmArc widgets which have
	<from-node-w> as their :XMN_FROM widget, and <to-node-w>
	as their :XMN_TO widget. See XM_ARC_WIDGET_CLASS below for
	details...

** XM_GRAPH_WIDGET_CLASS :GET_NODE_ARCS (XmGraphGetNodeArcs()):

	(send <graph-w> :GET_NODE_ARCS <node-w>)
		--> returns an ARRAY #(<from-array> <to-array>)
		    where <from-array> is an array of XmArc widgets
		    and <to-array> is another array of XmArc widgets.

	This method retrieves #(<from-array> <to-array>), where
	<from-array> is an ARRAY of XmArc widgets that have <node-w>
	as their :XMN_FROM widget, and where <to-array> is an ARRAY of XmArc
	widgets that have <node-w> as their :XMN_TO widget.

** XM_GRAPH_WIDGET_CLASS :GET_ARC_NODES (XmGraphGetArcNodes()):

	(send <graph-w> :GET_ARC_NODES <arc-w>)
		--> returns an ARRAY #(<from-array> <to-array>)
		    where <from-array> is an array of graph node widgets
		    and <to-array> is another array of graph node widgets.

	This method retrieves #(<from-array> <to-array>), where	<from-array>
	is an ARRAY of graph node widgets that are set to <arc-w>'s :XMN_FROM
	widget, and where <to-array> is an ARRAY of graph nodes widgets that
	are set to <arc-w>'s :XMN_TO widget.

** XM_GRAPH_WIDGET_CLASS :GET_ROOTS (XmGraphGetRoots()):

	(send <graph-w> :GET_ROOTS)
		--> returns an ARRAY of graph node widgets.

	This method returns an ARRAY of graph node widgets representing the
	representing the set of root nodes for the widget. See also
	:INSERT_ROOTS, :REMOVE_ROOTS, :NUM_ROOTS.

** XM_GRAPH_WIDGET_CLASS :GET_SELECTED_ARCS (XmGraphGetSelectedArcs()):

	(send <graph-w> :GET_SELECTED_ARCS)
		--> returns an ARRAY of XmArc widgets.

	This method returns an ARRAY of XmArc widgets representing the arcs
	that have been selected.

** XM_GRAPH_WIDGET_CLASS :GET_SELECTED_NODES (XmGraphGetSelectedNodes()):

	(send <graph-w> :GET_SELECTED_NODES)
		--> returns an ARRAY of graph node widgets.

	This method returns an ARRAY of graph node widgets representing the
	nodes that have been selected.

** XM_GRAPH_WIDGET_CLASS :INPUT_OVER_ARC (XmGraphInputOverArc()):

	(send <graph-w> :INPUT_OVER_ARC <x-pos-fixnum> <y-pos-fixnum>)
		--> returns an XmArc widget.

	This method returns an XmArc widget which contains the point
	<x-pos-fixnum> <y-pos-fixnum>. If no such XmArc widget exists,
	this method returns NIL.

** XM_GRAPH_WIDGET_CLASS :INSERT_ROOTS (XmGraphInsertRoots()):

	TODO: implement this method...

** XM_GRAPH_WIDGET_CLASS :IS_SELECTED_ARC (XmGraphIsSelectedArc()):

	(send <graph-w> :IS_SELECTED_ARC <arc-w>)
		--> returns T or NIL.

	This method returns 'T' if the given <arc-w> is currently set as
	selected in <graph-w>; returns 'NIL' if it isn't.

** XM_GRAPH_WIDGET_CLASS :IS_SELECTED_NODE (XmGraphIsSelectedNode()):

	(send <graph-w> :IS_SELECTED_NODE <node-w>)
		--> returns T or NIL.

	This method returns 'T' if the given <node-w> is set as selected in
	<graph-w>; returns 'NIL' if it isn't.

** XM_GRAPH_WIDGET_CLASS :MOVE_ARC (XmGraphMoveArc()):

	(send <graph-w> :MOVE_ARC <arc-w> <from-node-w> <to-node-w>)
		--> returns T or NIL.

	This method changes the end nodes of <arc-w>, setting them to
	<from-node-w> and <to-node-w>. Returns 'T' if successful, 'NIL'
	if not.

** XM_GRAPH_WIDGET_CLASS :MOVE_NODE (XmGraphMoveNode()):

	(send <graph-w> :MOVE_NODE <node-w> <x-pos-fixnum> <y-pos-fixnum>)
		--> returns T or NIL.

	This method changes the position of <node-w> to the position at
	<x-pos-fixnum>, and <y-pos-fixnum>.  <node-w> must be a node widget
	in <graph-w>.  Returns 'T' if successful, else 'NIL'.

** XM_GRAPH_WIDGET_CLASS :NUM_ARCS (XmGraphNumArcs()):

	(send <graph-w> :NUM_ARCS)
		--> returns a FIXNUM.

	This method returns a FIXNUM, the number of XmArc widgets in <graph-w>.

** XM_GRAPH_WIDGET_CLASS :NUM_NODES (XmGraphNumNodes()):

	(send <graph-w> :NUM_NODES)
		--> returns a FIXNUM.

	This method returns a FIXNUM, the number of node widgets in <graph-w>,
	not including the dummy node created by the XmGraph widget itself.

** XM_GRAPH_WIDGET_CLASS :NUM_NODE_ARCS (XmGraphNumNodeArcs()):

	(send <graph-w> :NUM_NODE_ARCS <node-w>)
		--> returns ARRAY #(<from-arcs> <to-arcs>).

	This method returns ARRAY <from-arcs> and <to-arcs>. <from-arcs>
	is an ARRAY of XmArc widgets whose :XMN_FROM resource is set to
	<node-w>; <to-arcs> is an ARRAY of XmArc widgets whose :XMN_TO resource
	is set to <node-w>. <node-w> must be a node in <graph-w>.

** XM_GRAPH_WIDGET_CLASS :NUM_ROOTS (XmGraphNumRoots()):

	(send <graph-w> :NUM_ROOTS)
		--> returns a FIXNUM.

	This method returns a FIXNUM, the number of root widgets set on
	<graph-w>. See also methods :INSERT_ROOTS :REMOVE_ROOTS.

** XM_GRAPH_WIDGET_CLASS :NUM_SELECTED_ARCS (XmGraphNumSelectedArcs()):

	(send <graph-w> :NUM_SELECTED_ARCS)
		--> returns a FIXNUM.

	This method returns a FIXNUM, the number of selected XmArc widgets in
	<graph-w>.

** XM_GRAPH_WIDGET_CLASS :NUM_SELECTED_NODES (XmGraphNumSelectedNodes()):

	(send <graph-w> :NUM_SELECTED_NODES)
		--> returns a FIXNUM.

	This method returns a FIXNUM, the number of selected graph node widgets
	in <graph-w>.

** XM_GRAPH_WIDGET_CLASS :MOVE_ALL (XmGraphMoveAll()):

	(send <graph-w> :MOVE_ALL <delta-x-fixnum> <delta-y-fixnum>)
		--> returs <graph-w>.

	This method moves the entire graph by the pixel distance specified
	by <delta-x-fixnum> and <delta-y-fixnum>.

** XM_GRAPH_WIDGET_CLASS :LAYOUT (XmGraphLayout()):

	(send <graph-w> :LAYOUT)
		--> returns <graph-w>.

	This method forces the entire graph to layout all the graph nodes
	again using the graph widget's built-in layout algorithm.
	

** XM_GRAPH_WIDGET_CLASS :RELAY_SUBGRAPH (XmGraphRelaySubgraph()):

	(send <graph-w> :RELAY_SUBGRAPH <node-w>)
		--> returns <graph-w>.

	This method calls the XmGraph widgets layout algorithm on the
	subtree rooted at <node-w>. <node-w> must be a node within <graph-w>.
	Unlike :LAYOUT, this method preserves the position of <node-w>.

** XM_GRAPH_WIDGET_CLASS :REMOVE_ARC_BETWEEN_NODES (XmGraphRemoveArcBetweenNodes()):

	(send <graph-w> :REMOVE_ARC_BETWEEN_NODES <node-1-w> <node-2-w>)
		--> returns <graph-w>.

	This method destroys all XmArc widgets between <node-1-w> and 
	<node-2-w>, which are nodes within <graph-w>.

** XM_GRAPH_WIDGET_CLASS :REMOVE_ROOTS (XmGraphRemoveRoots()):

	TODO: implement this method...

** XM_GRAPH_WIDGET_CLASS :SELECT_ARC (XmGraphSelectArc()):

	(send <graph-w> :SELECT_ARC <arc-w>)
		--> returns <graph-w>.

	This method adds <arc-w> to the list of selected arcs in <graph-w>.
	<arc-w> must be an XmArc widget in <graph-w>.

** XM_GRAPH_WIDGET_CLASS :SELECT_ARCS (XmGraphSelectArcs()):

	TODO: implement this method...

** XM_GRAPH_WIDGET_CLASS :SELECT_NODES (XmGraphSelectNodes()):

	TODO: implement this method...

** XM_GRAPH_WIDGET_CLASS :UNSELECT_ARC (XmGraphUnselectArc()):

	(send <graph-w> :UNSELECT_ARC <arc-w>)
		--> returns <graph-w>.

	This method removes <arc-w> from the list of selected arcs in
	<graph-w>. <arc-w> must be an XmArc widget in <graph-w>.

** XM_GRAPH_WIDGET_CLASS :UNSELECT_ARCS (XmGraphUnselectArcs()):

	TODO: implement this method...

** XM_GRAPH_WIDGET_CLASS :UNSELECT_NODES (XmGraphUnselectNodes()):

	TODO: implement this method...

** XM_GRAPH_WIDGET_CLASS :SELECT_NODE (XmGraphSelectNode()):

	(send <graph-w> :SELECT_NODE <node-w>)

** XM_GRAPH_WIDGET_CLASS :UNSELECT_NODE (XmGraphUnselectNode()):

	(send <graph-w> :UNSELECT_NODE <node-w>)
		--> returns <graph-w>.

	This method removes <node-w> from the list of selected nodes in 
	<graph-w>. <node-w> must be a node widget in <graph-w>.
	

* XM_ARC_WIDGET_CLASS

	The XmArc widget is a special widget that resembles a gadget in that
	it has no window of its own. It draws in the window of the XmGraph
	widget, with cooperation of the XmGraph widget. The XmArc widget can
	only be used with the XmGraph widget.  An arc may be undirected,
	directed or bidirected. For details on this widget, see 
	<winterp-top-dir>/doc/XmArc.doc (or XmArc.man).

	Example: given two nodes <pb3-w> and <pb4-w>, an arc widget can
	be created "from" <pb3-w> "to" <pb4-w> by creating an arc widget
	as follows:
		(send XM_ARC_WIDGET_CLASS :new :managed
		      "" <graph-w>
		      :XMN_FROM			<pb3-w>
		      :XMN_TO			<pb4-w>
		      :XMN_ARC_DIRECTION	:directed
		      )	

** equivalent Xt 'WidgetClass':

	xmArcWidgetClass

** equivalent creation convenience function:

	(send XM_ARC_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> XmCreateArc()

** XM_ARC_WIDGET_CLASS :ADD_CALLBACK/:SET_CALLBACK (XtAddCallback()):

	(send <xmarc-w> :ADD_CALLBACK	<name> <call_data_binding_names_list>
	      				<code>)
		--> returns: <callback_id_object> of type CALLBACKOBJ

	(send <xmarc-w> :SET_CALLBACK	<name> <call_data_binding_names_list>
					<code>)
		--> returns: <callback_id_object> of type CALLBACKOBJ

	These methods work just like the :ADD_CALLBACK/:SET_CALLBACK
	methods on WIDGET_CLASS except that these methods understand
	how to retrieve XmGraph-specific callback data from the
	XmGraphCallbackStruct.

	At the time of the callback, a set of symbols may be bound to values
	taken from the callback structure. These symbols may be passed in
	<call_data_binding_names_list> for :ADD_CALLBACK/:SET_CALLBACK. The
	following lists the callback symbols associated with a particular
	callback <name>:

	:XMN_DESTROY_CALLBACK --
		CALLBACK_WIDGET

	:XMN_ARC_EDITED_CALLBACK --
		CALLBACK_WIDGET CALLBACK_REASON CALLBACK_XEVENT
		CALLBACK_GRAPH_ELT
		CALLBACK_SELECTED_WIDGETS CALLBACK_NUM_SELECTED_WIDGETS
		CALLBACK_SELECTED_ARCS CALLBACK_NUM_SELECTED_ARCS
		CALLBACK_OLD_TO CALLBACK_OLD_FROM
		CALLBACK_NEW_TO CALLBACK_NEW_FROM
		CALLBACK_DOIT

	:XMN_ARM_CALLBACK, :XMN_ACTIVATE_CALLBACK, :XMN_DISARM_CALLBACK --
		CALLBACK_WIDGET CALLBACK_REASON CALLBACK_XEVENT
		CALLBACK_GRAPH_ELT

	:XMN_HELP_CALLBACK --
		CALLBACK_WIDGET CALLBACK_REASON CALLBACK_XEVENT

	See <<XM_GRAPH_WIDGET_CLASS Method :ADD_CALLBACK/:SET_CALLBACK...>>
	section under <<XM_GRAPH_WIDGET_CLASS>> above for descriptions of the
	CALLBACK_* fields.

	For CALLBACK_REASON, see WIDGET_CLASS :ADD_CALLBACK/:SET_CALLBACK
	method for a list of possible values for callback reason. THe XmArc
	widget callbacks specifically define the following values:
		CR_ARM (:XMN_ARM_CALLBACK):
			An arm action has occured on the XmArc widget.
		CR_ACTIVATE (:XMN_ACTIVATE_CALLBACK):
			An activate action has occured on the XmArc widget.
		CR_DISARM (:XMN_DISARM_CALLBACK):
			A disarm action has occured on the XmArc widget.
		CR_ARC_EDITED (:XMN_ARC_EDITED_CALLBACK):
			The XmArc widget has been edited/moved.

** XM_ARC_WIDGET_CLASS :IS_POINT_IN_ARC (XmGraphIsPointInArc()):

	(send <arc-w> :IS_POINT_IN_ARC <x-pos-fixnum> <y-pos-fixnum>)
		--> returns T or NIL.

	This method returns 'T' if the position <x-pos-fixnum> <y-pos-fixnum>
	is over arc widget <arc-w>. Otherwise, returns NIL.

#endif /* HP_GRAPH_WIDGET */
=============================================================================
#ifdef SGI_DROP_POCKET_WIDGET

* SG_DROP_POCKET_WIDGET_CLASS

	SG_DROP_POCKET_WIDGET_CLASS is an SGI Irix 5.X specific widget available
	with Irix IDO (X/Motif/cc developer toos) product. It provides a
	high-level interface to SGI IndigoMagic desktop drag and drop
	capabilities, hooks into SGI's file-type rules system, etc. For details
	on this widget, see SgDropPocket(3X).

	See <winterp-top-dir>/<examples/SGI/droppocket.lsp for a demo of
	SG_DROP_POCKET_WIDGET_CLASS showing the kinds of data transferred to
	the drop pocket widget when icons are dragged from the IndigoMagic
	desktop into the drop pocket widget.

** Compilation option "-DSGI_DROP_POCKET_WIDGET"

	If you are running on an SGI Irix 5.X machine, and if WINTERP has been
	compiled with "-DSGI_DROP_POCKET_WIDGET" and linked with "-lSgm", then
	you have SgDropPocket(3X) and SgFinder(3X) functionality built into
	WINTERP. To enable/disable this functionality, you may add/remove
	"-DSGI_DROP_POCKET_WIDGET" via (1) changing the machine/os-appropriate
	makefile in <winterp-top-dir>/src-server/Makefile.irix5; or (2) make
	equivalent change to the Imakefile or its generated Makefile in
	that directory; or (3) edit <winterp-top-dir>/src-server/config.h...

	If you use methods (2) or (3) to add/delete SGI_DROP_POCKET_WIDGET
	features, you must make sure to delete all the
	<winterp-top-dir>/src-server/*.o files, or at least delete the
	following: tic_*.o, wc_Xtango.o, wc_DropPockt.o, wc_XmGraph.o, 
	wc_Table.o, winterp.o, w_resources.o, w_funtab.o, w_callbacks.o...
	If you add/remove the feature by editing 
	<winterp-top-dir>/src-server/Makefile.irix5, then the appropriate
	files will get remade automatically.

** equivalent Xt 'WidgetClass':

	sgDropPocketWidgetClass.

** equivalent creation convenience function:

	(send SG_DROP_POCKET_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> SgCreateDropPocket()

** SG_DROP_POCKET_WIDGET_CLASS :ADD_CALLBACK/:SET_CALLBACK (XtAddCallback()):

	(send <sgdrop-w> :ADD_CALLBACK	<name> <call_data_binding_names_list>
	      				<code>)
		--> returns: <callback_id_object> of type CALLBACKOBJ

	(send <sgdrop-w> :SET_CALLBACK	<name> <call_data_binding_names_list>
					<code>)
		--> returns: <callback_id_object> of type CALLBACKOBJ

	These methods work just like the :ADD_CALLBACK/:SET_CALLBACK
	methods on WIDGET_CLASS except that these methods understand
	how to retrieve SgDropPocket-specific callback data from the
	SgDropPocketCallbackStruct.

	At the time of the callback, a set of symbols may be bound to values
	taken from the callback structure. These symbols may be passed in
	<call_data_binding_names_list> for :ADD_CALLBACK/:SET_CALLBACK.
	The following describes the various symbols that can be included
	in <call_data_binding_names_list>:

	    CALLBACK_WIDGET --
		<sgdrop-w>, the SgDropPocket widget of the callback.
	    CALLBACK_REASON --
		Indicates why the callback was invoked. See WIDGET_CLASS 
		:ADD_CALLBACK/:SET_CALLBACK method for Motif's default
		callback reasons. The SgDropPocket widget also defines a new
		value specific to SgDropPocket callbacks:
			CR_ICON_CHANGE (:SGN_ICON_UPDATE_CALLBACK).
	    CALLBACK_XEVENT --
		The XEvent that triggered the callback.
	    CALLBACK_WINDOW --
		The window of the drop pocket.
	    CALLBACK_ICON_NAME --
		For :SGN_ICON_UPDATE_CALLBACK, the XmString representing the
		name/filepath of the icon/desktop-item dropped on the
		drop-pocket. Use XM_STRING_GET_L_TO_R to retrieve XLISP
		STRING name.
	    CALLBACK_ICON_DATA --
		For :SGN_ICON_UPDATE_CALLBACK, the STRING representing a
		variety of data associated the drop of an icon/deskop-item 
		into the drop pocket. See the following example for code to
		parse/decode the STRING returned in CALLBACK_ICON_DATA:
		<winterp-top-dir>/<examples/SGI/droppocket.lsp

#endif /* SGI_DROP_POCKET_WIDGET */
=============================================================================
#ifdef SGI_DROP_POCKET_WIDGET

* SG_FINDER_WIDGET_CLASS

	SG_FINDER_WIDGET_CLASS is an SGI Irix 5.X specific widget available
	with Irix IDO (X/Motif/cc developer toos) product. The Finder
	widget is designed to integrate a drop pocket, a textField, a zoomBar,
	and a history menu into a single widget. It is typically used for
	filename or value selection, entry, and display.

	See <winterp-top-dir>/<examples/SGI/finder.lsp for a demo of
	SG_FINDER_WIDGET_CLASS showing the kinds of data transferred to
	the drop pocket widget when icons are dragged from the IndigoMagic
	desktop into the drop pocket widget.

** Compilation option "-DSGI_DROP_POCKET_WIDGET"

	If you are running on an SGI Irix 5.X machine, and if WINTERP has been
	compiled with "-DSGI_DROP_POCKET_WIDGET" and linked with "-lSgm", then
	you have SgDropPocket(3X) and SgFinder(3X) functionality built into
	WINTERP. To enable/disable this functionality, you may add/remove
	"-DSGI_DROP_POCKET_WIDGET" via (1) changing the machine/os-appropriate
	makefile in <winterp-top-dir>/src-server/Makefile.irix5; or (2) make
	equivalent change to the Imakefile or its generated Makefile in
	that directory; or (3) edit <winterp-top-dir>/src-server/config.h...

	If you use methods (2) or (3) to add/delete SGI_DROP_POCKET_WIDGET
	features, you must make sure to delete all the
	<winterp-top-dir>/src-server/*.o files, or at least delete the
	following: tic_*.o, wc_Xtango.o, wc_DropPockt.o, wc_XmGraph.o, 
	wc_Table.o, winterp.o, w_resources.o, w_funtab.o, w_callbacks.o...
	If you add/remove the feature by editing 
	<winterp-top-dir>/src-server/Makefile.irix5, then the appropriate
	files will get remade automatically.

** equivalent Xt 'WidgetClass':

	sgFinderWidgetClass.

** equivalent creation convenience function:

	(send SG_FINDER_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> SgCreateFinder()

** SG_FINDER_WIDGET_CLASS :ADD_HISTORY_ITEM (SgFinderAddHistoryItem()):

	(send <finder_widget> :ADD_HISTORY_ITEM <string>)
		--> returns <finder_widget>

	Method :ADD_HISTORY_ITEM adds STRING item <string> to the Finder
	history list at the top position.  When the item is inserted into the
	list, it is compared with the current items. If the new item matches
	an item on the selected Finder, the item is removed from the old
	position, so it is not duplicated in the history list.

** SG_FINDER_WIDGET_CLASS :CLEAR_HISTORY (SgFinderClearHistory()):

	(send <finder_widget> :CLEAR_HISTORY)
		--> returns <finder_widget>

	Method :CLEAR_HISTORY deletes all items from the Finder's history list.

** SG_FINDER_WIDGET_CLASS :GET_STRING (SgFinderGetTextString()):

	(send <finder_widget> :GET_STRING)
		--> returns a STRING

	Method :GET_STRING accesses the string value of the Finder widget.

** SG_FINDER_WIDGET_CLASS :SET_STRING (SgFinderSetTextString()):

	(send <finder_widget> :SET_STRING <string>)
		--> returns <finder_widget>
	
	Method :SET_STRING sets the string value of the Finder widget.
	It also calls the widget's :XMN_VALUE_CHANGED_CALLBACK and
	:XMN_ACTIVATE_CALLBACK.

** SG_FINDER_WIDGET_CLASS :GET_CHILD (SgFinderGetChild()):

	(send <finder_widget> :GET_CHILD <child_sym>)
		--> returns a WIDGETOBJ corresponding to a SgFinder child.
	
	<child_sym> can be one of the following keyword symbols:
	          :DROP_POCKET, :TEXT, :ZOOM_BAR, or :HISTORY_MENUBAR.
	
	Method :GET_CHILD is used to access a widget component within a Finder.
	The parameters given to the function are the Finder widget and a value
	indicating which component to access.
	
	The Finder widget generally provides the functionality and access to
	child behavior through other means.  Accessing the children of the
	Finder and modifying their callbacks or resources significantly may
	cause unpredictable results.  It is suggested that applications not
	modify the state of the Finder children.
		
#endif /* SGI_DROP_POCKET_WIDGET */
=============================================================================
#ifdef WINTERP_TABLE_WIDGET

* TABLE_WIDGET_CLASS

	TABLE_WIDGET_CLASS is a composite widget class designed to lay out its
	children widgets as a "Form" using an array model to specify the size
	and location of its children. Under this model, widgets are placed at
	row and column locations in a variable sized array.  Widgets may span
	more than one row or column.  The array can expand or contract in size
	as needed.  There are options to control justification and place size
	restrictions on rows and columns of widgets. The Table widget can
	contain any number and type of sub-widgets (including other Table
	widgets).

	The widget is directly derived from the core and composite widgets
	provided by the X Toolkit. TABLE_WIDGET_CLASS doesn't know anything
	about Motif and therefore does not behave like other Motif managers
	(subclasses of <XM_MANAGER_WIDGET_CLASS> (XmManager(3x)). In particular,
	some Motif-specific manager features will not work with this widget:
	traversal, and setting of any special resources that alter the behavior
	of the managed children, e.g. resolution independence, unit types,
	string directions, etc.
	
	See <winterp-top-dir>/doc/Table.doc for details of the Xtoolkit
	tableWidgetClass and the C interface; the correspondence to
	the WINTERP interface should be obvious; additionally
	the C Xt names associated with tableWidgetClass are included
	below to simplify searching...

	See <winterp-top-dir>/examples/Table.lsp for a very random demo of
	TABLE_WIDGET_CLASS.

	See <winterp-top-dir>/tk-challenge/Application.lsp to see
	how TABLE_WIDGET_CLASS is used to simplify (??) layout of a "form".

	<winterp-top-dir>/xtango/imag-build.lsp uses TABLE_WIDGET_CLASS
	to manage the "drawing area" and the "palette of images" for a
	simple drawing editor application.

** Compilation option "-DWINTERP_TABLE_WIDGET"

	compiled with "-DWINTERP_TABLE_WIDGET" 

	To enable/disable this functionality, you may add/remove
	"-DWINTERP_TABLE_WIDGET" via (1) changing the machine/os-appropriate
	makefile in <winterp-top-dir>/src-server/Makefile.irix5; or (2) make
	equivalent change to the Imakefile or its generated Makefile in
	that directory; or (3) edit <winterp-top-dir>/src-server/config.h...

	If you use methods (2) or (3) to add/delete WINTERP_TABLE_WIDGET
	features, you must make sure to delete all the
	<winterp-top-dir>/src-server/*.o files, or at least delete the
	following: tic_*.o, wc_Xtango.o, wc_DropPockt.o, wc_XmGraph.o, 
	wc_Table.o, winterp.o, w_resources.o, w_funtab.o, w_callbacks.o...
	If you add/remove the feature by editing 
	<winterp-top-dir>/src-server/Makefile.irix5, then the appropriate
	files will get remade automatically.

** equivalent Xt 'WidgetClass':

	tableWidgetClass.

** equivalent creation convenience function:

	(send TABLE_WIDGET_CLASS :new [:managed/:unmanaged] ...)
		--> XtCreateTable().

** Function XT_TBL_CONFIG (XtTblConfig()):

	(XT_TBL_CONFIG <widget> <col> <row> <h_span> <v_span> <opt>)
		--> <widget>
	
	This routine positions a <widget> that is managed/parented by
	an instance of TABLE_WIDGET_CLASS. The widget will be placed at
	column <col> and row <row> (both FIXNUMs).  The widget will span
	the distances given by <h_span> and <v_span> (both FIXNUMs).
	The <opt> argument is as follows:
	  :TBL_LEFT	 Horizontally left justified.
	  :TBL_RIGHT	 Horizontally right justified.
	  :TBL_TOP	 Vertically top justified.
	  :TBL_BOTTOM 	 Vertically bottom justified.
	  :TBL_SM_WIDTH	 Force the width to be as small as possible.
	  :TBL_SM_HEIGHT Force the height to be as small as possible.
	  :TBL_LK_WIDTH	 Don't try to expand the widget horizontally.
	  :TBL_LK_HEIGHT Don't try to expand the widget vertically.

	If <opt> is equal to :TBL_DEF_OPT,  it is filled with the default
	value for <widget>'s TABLE_WIDGET_CLASS instance parent
	(set by TABLE_WIDGET_CLASS resource :XMN_DEFAULT_OPTIONS).

** Function XT_TBL_POSITION (XtTblPosition()):

	(XT_TBL_POSITION <widget> <col> <row>)
		--> returns <widget>

	This function positions <widget> using the table layout provided by
	<widget>'s manager, a TABLE_WIDGET_CLASS instance. The widget will
	be placed at column <col> and row <row>, both FIXNUMs.  If <widget>
	has never been placed before, it will span only one space in each
	direction and its options will be the defaults for its
	TABLE_WIDGET_CLASS instance parent.

** Function XT_TBL_RESIZE (XtTblResize()):

	(XT_TBL_RESIZE <widget> <h_span> <v_span>)
		--> returns <widget>.

	This routine changes the span of widget <widget> to
	(<h_span>,<v_span>), where <h_span> and <v_span> are both FIXNUMs.
	If the widget has never been placed before, it will be located at (0,0)
	and its options will be the defaults for its TABLE_WIDGET_CLASS
	instance parent.

** Function XT_TBL_OPTIONS (XtTblOptions()):

	(XT_TBL_OPTIONS <widget> <opt>)
		--> returns <widget>.
	
	This routine changes the options of <widget> to <opt>. <widget>
	must be a child of an TABLE_WIDGET_CLASS instance. If
	the widget has never been placed before,  it will be located
	and (0,0) with a span of (1,1) and its options will be the
	default options for its parent table widget.  The option
	mask is as follows:
	  :TBL_LEFT	 Horizontally left justified.
	  :TBL_RIGHT	 Horizontally right justified.
	  :TBL_TOP	 Vertically top justified.
	  :TBL_BOTTOM 	 Vertically bottom justified.
	  :TBL_SM_WIDTH	 Force the width to be as small as possible.
	  :TBL_SM_HEIGHT Force the height to be as small as possible.
	  :TBL_LK_WIDTH	 Don't try to expand the widget horizontally.
	  :TBL_LK_HEIGHT Don't try to expand the widget vertically.

	If <opt> is equal to :TBL_DEF_OPT,  it is filled with the default
	value for <widget>'s TABLE_WIDGET_CLASS instance parent
	(set by TABLE_WIDGET_CLASS resource :XMN_DEFAULT_OPTIONS).

** Resource :XMN_LAYOUT (XtNlayout):

	The layout of children widgets can be set at creation time by
	specifying :XMN_LAYOUT resource at creation time. Attempting
	to do a (send w :set_values :XMN_LAYOUT ...) will result in an
	error since it is a creation time resource. Attempting to do a
	(send w :get_values :XMN_LAYOUT ...) will also result in an
	error since this resource is "opaque"....

	The format of the string is a semicolon-separated list of statements;
	Each statement has the form:

	widget_name column row horizontal_span vertical_span opt_list

	widget_name	Name of the widget as given to XtCreateWidget().
	column		Integer >= 0 giving column in array
	row		Integer >= 0 giving row in array
	horizontal_span	Integer >= 1 giving number of columns to span
	vertical_span	Integer >= 1 giving number of rows to span
	opt_list	Series of characters each representing an option:
				l:	:TBL_LEFT
				r:	:TBL_RIGHT
				t:	:TBL_TOP
				b:	:TBL_BOTTOM
				w:	:TBL_LK_WIDTH
				h:	:TBL_LK_HEIGHT
				W:	:TBL_SM_WIDTH
				H:	:TBL_SM_HEIGHT

	For example, <winterp-top-dir>/tk-challenge/Application.lsp uses the
	following resource as argument to :NEW method.

	       :XMN_LAYOUT	"name-label    0 0 1 1 rWH;\
				 addrs-0-label 0 1 1 1 rWH;\
				 addrs-1-label 0 2 1 1 rWH;\
				 addrs-2-label 0 3 1 1 rWH;\
				 hophone-label 0 4 1 1 rWH;\
				 wophone-label 0 5 1 1 rWH;\
				 fax-label     0 6 1 1 rWH;\
				 name-field    1 0 1 1 h;\
				 addrs-0-field 1 1 1 1 h;\
				 addrs-1-field 1 2 1 1 h;\
				 addrs-2-field 1 3 1 1 h;\
				 hophone-field 1 4 1 1 h;\
				 wophone-field 1 5 1 1 h;\
				 fax-field     1 6 1 1 h;"

	Alternately, layout may also be achieved via functions XT_TBL_CONFIG,
	XT_TBL_POSITION, XT_TBL_RESIZE, or XT_TBL_OPTIONS after both
	the TABLE_WIDGET_CLASS instance and it's children have been created.
	For example <winterp-top-dir>/xtango/imag-build.lsp uses the following:

	 (XT_TBL_CONFIG create-bitmap_w
			0  0  1  1 :tbl_sm_width :tbl_lk_height)
	 (XT_TBL_CONFIG create-circle_w
			0  1  1  1 :tbl_sm_width :tbl_lk_height)
	 (XT_TBL_CONFIG create-composite_w
			0  2  1  1 :tbl_sm_width :tbl_lk_height)
	 (XT_TBL_CONFIG create-ellipse_w
			0  3  1  1 :tbl_sm_width :tbl_lk_height)
	 (XT_TBL_CONFIG create-line_w
			0  4  1  1 :tbl_sm_width :tbl_lk_height)
	 (XT_TBL_CONFIG create-polygon_w
			0  5  1  1 :tbl_sm_width :tbl_lk_height)
	 (XT_TBL_CONFIG create-polyline_w
			0  6  1  1 :tbl_sm_width :tbl_lk_height)
	 (XT_TBL_CONFIG create-rectangle_w
			0  7  1  1 :tbl_sm_width :tbl_lk_height)
	 (XT_TBL_CONFIG create-spline_w
			0  8  1  1 :tbl_sm_width :tbl_lk_height)
	 (XT_TBL_CONFIG create-text_w
			0  9  1  1 :tbl_sm_width :tbl_lk_height)
	 (XT_TBL_CONFIG sep_w
			1  0  1  10 :tbl_sm_width)
	 (XT_TBL_CONFIG tango_w
			2  0  8  10)

** Resource :XMN_DEFAULT_OPTIONS (XtNdefaultOptions):

	This resource sets the default options for the TABLE_WIDGET_CLASS
	instance. The resource can be specified as a STRING of option
	characters. This string has the same form as the opt_list described
	above for TABLE_WIDGET_CLASS resource :XMN_LAYOUT. The following shows
	the correspondence between the characters used for :XMN_DEFAULT_OPTIONS
	and the values set by function XT_TBL_CONFIG and XT_TBL_OPTIONS:

				l:	:TBL_LEFT
				r:	:TBL_RIGHT
				t:	:TBL_TOP
				b:	:TBL_BOTTOM
				w:	:TBL_LK_WIDTH
				h:	:TBL_LK_HEIGHT
				W:	:TBL_SM_WIDTH
				H:	:TBL_SM_HEIGHT

#endif /* WINTERP_TABLE_WIDGET */
=============================================================================

* WINTERP <--> Motif resources

______________________________________________________________________________

** XmRAcceleratorTable:

*** Type Information:

	Resource representation type XmRAcceleratorTable corresponds to the
	atomic type XT_ACCELERATORS as returned by primitive
	XT_PARSE_ACCELERATOR_TABLE.

	One may set XmRAcceleratorTable resources by specifying a STRING
	accelerator table, just as you would in file $HOME/.Xdefaults.
	Alternatively, one can use the result of :get_values on another
	widget's XmRAcceleratorTable resource or use primitive
	XT_PARSE_ACCELERATOR_TABLE as a XmRAcceleratorTable value.

	For more information on the syntax of the string representation of
	accelerator tables, see the X11 documentation "X Toolkit
	Intrinsics -- C Language Interface": "Appendix B: Translation Table
	Syntax" and "Chapter 10: Translation Management".

*** Resource names and the widget classes they apply to:

	:XMN_TEXT_ACCELERATORS		XmNtextAccelerators

		XM_SELECTION_BOX_WIDGET_CLASS

	:XMN_ACCELERATORS		XmNaccelerators

		<WIDGET_CLASS>

______________________________________________________________________________

** XmRAlignment:

*** Type Information:

	Resource representation type XmRAlignment corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:ALIGNMENT_BEGINNING	XmALIGNMENT_BEGINNING
		:ALIGNMENT_CENTER	XmALIGNMENT_CENTER
		:ALIGNMENT_END		XmALIGNMENT_END

	You may also specify a STRING value which will be automatically
	converted to XmRAlignment by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_ALIGNMENT		XmNalignment

		XM_LABEL_WIDGET_CLASS XM_LABEL_GADGET_CLASS

	:XMN_MESSAGE_ALIGNMENT	XmNmessageAlignment

		XM_MESSAGE_BOX_WIDGET_CLASS

	:XMN_ENTRY_ALIGNMENT	XmNentryAlignment

		XM_ROW_COLUMN_WIDGET_CLASS

   #ifdef Motif_1.2

	:XMN_CHILD_HORIZONTAL_ALIGNMENT	XmNchildHorizontalAlignment

		constraint resource from XM_FRAME_WIDGET_CLASS parent

   #endif /* Motif_1.2 */
______________________________________________________________________________
#ifdef HP_GRAPH_WIDGET

** XmRArcDirection [HP_GRAPH_WIDGET only]:

*** Type Information:

	Resource representation type XmRArcDirection corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:BIDIRECTED		XmBIDIRECTED
		:DIRECTED		XmDIRECTED
		:UNDIRECTED		XmUNDIRECTED

	You may also specify a STRING value which will be automatically
	converted to XmRArcDirection by Motif's resource converters.
	These values would be the same as one would specify in
	$HOME/.Xdefaults.

*** Resource names and the widget classes they apply to:

	:XMN_INTERACTIVE_ARC_DIRECTION	XmNinteractiveArcDirection

		XM_GRAPH_WIDGET_CLASS

	:XMN_ARC_DIRECTION		XmNarcDirection

		XM_ARC_WIDGET_CLASS

#endif /* HP_GRAPH_WIDGET */
______________________________________________________________________________
#ifdef HP_GRAPH_WIDGET

** XmRArcDrawMode [HP_GRAPH_WIDGET only]:

*** Type Information:

	Resource representation type XmRArcDrawMode corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:POSITION_FIXED		XmPOSITION_FIXED
		:POSITION_RELATIVE	XmPOSITION_RELATIVE

	You may also specify a STRING value which will be automatically
	converted to XmRArcDrawMode by Motif's resource converters.
	These values would be the same as one would specify in
	$HOME/.Xdefaults.

*** Resource names and the widget classes they apply to:

	:XMN_ARC_DRAW_MODE		XmNarcDrawMode

		XM_GRAPH_WIDGET_CLASS

#endif /* HP_GRAPH_WIDGET */
______________________________________________________________________________

** XmRArrowDirection:

*** Type Information:

	Resource representation type XmRArrowDirection corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:ARROW_UP		XmARROW_UP
		:ARROW_DOWN		XmARROW_DOWN
		:ARROW_LEFT		XmARROW_LEFT
		:ARROW_RIGHT		XmARROW_RIGHT

	You may also specify a STRING value which will be automatically
	converted to XmRArrowDirection by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_ARROW_DIRECTION		XmNarrowDirection

		XM_ARROW_BUTTON_WIDGET_CLASS XM_ARROW_BUTTON_GADGET_CLASS

______________________________________________________________________________

** XmRAttachment:

*** Type Information:

	Resource representation type XmRAttachment corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:ATTACH_NONE		XmATTACH_NONE
		:ATTACH_FORM		XmATTACH_FORM
		:ATTACH_OPPOSITE_FORM	XmATTACH_OPPOSITE_FORM
		:ATTACH_WIDGET		XmATTACH_WIDGET
		:ATTACH_OPPOSITE_WIDGET	XmATTACH_OPPOSITE_WIDGET
		:ATTACH_POSITION	XmATTACH_POSITION
		:ATTACH_SELF		XmATTACH_SELF

	You may also specify a STRING value which will be automatically
	converted to XmRAttachment by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_TOP_ATTACHMENT		XmNtopAttachment

		constraint resource from XM_FORM_WIDGET_CLASS parent

	:XMN_BOTTOM_ATTACHMENT		XmNbottomAttachment

		constraint resource from XM_FORM_WIDGET_CLASS parent

	:XMN_LEFT_ATTACHMENT		XmNleftAttachment

		constraint resource from XM_FORM_WIDGET_CLASS parent

	:XMN_RIGHT_ATTACHMENT		XmNrightAttachment

		constraint resource from XM_FORM_WIDGET_CLASS parent

______________________________________________________________________________
#ifdef HP_GRAPH_WIDGET

** XmRAutoLayoutMode [HP_GRAPH_WIDGET only]:

*** Type Information:

	Resource representation type XmRAutoLayoutMode corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:NEVER			XmNEVER
		:ALWAYS			XmALWAYS
		:ARCS_ONLY		XmARCS_ONLY
		:NODES_ONLY		XmNODES_ONLY
		:PARTIAL		XmPARTIAL

	You may also specify a STRING value which will be automatically
	converted to XmRAutoLayoutMode by Motif's resource converters.
	These values would be the same as one would specify in 
	$HOME/.Xdefaults.

*** Resource names and the widget classes they apply to:

	:XMN_AUTO_LAYOUT_MODE		XmNautoLayoutMode

		XM_GRAPH_WIDGET_CLASS

#endif /* HP_GRAPH_WIDGET */
______________________________________________________________________________

** XmRBoolean:

*** Type Information:

	Resource representation type XmRBoolean corresponds to any WINTERP-Lisp 
	value. If the value is NIL, then the value is the boolean FALSE,
	any other value is interpreted as boolean TRUE.

	You may also specify a STRING value which will be automatically
	converted to XmRBoolean by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.

*** Resource names and the widget classes they apply to:

	:XMN_ANCESTOR_SENSITIVE		XmNancestorSensitive

		<WIDGET_CLASS> <SHELL_WIDGET_CLASS>

	:XMN_INPUT			XmNinput

		<SHELL_WIDGET_CLASS>

	:XMN_SENSITIVE			XmNsensitive

		<WIDGET_CLASS>

	:XMN_ALLOW_SHELL_RESIZE		XmNallowShellResize
   #ifdef MOTIF_1.0
		<SHELL_WIDGET_CLASS> XM_MENU_POPUP_SHELL_WIDGET_CLASS
   #endif
   #ifdef MOTIF_1.1
		<SHELL_WIDGET_CLASS> 
   #endif

	:XMN_SAVE_UNDER			XmNsaveUnder
   #ifdef MOTIF_1.0
		<SHELL_WIDGET_CLASS> XM_MENU_POPUP_SHELL_WIDGET_CLASS
   #endif
   #ifdef MOTIF_1.1
		<SHELL_WIDGET_CLASS>
   #endif

	:XMN_OVERRIDE_REDIRECT		XmNoverrideRedirect

		<SHELL_WIDGET_CLASS>

	:XMN_WAIT_FOR_WM		XmNwaitForWm

		<SHELL_WIDGET_CLASS>

	:XMN_TRANSIENT			XmNtransient

		<SHELL_WIDGET_CLASS>

	:XMN_ICONIC			XmNiconic

		<SHELL_WIDGET_CLASS>

	:XMN_MAPPED_WHEN_MANAGED	XmNmappedWhenManaged

		<WIDGET_CLASS>

	:XMN_ALLOW_OVERLAP		XmNallowOverlap

		XM_BULLETIN_BOARD_WIDGET_CLASS

	:XMN_AUTO_UNMANAGE		XmNautoUnmanage

		XM_BULLETIN_BOARD_WIDGET_CLASS XM_COMMAND_WIDGET_CLASS
		XM_FILE_SELECTION_BOX_WIDGET_CLASS

	:XMN_DEFAULT_POSITION		XmNdefaultPosition

		XM_BULLETIN_BOARD_WIDGET_CLASS XM_COMMAND_WIDGET_CLASS

	:XMN_NO_RESIZE			XmNnoResize

		XM_BULLETIN_BOARD_WIDGET_CLASS

	:XMN_PUSH_BUTTON_ENABLED	XmNpushButtonEnabled

		XM_DRAWN_BUTTON_WIDGET_CLASS

	:XMN_LIST_UPDATED		XmNlistUpdated

		XM_FILE_SELECTION_BOX_WIDGET_CLASS

	:XMN_RUBBER_POSITIONING		XmNrubberPositioning

		XM_FORM_WIDGET_CLASS

	:XMN_RESIZABLE			XmNresizable

		constraint resource from XM_FORM_WIDGET_CLASS parent

	:XMN_TRAVERSAL_ON		XmNtraversalOn

	   #ifdef MOTIF_1.0
		<XM_GADGET_CLASS> <XM_PRIMITIVE_WIDGET_CLASS>
		XM_SCALE_WIDGET_CLASS
	   #endif /* MOTIF_1.0 */
	   #ifdef MOTIF_1.1
		XM_CASCADE_BUTTON_WIDGET_CLASS XM_CASCADE_BUTTON_GADGET_CLASS
		XM_DRAWN_BUTTON_WIDGET_CLASS <XM_GADGET_CLASS> 
		XM_LABEL_WIDGET_CLASS XM_LABEL_GADGET_CLASS
		<XM_MANAGER_WIDGET_CLASS> <XM_PRIMITIVE_WIDGET_CLASS>
		XM_PUSH_BUTTON_WIDGET_CLASS XM_PUSH_BUTTON_GADGET_CLASS
		XM_SCROLL_BAR_WIDGET_CLASS XM_SEPARATOR_GADGET_CLASS
		XM_SEPARATOR_WIDGET_CLASS XM_TOGGLE_BUTTON_WIDGET_CLASS
		XM_TOGGLE_BUTTON_GADGET_CLASS 
	   #endif /* MOTIF_1.1 */
	   #ifdef SGI_DROP_POCKET_WIDGET
		SG_FINDER_WIDGET_CLASS
		SG_DROP_POCKET_WIDGET_CLASS
	   #endif /* SGI_DROP_POCKET_WIDGET */

	:XMN_HIGHLIGHT_ON_ENTER		XmNhighlightOnEnter

		<XM_GADGET_CLASS> <XM_PRIMITIVE_WIDGET_CLASS>
		XM_SCALE_WIDGET_CLASS

	:XMN_RECOMPUTE_SIZE		XmNrecomputeSize

		XM_LABEL_WIDGET_CLASS XM_LABEL_GADGET_CLASS

	:XMN_AUTOMATIC_SELECTION XmNautomaticSelection

		XM_LIST_WIDGET_CLASS

	:XMN_SHOW_SEPARATOR		XmNshowSeparator

		XM_MAIN_WINDOW_WIDGET_CLASS

	:XMN_MINIMIZE_BUTTONS		XmNminimizeButtons

		XM_MESSAGE_BOX_WIDGET_CLASS XM_SELECTION_BOX_WIDGET_CLASS

	:XMN_REFIGURE_MODE		XmNrefigureMode

		XM_PANED_WINDOW_WIDGET_CLASS

	:XMN_SEPARATOR_ON		XmNseparatorOn

		XM_PANED_WINDOW_WIDGET_CLASS

	:XMN_ALLOW_RESIZE		XmNallowResize

		XM_PANED_WINDOW_WIDGET_CLASS

	:XMN_SKIP_ADJUST		XmNskipAdjust

		XM_PANED_WINDOW_WIDGET_CLASS

	:XMN_FILL_ON_ARM		XmNfillOnArm

		XM_PUSH_BUTTON_WIDGET_CLASS XM_PUSH_BUTTON_GADGET_CLASS

	:XMN_RESIZE_WIDTH		XmNresizeWidth

		XM_ROW_COLUMN_WIDGET_CLASS XM_TEXT_WIDGET_CLASS
		XM_TEXT_FIELD_WIDGET_CLASS

	:XMN_RESIZE_HEIGHT		XmNresizeHeight

		XM_ROW_COLUMN_WIDGET_CLASS XM_TEXT_WIDGET_CLASS

	:XMN_ADJUST_LAST		XmNadjustLast

		XM_ROW_COLUMN_WIDGET_CLASS

	:XMN_IS_ALIGNED			XmNisAligned

		XM_ROW_COLUMN_WIDGET_CLASS

	:XMN_ADJUST_MARGIN		XmNadjustMargin

		XM_ROW_COLUMN_WIDGET_CLASS

	:XMN_RADIO_BEHAVIOR		XmNradioBehavior

		XM_ROW_COLUMN_WIDGET_CLASS

	:XMN_RADIO_ALWAYS_ONE		XmNradioAlwaysOne

		XM_ROW_COLUMN_WIDGET_CLASS

	:XMN_IS_HOMOGENEOUS		XmNisHomogeneous

		XM_ROW_COLUMN_WIDGET_CLASS

	:XMN_POPUP_ENABLED		XmNpopupEnabled

		XM_ROW_COLUMN_WIDGET_CLASS

	:XMN_SHOW_VALUE			XmNshowValue

		XM_SCALE_WIDGET_CLASS

	:XMN_SHOW_ARROWS		XmNshowArrows

		XM_SCROLL_BAR_WIDGET_CLASS

	:XMN_MUST_MATCH			XmNmustMatch

		XM_SELECTION_BOX_WIDGET_CLASS

	:XMN_AUTO_SHOW_CURSOR_POSITION	XmNautoShowCursorPosition

		XM_TEXT_WIDGET_CLASS

	:XMN_EDITABLE			XmNeditable

		XM_TEXT_WIDGET_CLASS XM_TEXT_FIELD_WIDGET_CLASS
    #ifdef HP_GRAPH_WIDGET
		XM_GRAPH_WIDGET_CLASS
    #endif /* HP_GRAPH_WIDGET */

	:XMN_PENDING_DELETE		XmNpendingDelete

		XM_TEXT_WIDGET_CLASS	XM_TEXT_FIELD_WIDGET_CLASS

	:XMN_WORD_WRAP			XmNwordWrap

		XM_TEXT_WIDGET_CLASS

	:XMN_SCROLL_VERTICAL		XmNscrollVertical

		XM_TEXT_WIDGET_CLASS

	:XMN_SCROLL_HORIZONTAL		XmNscrollHorizontal

		XM_TEXT_WIDGET_CLASS

	:XMN_SCROLL_LEFT_SIDE		XmNscrollLeftSide

		XM_TEXT_WIDGET_CLASS

	:XMN_SCROLL_TOP_SIDE		XmNscrollTopSide

		XM_TEXT_WIDGET_CLASS

	:XMN_CURSOR_POSITION_VISIBLE	XmNcursorPositionVisible

		XM_TEXT_WIDGET_CLASS	XM_TEXT_FIELD_WIDGET_CLASS

	:XMN_VISIBLE_WHEN_OFF		XmNvisibleWhenOff

		XM_TOGGLE_BUTTON_WIDGET_CLASS XM_TOGGLE_BUTTON_GADGET_CLASS

	:XMN_SET			XmNset	

		XM_TOGGLE_BUTTON_WIDGET_CLASS XM_TOGGLE_BUTTON_GADGET_CLASS

	:XMN_INDICATOR_ON		XmNindicatorOn

		XM_TOGGLE_BUTTON_WIDGET_CLASS XM_TOGGLE_BUTTON_GADGET_CLASS

	:XMN_FILL_ON_SELECT		XmNfillOnSelect

		XM_TOGGLE_BUTTON_WIDGET_CLASS XM_TOGGLE_BUTTON_GADGET_CLASS

   #ifdef MOTIF_1.1

	:XMN_DIRECTORY_VALID		XmNdirectoryValid

		XM_FILE_SELECTION_BOX_WIDGET_CLASS

	:XMN_VERIFY_BELL		XmNverifyBell

		XM_TEXT_WIDGET_CLASS XM_TEXT_FIELD_WIDGET_CLASS

	:XMN_USE_ASYNC_GEOMETRY		XmNuseAsyncGeometry

		<SHELL_WIDGET_CLASS>

	:XMN_SHOW_AS_DEFAULT		XmNshowAsDefault

		XM_PUSH_BUTTON_WIDGET_CLASS XM_PUSH_BUTTON_GADGET_CLASS

	:XMN_INITIAL_RESOURCES_PERSISTENT XmNinitialResourcesPersistent
		<WIDGET_CLASS>

   #endif /* MOTIF_1.1 */

   #ifdef HP_GRAPH_WIDGET

	:XMN_ALLOW_MULTIPLE_SELECTIONS	XmNallowMultipleSelections

		XM_GRAPH_WIDGET_CLASS XM_ARC_WIDGET_CLASS

	:XMN_SHOW_CROSSING_ARCS		XmNshowCrossingArcs

		XM_GRAPH_WIDGET_CLASS

	:XMN_MOVABLE_NODES		XmNmovableNodes

		XM_GRAPH_WIDGET_CLASS

	:XMN_RE_LAYOUT			XmNreLayout

		XM_GRAPH_WIDGET_CLASS

	:XMN_REORIENT			XmNreorient

		XM_GRAPH_WIDGET_CLASS

	:XMN_TWINS_VISIBLE		XmNtwinsVisible

		XM_GRAPH_WIDGET_CLASS

	:XMN_SNAP_GRID_ON		XmNsnapGridOn

		XM_GRAPH_WIDGET_CLASS

	:XMN_HIGHLIGHT			XmNhighlight

		XM_ARC_WIDGET_CLASS

	:XMN_MAP_LABEL			XmNmapLabel

		XM_ARC_WIDGET_CLASS

   #endif /* HP_GRAPH_WIDGET */

   #ifdef SGI_DROP_POCKET_WIDGET

	:SGN_USE_DROP_POCKET		SgNuseDropPocket

		SG_FINDER_WIDGET_CLASS

	:SGN_USE_HISTORY_MENU		SgNuseHistoryMenu

		SG_FINDER_WIDGET_CLASS

   #endif /* SGI_DROP_POCKET_WIDGET */


______________________________________________________________________________

#ifdef MOTIF_1.1
** XmRButtonType [MOTIF_1.1 only]:

*** Type Information:

	One may set an XmRButtonType resource by passing a ARRAY or LIST value
	containing the following button-type keyword symbols:
	:PUSHBUTTON, :TOGGLEBUTTON, :CHECKBUTTON, :RADIOBUTTON, :CASCADEBUTTON
	:SEPARATOR, :DOUBLE_SEPARATOR, :TITLE.

	XmRButtonType is a create-time-only resource. It cannot be
	retrieved via :GET_VALUES.

*** Resource names and the widget classes they apply to:

	:XMN_BUTTON_TYPE		XmNbuttonType

		XM_ROW_COLUMN_WIDGET_CLASS
		(for XmCreateSimple*() routines only).

#endif /* MOTIF_1.1 */

______________________________________________________________________________

** XmRCallback:

*** Type Information:

	The current version of WINTERP does not allow you to set or
	retrieve a widget's callback list directly. Modifications
	to a callback list must be done through WIDGET_CLASS methods
	:ADD_CALLBACK, :SET_CALLBACK, :REMOVE_ALL_CALLBACKS,
	or via primitive XT_REMOVE_CALLBACK.


*** Resource names and the widget classes they apply to:

	:XMN_DESTROY_CALLBACK		XmNdestroyCallback

		<WIDGET_CLASS>

	:XMN_POPUP_CALLBACK		XmNpopupCallback

		<SHELL_WIDGET_CLASS>

	:XMN_POPDOWN_CALLBACK		XmNpopdownCallback

		<SHELL_WIDGET_CLASS>

	:XMN_ACTIVATE_CALLBACK		XmNactivateCallback

		XM_ARROW_BUTTON_WIDGET_CLASS XM_ARROW_BUTTON_GADGET_CLASS
		XM_CASCADE_BUTTON_WIDGET_CLASS XM_CASCADE_BUTTON_GADGET_CLASS
		XM_DRAWN_BUTTON_WIDGET_CLASS
		XM_PUSH_BUTTON_WIDGET_CLASS XM_PUSH_BUTTON_GADGET_CLASS
		XM_TEXT_WIDGET_CLASS
	   #ifdef MOTIF_1.1
		XM_TEXT_FIELD_WIDGET_CLASS
	   #endif /* MOTIF_1.1 */
	   #ifdef SGI_DROP_POCKET_WIDGET
		SG_FINDER_WIDGET_CLASS
	   #endif /* SGI_DROP_POCKET_WIDGET */
           #ifdef HP_GRAPH_WIDGET
		XM_ARC_WIDGET_CLASS
           #endif /* HP_GRAPH_WIDGET */

	:XMN_ARM_CALLBACK		XmNarmCallback

		XM_ARROW_BUTTON_WIDGET_CLASS XM_ARROW_BUTTON_GADGET_CLASS
		XM_DRAWN_BUTTON_WIDGET_CLASS
		XM_PUSH_BUTTON_WIDGET_CLASS XM_PUSH_BUTTON_GADGET_CLASS
		XM_TOGGLE_BUTTON_WIDGET_CLASS XM_TOGGLE_BUTTON_GADGET_CLASS
           #ifdef HP_GRAPH_WIDGET
		XM_ARC_WIDGET_CLASS
           #endif /* HP_GRAPH_WIDGET */

	:XMN_DISARM_CALLBACK		XmNdisarmCallback

		XM_ARROW_BUTTON_WIDGET_CLASS XM_ARROW_BUTTON_GADGET_CLASS
		XM_DRAWN_BUTTON_WIDGET_CLASS
		XM_PUSH_BUTTON_WIDGET_CLASS XM_PUSH_BUTTON_GADGET_CLASS
		XM_TOGGLE_BUTTON_WIDGET_CLASS XM_TOGGLE_BUTTON_GADGET_CLASS
           #ifdef HP_GRAPH_WIDGET
		XM_ARC_WIDGET_CLASS
           #endif /* HP_GRAPH_WIDGET */

	:XMN_FOCUS_CALLBACK		XmNfocusCallback

		XM_BULLETIN_BOARD_WIDGET_CLASS XM_TEXT_WIDGET_CLASS
   #ifdef MOTIF_1.2
		XM_TEXT_FIELD_WIDGET_CLASS
   #endif MOTIF_1.2

	:XMN_MAP_CALLBACK		XmNmapCallback

		XM_BULLETIN_BOARD_WIDGET_CLASS XM_ROW_COLUMN_WIDGET_CLASS

	:XMN_UNMAP_CALLBACK		XmNunmapCallback

		XM_BULLETIN_BOARD_WIDGET_CLASS XM_ROW_COLUMN_WIDGET_CLASS

	:XMN_CASCADING_CALLBACK		XmNcascadingCallback

		XM_CASCADE_BUTTON_WIDGET_CLASS XM_CASCADE_BUTTON_GADGET_CLASS

	:XMN_COMMAND_ENTERED_CALLBACK	XmNcommandEnteredCallback

		XM_COMMAND_WIDGET_CLASS

	:XMN_COMMAND_CHANGED_CALLBACK	XmNcommandChangedCallback

		XM_COMMAND_WIDGET_CLASS

	:XMN_RESIZE_CALLBACK		XmNresizeCallback

		XM_DRAWING_AREA_WIDGET_CLASS XM_DRAWN_BUTTON_WIDGET_CLASS

	:XMN_EXPOSE_CALLBACK		XmNexposeCallback

		XM_DRAWING_AREA_WIDGET_CLASS XM_DRAWN_BUTTON_WIDGET_CLASS

	:XMN_INPUT_CALLBACK		XmNinputCallback

		XM_DRAWING_AREA_WIDGET_CLASS

	:XMN_HELP_CALLBACK		XmNhelpCallback

		<XM_GADGET_CLASS> <XM_MANAGER_WIDGET_CLASS>
		<XM_PRIMITIVE_WIDGET_CLASS>

	:XMN_SINGLE_SELECTION_CALLBACK	XmNsingleSelectionCallback

		XM_LIST_WIDGET_CLASS

	:XMN_MULTIPLE_SELECTION_CALLBACK XmNmultipleSelectionCallback

		XM_LIST_WIDGET_CLASS

	:XMN_EXTENDED_SELECTION_CALLBACK XmNextendedSelectionCallback

		XM_LIST_WIDGET_CLASS

	:XMN_BROWSE_SELECTION_CALLBACK	XmNbrowseSelectionCallback

		XM_LIST_WIDGET_CLASS

	:XMN_DEFAULT_ACTION_CALLBACK	XmNdefaultActionCallback

		XM_LIST_WIDGET_CLASS 
    #ifdef HP_GRAPH_WIDGET
		XM_GRAPH_WIDGET_CLASS
    #endif /* HP_GRAPH_WIDGET */

	:XMN_OK_CALLBACK		XmNokCallback

		XM_MESSAGE_BOX_WIDGET_CLASS XM_SELECTION_BOX_WIDGET_CLASS

	:XMN_CANCEL_CALLBACK		XmNcancelCallback

		XM_MESSAGE_BOX_WIDGET_CLASS XM_SELECTION_BOX_WIDGET_CLASS

	:XMN_ENTRY_CALLBACK		XmNentryCallback

		XM_ROW_COLUMN_WIDGET_CLASS

	:XMN_VALUE_CHANGED_CALLBACK	XmNvalueChangedCallback

		XM_SCALE_WIDGET_CLASS XM_SCROLL_BAR_WIDGET_CLASS
		XM_TEXT_WIDGET_CLASS
		XM_TOGGLE_BUTTON_WIDGET_CLASS XM_TOGGLE_BUTTON_GADGET_CLASS
	   #ifdef MOTIF_1.1
		XM_TEXT_FIELD_WIDGET_CLASS
	   #endif /* MOTIF_1.1 */
	   #ifdef SGI_DROP_POCKET_WIDGET
		SG_FINDER_WIDGET_CLASS
	   #endif /* SGI_DROP_POCKET_WIDGET */

	:XMN_DRAG_CALLBACK		XmNdragCallback

		XM_SCALE_WIDGET_CLASS XM_SCROLL_BAR_WIDGET_CLASS

	:XMN_INCREMENT_CALLBACK		XmNincrementCallback

		XM_SCROLL_BAR_WIDGET_CLASS

	:XMN_DECREMENT_CALLBACK		XmNdecrementCallback

		XM_SCROLL_BAR_WIDGET_CLASS

	:XMN_PAGE_INCREMENT_CALLBACK	XmNpageIncrementCallback

		XM_SCROLL_BAR_WIDGET_CLASS

	:XMN_PAGE_DECREMENT_CALLBACK	XmNpageDecrementCallback

		XM_SCROLL_BAR_WIDGET_CLASS

	:XMN_TO_TOP_CALLBACK		XmNtoTopCallback

		XM_SCROLL_BAR_WIDGET_CLASS

	:XMN_TO_BOTTOM_CALLBACK		XmNtoBottomCallback

		XM_SCROLL_BAR_WIDGET_CLASS

	:XMN_NO_MATCH_CALLBACK		XmNnoMatchCallback

		XM_SELECTION_BOX_WIDGET_CLASS

	:XMN_APPLY_CALLBACK		XmNapplyCallback

		XM_SELECTION_BOX_WIDGET_CLASS

	:XMN_LOSING_FOCUS_CALLBACK	XmNlosingFocusCallback

		XM_TEXT_WIDGET_CLASS
	   #ifdef MOTIF_1.1
		XM_BULLETIN_BOARD_WIDGET_CLASS XM_TEXT_FIELD_WIDGET_CLASS
	   #endif

	:XMN_MODIFY_VERIFY_CALLBACK	XmNmodifyVerifyCallback

		XM_TEXT_WIDGET_CLASS
	   #ifdef MOTIF_1.1
		XM_TEXT_FIELD_WIDGET_CLASS
	   #endif

	:XMN_MOTION_VERIFY_CALLBACK	XmNmotionVerifyCallback

		XM_TEXT_WIDGET_CLASS
	   #ifdef MOTIF_1.1
		XM_TEXT_FIELD_WIDGET_CLASS
	   #endif

   #ifdef MOTIF_1.1
	:XMN_GAIN_PRIMARY_CALLBACK	XmNgainPrimaryCallback

		XM_TEXT_WIDGET_CLASS XM_TEXT_FIELD_WIDGET_CLASS

	:XMN_LOSE_PRIMARY_CALLBACK	XmNlosePrimaryCallback

		XM_TEXT_WIDGET_CLASS XM_TEXT_FIELD_WIDGET_CLASS

	:XMN_FOCUS_MOVED_CALLBACK	XmNfocusMovedCallback

		<SHELL_WIDGET_CLASS>

	:XMN_REALIZE_CALLBACK		XmNrealizeCallback

		<SHELL_WIDGET_CLASS>
   #endif /* MOTIF 1.1 */

   #ifdef HP_GRAPH_WIDGET

	:XMN_NEW_ARC_CALLBACK		XmNnewArcCallback

		XM_GRAPH_WIDGET_CLASS 

	:XMN_NEW_NODE_CALLBACK		XmNnewNodeCallback

		XM_GRAPH_WIDGET_CLASS 

	:XMN_NODE_MOVED_CALLBACK	XmNnodeMovedCallback

		XM_GRAPH_WIDGET_CLASS 

	:XMN_ARC_MOVED_CALLBACK		XmNarcMovedCallback

		XM_GRAPH_WIDGET_CLASS 

	:XMN_SELECT_NODE_CALLBACK	XmNselectNodeCallback

		XM_GRAPH_WIDGET_CLASS 

	:XMN_DESELECT_CALLBACK		XmNdeselectCallback

		XM_GRAPH_WIDGET_CLASS 

	:XMN_SELECT_ARC_CALLBACK	XmNselectArcCallback

		XM_GRAPH_WIDGET_CLASS 

	:XMN_SELECT_SUBGRAPH_CALLBACK	XmNselectSubgraphCallback

		XM_GRAPH_WIDGET_CLASS 

	:XMN_ARC_EDITED_CALLBACK	XmNarcEditedCallback

		XM_ARC_WIDGET_CLASS

   #endif /* HP_GRAPH_WIDGET */

   #ifdef SGI_DROP_POCKET_WIDGET

	:SGN_ICON_UPDATE_CALLBACK	SgNiconUpdateCallback

		SG_DROP_POCKET_WIDGET_CLASS

   #endif /* SGI_DROP_POCKET_WIDGET */
   #ifdef Motif_1.2

	:XMN_TRAVERSE_OBSCURED_CALLBACK	XmNtraverseObscuredCallback

		XM_SCROLLED_WINDOW_WIDGET_CLASS

	:XMN_TEAR_OFF_MENU_ACTIVATE_CALLBACK XmNtearOffMenuActivateCallback

		XM_ROW_COLUMN_WIDGET_CLASS

	:XMN_TEAR_OFF_MENU_DEACTIVATE_CALLBACK XmNtearOffMenuDeactivateCallback

		XM_ROW_COLUMN_WIDGET_CLASS

   #endif /* Motif_1.2 */

______________________________________________________________________________
#ifdef HP_GRAPH_WIDGET

** XmRCapStyle: [HP_GRAPH_WIDGET only]

*** Type Information:

	Resource representation type XmRCapStyle corresponds to an enumerated
	type. The following keyword symbols represent the valid WINTERP-Lisp
	values for this type and their associated Motif constants:

		:CAP_NOT_LAST		XmCapNotLast
		:CAP_BUTT		XmCapButt
		:CAP_ROUND		XmCapRound
		:CAP_PROJECTING		XmCapProjecting

	You may also specify a STRING value which will be automatically
	converted to XmRCapStyle by Motif's resource converters. These values
	would be the same as one would specify in $HOME/.Xdefaults.

*** Resource names and the widget classes they apply to:

	:XMN_CAP_STYLE		XmNcapStyle

		XM_ARC_WIDGET_CLASS

#endif /* HP_GRAPH_WIDGET */
______________________________________________________________________________
#ifdef MOTIF_1.1
** XmRCommandWindowLocation: [Motif >= 1.1 only]

*** Type Information:

	Resource representation type XmRCommandWindowLocation corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:COMMAND_ABOVE_WORKSPACE	XmCOMMAND_ABOVE_WORKSPACE
		:COMMAND_BELOW_WORKSPACE	XmCOMMAND_BELOW_WORKSPACE

	You may also specify a STRING value which will be automatically
	converted to XmRCommandWindowLocation by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_COMMAND_WINDOW_LOCATION		XmNcommandWindowLocation

		XM_MAIN_WINDOW_WIDGET_CLASS

#endif /* MOTIF_1.1 */

______________________________________________________________________________

** XmRChar (Motif 1.0) // XmRKeySym (Motif 1.1)

*** Type Information:

	Resource representation type XmRChar/XmRKeySym corresponds to the
	WINTERP-Lisp type CHARACTER.

	You may also specify a STRING value which will be automatically
	converted to XmRChar/XmRKeySym by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_MNEMONIC			XmNmnemonic

		XM_LABEL_WIDGET_CLASS XM_LABEL_GADGET_CLASS
		XM_ROW_COLUMN_WIDGET_CLASS

   #ifdef MOTIF_1.1
	:XMN_OPTION_MNEMONIC		XmNoptionMnemonic

		<XM_ROW_COLUMN_WIDGET_CLASS created w/ :SIMPLE_OPTION_MENU>
   #endif /* MOTIF_1.1 */

   #ifdef SGI_DROP_POCKET_WIDGET

	:SGN_SEPARATOR			SgNseparator

		SG_FINDER_WIDGET_CLASS

   #endif /* SGI_DROP_POCKET_WIDGET */

______________________________________________________________________________

#ifdef MOTIF_1.2
** XmRChildType: [MOTIF >= 1.2 only]

*** Type Information:

	Resource representation type XmRChildType corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:FRAME_GENERIC_CHILD	XmFRAME_GENERIC_CHILD
		:FRAME_WORKAREA_CHILD	XmFRAME_WORKAREA_CHILD
		:FRAME_TITLE_CHILD	XmFRAME_TITLE_CHILD

	You may also specify a STRING value which will be automatically
	converted to XmRChildType by Motif's resource converters.
	These values would be the same as one would specify in
	$HOME/.Xdefaults.

*** Resource names and the widget classes they apply to:

	:XMN_CHILD_TYPE		XmNchildType

		constraint resource from XM_FRAME_WIDGET_CLASS parent

#endif /* MOTIF_1.2 */

______________________________________________________________________________

#ifdef MOTIF_1.2
** XmRChildVerticalAlignment: [MOTIF >= 1.2 only]

*** Type Information:

	Resource representation type XmRChildVerticalAlignment corresponds
	to an enumerated type. The following keyword symbols represent the
	valid WINTERP-Lisp values for this type and their associated Motif
	constants:

		:ALIGNMENT_BASELINE_TOP		XmALIGNMENT_BASELINE_TOP
		:ALIGNMENT_CENTER		XmALIGNMENT_CENTER
		:ALIGNMENT_BASELINE_BOTTOM	XmALIGNMENT_BASELINE_BOTTOM
		:ALIGNMENT_WIDGET_TOP		XmALIGNMENT_WIDGET_TOP
		:ALIGNMENT_WIDGET_BOTTOM	XmALIGNMENT_WIDGET_BOTTOM

	You may also specify a STRING value which will be automatically
	converted to XmRChildVerticalAlignment by Motif's resource converters.
	These values would be the same as one would specify in
	$HOME/.Xdefaults.

*** Resource names and the widget classes they apply to:

	:XMN_CHILD_VERTICAL_ALIGNMENT		XmNchildVerticalAlignment

		constraint resource from XM_FRAME_WIDGET_CLASS parent

#endif /* MOTIF_1.2 */

______________________________________________________________________________

#ifdef MOTIF_1.0
** XmRDimension: [MOTIF 1.0 only]

*** Type Information:

	Resource representation type XmRDimension corresponds to
	WINTERP-Lisp type FIXNUM, and further restricts that type to the
	subrange of non-negative integers.

	You may also specify a STRING value which will be automatically
	converted to XmRDimension by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_SPACING			XmNspacing

		XM_PANED_WINDOW_WIDGET_CLASS
		XM_ROW_COLUMN_WIDGET_CLASS
		XM_TOGGLE_BUTTON_WIDGET_CLASS XM_TOGGLE_BUTTON_GADGET_CLASS

		Note -- Motif 1.0 has a bug in that :XMN_SPACING is
		inconsistently declared across widget classes. In
		XM_ROW_COLUMN_WIDGET_CLASS, it is declared as XmRDimension; in
		XM_TOGGLE_BUTTON_WIDGET_CLASS and XM_TOGGLE_BUTTON_GADGET_CLASS
		it's declared as XmRShort; and it's declared as XmRInt in
		XM_PANED_WINDOW_WIDGET_CLASS. Note that in some architectures,
		this may result in the bug of bogus retrieval and/or setting of
		values....

	:XMN_WIDTH			XmNwidth

		<WIDGET_CLASS>

	:XMN_HEIGHT			XmNheight

		<WIDGET_CLASS>

	:XMN_BORDER_WIDTH		XmNborderWidth

		<WIDGET_CLASS> <XM_GADGET_CLASS> <XM_MANAGER_WIDGET_CLASS>
		<XM_PRIMITIVE_WIDGET_CLASS>

	:XMN_SASH_WIDTH			XmNsashWidth

		XM_PANED_WINDOW_WIDGET_CLASS

	:XMN_SASH_HEIGHT		XmNsashHeight

		XM_PANED_WINDOW_WIDGET_CLASS

	:XMN_RCMARGIN_WIDTH		XmNmarginWidth

		XM_ROW_COLUMN_WIDGET_CLASS

		Note -- :XMN_RCMARGIN_WIDTH is an alias for XmNmarginWidth
		for the Motif Row Column Widget. Motif 1.0 has a bug in
		that it inconsistently declares XmNmarginWidth as 'short' in
		a number of widget classes, but uses 'unsigned int' for the
		rowcolumn widget. On some architectures, this may cause
		method :get_values to retrieve garbage.

	:XMN_RCMARGIN_HEIGHT		XmNmarginHeight

		XM_ROW_COLUMN_WIDGET_CLASS

		Note -- :XMN_RCMARGIN_HEIGHT is an alias for XmNmarginHeight
		for the Motif Row Column Widget. Motif 1.0 has a bug in
		that it inconsistently declares XmNmarginHeight as 'short' in
		a number of widget classes, but uses 'unsigned int' for the
		rowcolumn widget. On some architectures, this may cause
		method :get_values to retrieve garbage.

	:XMN_ENTRY_BORDER		XmNentryBorder

		XM_ROW_COLUMN_WIDGET_CLASS

	:XMN_SCALE_WIDTH		XmNscaleWidth

		XM_SCALE_WIDGET_CLASS

	:XMN_SCALE_HEIGHT		XmNscaleHeight

		XM_SCALE_WIDGET_CLASS
#endif /* Motif 1.0 */

______________________________________________________________________________

#ifdef MOTIF_1.1
** XmRHorizontalDimension: [Motif >= 1.1 only]

*** Type Information:

	Resource representation type XmRHorizontalDimension corresponds to
	WINTERP-Lisp type FIXNUM, and further restricts that type to the
	subrange of non-negative integers.

	If you specify a string as the value of an XmRHorizontalDimension, Motif
	1.1 will automatically convert the string to a vertical axis dimension
	using Motif's "resolution independence"	capabilities. For more
	information on resolution independence, see the :XMN_UNIT_TYPE
	(XmNunitType) resource description in the manual pages for XmGadget(3X),
	XmManager(3X), and XmPrimitive(3X). Also see the :XMN_SHELL_UNIT_TYPE
	(XmNshellUnitType) resource description in VendorShell(3X).

*** Resource names and the widget classes they apply to:

	:XMN_SPACING			XmNspacing

		XM_SCROLLED_WINDOW_WIDGET_CLASS
		XM_PANED_WINDOW_WIDGET_CLASS
		XM_ROW_COLUMN_WIDGET_CLASS
		XM_TOGGLE_BUTTON_WIDGET_CLASS XM_TOGGLE_BUTTON_GADGET_CLASS

		Note -- Motif 1.1 inconsistently declares resource XmNspacing:
			XmRDimension -- Xm/ScrolledW.c
			XmRHorizontalDimension -- Xm/RowColumn.c Xm/ToggleB.c Xm/ToggleBG.c
			XmRVerticalDimension -- Xm/PanedW.c
		In WINTERP, XmNspacing is treated as XmRHorizontalDimension for
		all widget classes. If you call :set_values :XMN_SPACING on
		a XM_SCROLLED_WINDOW_WIDGET_CLASS or
		XM_PANED_WINDOW_WIDGET_CLASS instance, note that when you give
		string argument as a resource value the string will be converted
		in terms of the current horizontal-dimension
		resolution-independence settings. For these cases, if you want
		resolution independent conversions, you must set this resource
		directly via ~/.Xdefaults, xrdb(1), etc. Alternately, just
		don't ask for resolution-independent conversions through
		WINTERP by specifying FIXNUM values to the problem resources.

	:XMN_SHADOW_THICKNESS		XmNshadowThickness

		<GADGET_CLASS> <PRIMITIVE_WIDGET_CLASS> <MANAGER_WIDGET_CLASS>
		XM_DRAWN_BUTTON_WIDGET_CLASS XM_SCROLLED_WINDOW_WIDGET_CLASS
		XM_BULLETIN_BOARD_WIDGET_CLASS XM_ROW_COLUMN_WIDGET_CLASS
		XM_CASCADE_BUTTON_WIDGET_CLASS XM_CASCADE_BUTTON_GADGET_CLASS
		XM_LABEL_WIDGET_CLASS XM_LABEL_GADGET_CLASS
		XM_PUSH_BUTTON_WIDGET_CLASS XM_PUSH_BUTTON_GADGET_CLASS
	   #ifdef SGI_DROP_POCKET_WIDGET
		SG_FINDER_WIDGET_CLASS
		SG_DROP_POCKET_WIDGET_CLASS
	   #endif /* SGI_DROP_POCKET_WIDGET */

	:XMN_HIGHLIGHT_THICKNESS	XmNhighlightThickness

		<GADGET_CLASS> <PRIMITIVE_WIDGET_CLASS>
		XM_CASCADE_BUTTON_WIDGET_CLASS XM_CASCADE_BUTTON_GADGET_CLASS
		XM_DRAWN_BUTTON_WIDGET_CLASS
		XM_LABEL_WIDGET_CLASS XM_LABEL_GADGET_CLASS
		XM_PUSH_BUTTON_WIDGET_CLASS XM_PUSH_BUTTON_GADGET_CLASS
		XM_SCALE_WIDGET_CLASS XM_SCROLL_BAR_WIDGET_CLASS
		XM_SEPARATOR_WIDGET_CLASS XM_SEPARATOR_GADGET_CLASS
		XM_TOGGLE_BUTTON_WIDGET_CLASS XM_TOGGLE_BUTTON_GADGET_CLASS
	   #ifdef SGI_DROP_POCKET_WIDGET
		SG_DROP_POCKET_WIDGET_CLASS
	   #endif /* SGI_DROP_POCKET_WIDGET */


	:XMN_HORIZONTAL_SPACING		XmNhorizontalSpacing

		XM_FORM_WIDGET_CLASS

	:XMN_WIDTH			XmNwidth

		<SHELL_WIDGET_CLASS> <GADGET_CLASS> <PRIMITIVE_CLASS>
		<MANAGER_CLASS> XM_SCALE_WIDGET_CLASS

	:XMN_BORDER_WIDTH		XmNborderWidth

		<SHELL_WIDGET_CLASS> <WIDGET_CLASS> <GADGET_CLASS>
		<PRIMITIVE_CLASS> <MANAGER_CLASS>

	:XMN_MARGIN_LEFT		XmNmarginLeft

		XM_LABEL_WIDGET_CLASS XM_LABEL_GADGET_CLASS

	:XMN_MARGIN_RIGHT		XmNmarginRight

		XM_LABEL_WIDGET_CLASS XM_LABEL_GADGET_CLASS

	:XMN_LIST_MARGIN_WIDTH		XmNlistMarginWidth

		XM_LIST_WIDGET_CLASS

	:XMN_MAIN_WINDOW_MARGIN_WIDTH	XmNmainWindowMarginWidth

		XM_MAIN_WINDOW_MARGIN_WIDTH

	:XMN_SASH_WIDTH			XmNsashWidth

		XM_PANED_WINDOW_WIDGET_CLASS

	:XMN_SASH_SHADOW_THICKNESS	XmNsashShadowThickness

		XM_PANED_WINDOW_WIDGET_CLASS
			
	:XMN_DEFAULT_BUTTON_SHADOW_THICKNESS XmNdefaultButtonShadowThickness

		XM_PUSH_BUTTON_WIDGET_CLASS XM_PUSH_BUTTON_GADGET_CLASS

	:XMN_ENTRY_BORDER		XmNentryBorder

		XM_ROW_COLUMN_WIDGET_CLASS

	:XMN_SCALE_WIDTH		XmNscaleWidth

		XM_SCALE_WIDGET_CLASS

	:XMN_SCROLLED_WINDOW_MARGIN_WIDTH XmNscrolledWindowMarginWidth

		XM_SCROLLED_WINDOW_WIDGET_CLASS

	:XMN_MARGIN			XmNmargin

#endif /* MOTIF_1.1 */
#ifdef MOTIF_1.2
	:XMN_CHILD_HORIZONTAL_SPACING	XmNchildHorizontalSpacing
	
		constraint resource from XM_FRAME_WIDGET_CLASS parent
#endif /* MOTIF_1.2 */

______________________________________________________________________________

#ifdef MOTIF_1.2
** XmRVerticalAlignment: [MOTIF >= 1.2 only]

*** Type Information:

	Resource representation type XmRVerticalAlignment corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:ALIGNMENT_BASELINE_TOP    XmALIGNMENT_BASELINE_TOP
		:ALIGNMENT_CENTER	   XmALIGNMENT_CENTER
		:ALIGNMENT_BASELINE_BOTTOM XmALIGNMENT_BASELINE_BOTTOM
		:ALIGNMENT_CONTENTS_TOP    XmALIGNMENT_CONTENTS_TOP
		:ALIGNMENT_CONTENTS_BOTTOM XmALIGNMENT_CONTENTS_BOTTOM

	You may also specify a STRING value which will be automatically
	converted to XmRVerticalAlignment by Motif's resource converters.
	These values would be the same as one would specify in
	$HOME/.Xdefaults.

*** Resource names and the widget classes they apply to:

	:XMN_ENTRY_VERTICAL_ALIGNMENT		XmNentryVerticalAlignment

		XM_ROW_COLUMN_WIDGET_CLASS

______________________________________________________________________________
#ifdef MOTIF_1.1
** XmRVerticalDimension: [Motif >= 1.1 only]

*** Type Information:

	Resource representation type XmRVerticalDimension corresponds to
	WINTERP-Lisp type FIXNUM, and further restricts that type to the
	subrange of non-negative integers.

	If you specify a string as the value of an XmRVerticalDimension, Motif
	1.1 will automatically convert the string to a vertical axis dimension
	using Motif's "resolution independence"	capabilities. For more
	information on resolution independence, see the :XMN_UNIT_TYPE
	(XmNunitType) resource description in the manual pages for XmGadget(3X),
	XmManager(3X), and XmPrimitive(3X). Also see the :XMN_SHELL_UNIT_TYPE
	(XmNshellUnitType) resource description in VendorShell(3X).

*** Resource names and the widget classes they apply to:

	:XMN_HEIGHT			XmNheight

		<WIDGET_CLASS> <SHELL_WIDGET_CLASS>

		Note -- Motif 1.1 inconsistently declares resource XmNheight:
			XmRShellVertDim -- Xm/Vendor.c
			XtRDimension -- Xt/RectObj.c
			XmRVerticalDimension -- Xm/Gadget.c Xm/Manager.c Xm/Primitive.c Xm/Scale.c

	:XMN_MARGIN_HEIGHT			XmNmarginHeight

		XM_BULLETIN_BOARD_WIDGET_CLASS XM_DRAWING_AREA_WIDGET_CLASS
		XM_FORM_WIDGET_CLASS XM_FRAME_WIDGET_CLASS 
		XM_LABEL_WIDGET_CLASS XM_LABEL_GADGET_CLASS
		XM_PANED_WIDGET_CLASS XM_ROW_COLUMN_WIDGET_CLASS
		XM_TEXT_WIDGET_CLASS XM_TEXT_FIELD_WIDGET_CLASS

	:XMN_VERTICAL_SPACING			XmNverticalSpacing

		XM_FORM_WIDGET_CLASS

	:XMN_MARGIN_TOP				XmNmarginTop

		XM_LABEL_WIDGET_CLASS XM_LABEL_GADGET_CLASS

	:XMN_MARGIN_BOTTOM			XmNmarginBottom

		XM_LABEL_WIDGET_CLASS XM_LABEL_GADGET_CLASS

	:XMN_LIST_SPACING			XmNlistSpacing

		XM_LIST_WIDGET_CLASS

	:XMN_LIST_MARGIN_HEIGHT			XmNlistMarginHeight

		XM_LIST_WIDGET_CLASS

	:XMN_MAIN_WINDOW_MARGIN_HEIGHT		XmNmainWindowMarginHeight

		XM_MAIN_WINDOW_WIDGET_CLASS

	:XMN_SASH_HEIGHT			XmNsashHeight

		XM_PANED_WIDGET_CLASS

	:XMN_PANE_MINIMUM			XmNpaneMinimum

		XM_PANED_WIDGET_CLASS

	:XMN_PANE_MAXIMUM			XmNpaneMaximum

		XM_PANED_WIDGET_CLASS

	:XMN_SCALE_HEIGHT			XmNscaleHeight

		XM_SCALE_WIDGET_CLASS

	:XMN_SCROLLED_WINDOW_MARGIN_HEIGHT	XmNscrolledWindowMarginHeight

		XM_SCROLLED_WINDOW_WIDGET_CLASS

	:XMN_INDICATOR_SIZE			XmNindicatorSize

		XM_TOGGLE_BUTTON_WIDGET_CLASS XM_TOGGLE_BUTTON_GADGET_CLASS

#endif /* MOTIF_1.1 */

______________________________________________________________________________

** XmRDefaultButtonType:

*** Type Information:

	Resource representation type XmRDefaultButtonType corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:DIALOG_OK_BUTTON		XmDIALOG_OK_BUTTON
		:DIALOG_CANCEL_BUTTON		XmDIALOG_CANCEL_BUTTON
		:DIALOG_HELP_BUTTON		XmDIALOG_HELP_BUTTON

	You may also specify a STRING value which will be automatically
	converted to XmRDefaultButtonType by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_DEFAULT_BUTTON_TYPE	XmNdefaultButtonType

		XM_MESSAGE_BOX_WIDGET_CLASS

______________________________________________________________________________

** XmRDeleteResponse:

*** Type Information:

	Resource representation type XmRDeleteResponse corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:DESTROY		XmDESTROY
		:UNMAP			XmUNMAP
		:DO_NOTHING		XmDO_NOTHING

	You may also specify a STRING value which will be automatically
	converted to XmRDeleteResponse by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_DELETE_RESPONSE		XmNdeleteResponse

		<SHELL_WIDGET_CLASS> XM_DIALOG_POPUP_SHELL_WIDGET_CLASS

______________________________________________________________________________

** XmRDialogStyle:

*** Type Information:

	Resource representation type XmRDialogStyle corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

   #ifdef MOTIF_1.0
		:DIALOG_WORK_AREA		XmDIALOG_WORK_AREA
		:DIALOG_MODELESS		XmDIALOG_MODELESS
		:DIALOG_APPLICATION_MODAL	XmDIALOG_APPLICATION_MODAL
		:DIALOG_SYSTEM_MODAL		XmDIALOG_SYSTEM_MODAL
   #endif
   #ifdef MOTIF_1.1
		:DIALOG_MODELESS                  XmDIALOG_MODELESS
		:DIALOG_PRIMARY_APPLICATION_MODAL XmDIALOG_PRIMARY_APPLICATION_MODAL
		:DIALOG_FULL_APPLICATION_MODAL    XmDIALOG_FULL_APPLICATION_MODAL
		:DIALOG_SYSTEM_MODAL              XmDIALOG_SYSTEM_MODAL
	
	Note 1: XmRDialogStyle value :DIALOG_APPLICATION_MODAL from Motif
	1.0 is obsolete, use :DIALOG_PRIMARY_APPLICATION_MODAL instead.

	Note 2: XmRDialogStyle value :DIALOG_WORK_AREA cannot be retrieved
	by WINTERP due to Motif 1.1 bug: enumeration XmDIALOG_WORK_AREA has
	same value (0) as XmDIALOG_MODELESS which means that if you set
	:DIALOG_WORK_AREA, method :GET_VALUES will retrieve :DIALOG_MODELESS
	(due to ordering...)
   #endif

	You may also specify a STRING value which will be automatically
	converted to XmRDialogStyle by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_DIALOG_STYLE		XmNdialogStyle

		XM_BULLETIN_BOARD_WIDGET_CLASS

______________________________________________________________________________

** XmRDialogType:

*** Type Information:

	Resource representation type XmRDialogType corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:
   #ifdef MOTIF_1.2
		:DIALOG_TEMPLATE	XmDIALOG_TEMPLATE
   #endif MOTIF_1.2
		:DIALOG_ERROR		XmDIALOG_ERROR
		:DIALOG_INFORMATION	XmDIALOG_INFORMATION
		:DIALOG_MESSAGE		XmDIALOG_MESSAGE
		:DIALOG_QUESTION	XmDIALOG_QUESTION
		:DIALOG_WARNING		XmDIALOG_WARNING
		:DIALOG_WORKING		XmDIALOG_WORKING
		:DIALOG_WORK_AREA	XmDIALOG_WORK_AREA
		:DIALOG_PROMPT		XmDIALOG_PROMPT
		:DIALOG_SELECTION	XmDIALOG_SELECTION
		:DIALOG_COMMAND		XmDIALOG_COMMAND
		:DIALOG_FILE_SELECTION	XmDIALOG_FILE_SELECTION

	You may also specify a STRING value which will be automatically
	converted to XmRDialogType by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.

   #ifdef MOTIF_1.1
	Note that Motif 1.1 introduced a new bug which makes it impossible
	to do a :GET_VALUES of a XmRDialogType resource and retrieve values
	:DIALOG_WORK_AREA, :DIALOG_PROMPT, :DIALOG_SELECTION, or :DIALOG_COMMAND.
	Even if you did a :SET_VALUES of an XmRDialogType resource to 
	:DIALOG_WORK_AREA, :DIALOG_PROMPT, :DIALOG_SELECTION, or :DIALOG_COMMAND,
	method :GET_VALUES will return:
		:DIALOG_TEMPLATE for :DIALOG_WORK_AREA (Motif 1.2 only).
		:DIALOG_ERROR for :DIALOG_PROMPT
		:DIALOG_INFORMATION for :DIALOG_SELECTION
		:DIALOG_MESSAGE for :DIALOG_COMMAND
	And that of course means that values set and then retrieved from
	an XmRDialogType resource will not necessary be EQ.
   #endif

*** Resource names and the widget classes they apply to:

	:XMN_DIALOG_TYPE		XmNdialogType

		XM_COMMAND_WIDGET_CLASS XM_FILE_SELECTION_BOX_WIDGET_CLASS
		XM_MESSAGE_BOX_WIDGET_CLASS XM_SELECTION_BOX_WIDGET_CLASS

______________________________________________________________________________

** XmREditMode:

*** Type Information:

	Resource representation type XmREditMode corresponds to an enumerated
	type. The following keyword symbols represent the valid	WINTERP-Lisp
	values for this type and their associated Motif constants:

		:MULTI_LINE_EDIT	XmMULTI_LINE_EDIT
		:SINGLE_LINE_EDIT	XmSINGLE_LINE_EDIT


*** Resource names and the widget classes they apply to:

	:XMN_EDIT_MODE			XmNeditMode

		XM_TEXT_WIDGET_CLASS
______________________________________________________________________________

#ifdef MOTIF_1.1
** XmRFileTypeMask: [Motif >= 1.1 only]

*** Type Information:

	Resource representation type XmRFileTypeMask corresponds to an enumerated
	type. The following keyword symbols represent the valid	WINTERP-Lisp
	values for this type and their associated Motif constants:

		:FILE_DIRECTORY		XmFILE_DIRECTORY
		:FILE_REGULAR		XmFILE_REGULAR
		:FILE_ANY_TYPE		XmFILE_ANY_TYPE

*** Resource names and the widget classes they apply to:

	:XMN_FILE_TYPE_MASK		XmNfileTypeMask

		XM_FILE_SELECTION_BOX_WIDGET_CLASS

#endif /* MOTIF_1.1 */
______________________________________________________________________________

** XmRFontList:

*** Type Information:

	The current version of WINTERP does not allow you to get
	a widget's XmRFontList value since WINTERP-Lisp doesn't currently
	support XmRFontList as a type. Adding this type was not a high
	priority in this first release of WINTERP; I expect to add it in a 
	subsequent release along with various XmString utilities that use
	the XmFontList type.

	One may set a XmRFontList resource by specifying a STRING value
	corresponding to the font's name. These string values will then get
	looked up using Motif's font-searching and font-cacheing utilities.
	You may specify any value that you would specify to a XmRFontList
	resource in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_BUTTON_FONT_LIST		XmNbuttonFontList

		XM_BULLETIN_BOARD_WIDGET_CLASS

	:XMN_LABEL_FONT_LIST		XmNlabelFontList

		XM_BULLETIN_BOARD_WIDGET_CLASS

	:XMN_TEXT_FONT_LIST		XmNtextFontList

		XM_BULLETIN_BOARD_WIDGET_CLASS

	:XMN_FONT_LIST			XmNfontList

		XM_LABEL_WIDGET_CLASS XM_LABEL_GADGET_CLASS XM_LIST_WIDGET_CLASS
		XM_SCALE_WIDGET_CLASS XM_TEXT_WIDGET_CLASS
	   #ifdef MOTIF_1.1
		XM_TEXT_FIELD_WIDGET_CLASS
	   #endif /* MOTIF_1.1
	   #ifdef HP_GRAPH_WIDGET
		XM_ARC_WIDGET_CLASS
	   #endif /* HP_GRAPH_WIDGET */

   #ifdef MOTIF_1.1
	:XMN_DEFAULT_FONT_LIST	XmNdefaultFontList

		<SHELL_WIDGET_CLASS> XM_MENU_POPUP_SHELL_WIDGET_CLASS

   #endif /* MOTIF_1.1 */
______________________________________________________________________________

** XmRIndicatorType:

*** Type Information:

	Resource representation type XmRIndicatorType corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:N_OF_MANY	XmN_OF_MANY
		:ONE_OF_MANY	XmONE_OF_MANY

	You may also specify a STRING value which will be automatically
	converted to XmRIndicatorType by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_INDICATOR_TYPE		XmNindicatorType

		XM_TOGGLE_BUTTON_WIDGET_CLASS XM_TOGGLE_BUTTON_GADGET_CLASS
______________________________________________________________________________

#ifdef MOTIF_1.1
** XmRInitialState: [Motif >= 1.1 only]

*** Type Information:

	Resource representation type XtRInitialState/XmRInitialState
	corresponds to an enumerated type. The following keyword symbols
	represent the valid WINTERP-Lisp this type and their associated
	X11/Motif constants:

		:WITHDRAWN_STATE	WithdrawnState
		:NORMAL_STATE		NormalState
		:ICONIC_STATE		IconicState

*** Resource names and the widget classes they apply to:

	:XMN_INITIAL_STATE		XmNinitialState

		<SHELL_WIDGET_CLASS> <POPUP_SHELL_WIDGET_CLASS>

#endif /* MOTIF_1.1 */

______________________________________________________________________________

** XmRInt:

*** Type Information:

	Resource representation type XmRInt corresponds to WINTERP-Lisp type
	FIXNUM. On architectures where the range of type 'long' is
	different from the range of type 'int', FIXNUM values exceeding the
	minimum and maximum 'int' limits will cause XLISP to signal an error.


*** Resource names and the widget classes they apply to:

	:XMN_MAPPING_DELAY		XmNmappingDelay

		XM_CASCADE_BUTTON_WIDGET_CLASS XM_CASCADE_BUTTON_GADGET_CLASS

	:XMN_HISTORY_ITEM_COUNT		XmNhistoryItemCount

		XM_COMMAND_WIDGET_CLASS

	:XMN_HISTORY_MAX_ITEMS		XmNhistoryMaxItems

		XM_COMMAND_WIDGET_CLASS

	:XMN_HISTORY_VISIBLE_ITEM_COUNT	XmNhistoryVisibleItemCount

		XM_COMMAND_WIDGET_CLASS

	:XMN_FRACTION_BASE		XmNfractionBase

		XM_FORM_WIDGET_CLASS

	:XMN_TOP_POSITION		XmNtopPosition

		Any <WIDGET_CLASS> that has XM_FORM_WIDGET_CLASS constraints.
	   #ifdef MOTIF_1.0
		XM_TEXT_WIDGET_CLASS (name changed to XmNtopCharacter in 1.1)
	   #endif /* MOTIF_1.0 */

	:XMN_BOTTOM_POSITION		XmNbottomPosition

		Any <WIDGET_CLASS> that has XM_FORM_WIDGET_CLASS constraints.

	:XMN_LEFT_POSITION		XmNleftPosition

		Any <WIDGET_CLASS> that has XM_FORM_WIDGET_CLASS constraints.

	:XMN_RIGHT_POSITION		XmNrightPosition

		Any <WIDGET_CLASS> that has XM_FORM_WIDGET_CLASS constraints.

	:XMN_TOP_OFFSET			XmNtopOffset

		Any <WIDGET_CLASS> that has XM_FORM_WIDGET_CLASS constraints.

	:XMN_BOTTOM_OFFSET		XmNbottomOffset

		Any <WIDGET_CLASS> that has XM_FORM_WIDGET_CLASS constraints.


	:XMN_LEFT_OFFSET		XmNleftOffset

		Any <WIDGET_CLASS> that has XM_FORM_WIDGET_CLASS constraints.

	:XMN_RIGHT_OFFSET		XmNrightOffset

		Any <WIDGET_CLASS> that has XM_FORM_WIDGET_CLASS constraints.

	:XMN_ITEM_COUNT			XmNitemCount

		XM_LIST_WIDGET_CLASS

	:XMN_SELECTED_ITEM_COUNT	XmNselectedItemCount

		XM_LIST_WIDGET_CLASS

	:XMN_VISIBLE_ITEM_COUNT		XmNvisibleItemCount

		XM_LIST_WIDGET_CLASS

	:XMN_DOUBLE_CLICK_INTERVAL	XmNdoubleClickInterval

		XM_LIST_WIDGET_CLASS
    #ifdef HP_GRAPH_WIDGET
		XM_GRAPH_WIDGET_CLASS
    #endif /* HP_GRAPH_WIDGET */
			
	:XMN_VALUE			XmNvalue

		XM_SCALE_WIDGET_CLASS XM_SCROLL_BAR_WIDGET_CLASS

		Note -- resource name :XMN_VALUE will not set or
		retrieve a string value in XM_TEXT_WIDGET_CLASS instances.
		Motif 1.0 & 1.1 has a bug that inconsistently declares the value
		associated with the "message" XmNvalue as 'int' for 
		XM_SCALE_WIDGET_CLASS XM_SCROLL_BAR_WIDGET_CLASS, and
		as a 'string' for the text widget. Thus, to retrieve or
		set the string in a text widget, use the alias resource name
		:XMN_STRING.

	:XMN_MAXIMUM			XmNmaximum

		XM_SCALE_WIDGET_CLASS XM_SCROLL_BAR_WIDGET_CLASS
	    #ifdef MOTIF_1.0
		XM_PANED_WINDOW_WIDGET_CLASS
	    #else
		For Motif 1.1's XM_PANED_WINDOW_WIDGET_CLASS, :XMN_MAXIMUM
		has been changed to :XMN_PANE_MAXIMUM.
	    #endif /* MOTIF_1.0 */

	:XMN_MINIMUM			XmNminimum

		XM_SCALE_WIDGET_CLASS XM_SCROLL_BAR_WIDGET_CLASS
	    #ifdef MOTIF_1.0
		XM_PANED_WINDOW_WIDGET_CLASS
	    #else
		For Motif 1.1's XM_PANED_WINDOW_WIDGET_CLASS, :XMN_MINIMUM
		has been changed to :XMN_PANE_MINIMUM.
	    #endif /* MOTIF_1.0 */

	:XMN_SLIDER_SIZE		XmNsliderSize

		XM_SCROLL_BAR_WIDGET_CLASS

	:XMN_INCREMENT			XmNincrement

		XM_SCROLL_BAR_WIDGET_CLASS

	:XMN_PAGE_INCREMENT		XmNpageIncrement

		XM_SCROLL_BAR_WIDGET_CLASS

	:XMN_INITIAL_DELAY		XmNinitialDelay

		XM_SCROLL_BAR_WIDGET_CLASS

	:XMN_REPEAT_DELAY		XmNrepeatDelay

		XM_SCROLL_BAR_WIDGET_CLASS

	:XMN_LIST_ITEM_COUNT		XmNlistItemCount

		XM_SELECTION_BOX_WIDGET_CLASS

	:XMN_LIST_VISIBLE_ITEM_COUNT	XmNlistVisibleItemCount

		XM_SELECTION_BOX_WIDGET_CLASS

	:XMN_MAX_LENGTH			XmNmaxLength

		XM_TEXT_WIDGET_CLASS
	    #ifdef MOTIF_1.1
		XM_TEXT_FIELD_WIDGET_CLASS
	    #endif /* MOTIF_1.1 */

	:XMN_BLINK_RATE			XmNblinkRate

		XM_TEXT_WIDGET_CLASS
	    #ifdef MOTIF_1.1
		XM_TEXT_FIELD_WIDGET_CLASS
	    #endif /* MOTIF_1.1 */

	:XMN_SELECTION_ARRAY_COUNT	XmNselectionArrayCount

		XM_TEXT_WIDGET_CLASS
	    #ifdef MOTIF_1.1
		XM_TEXT_FIELD_WIDGET_CLASS
	    #endif /* MOTIF_1.1 */

	:XMN_SELECT_THRESHOLD		XmNselectThreshold

		XM_TEXT_WIDGET_CLASS
	    #ifdef MOTIF_1.1
		XM_TEXT_FIELD_WIDGET_CLASS
	    #endif /* MOTIF_1.1 */

	:XMN_MWM_DECORATIONS		XmNmwmDecorations

		<SHELL_WIDGET_CLASS>

		Note: The value supplied or retrieved via resource
		:XMN_MWM_DECORATIONS is a FIXNUM mask that can be created by
		doing the logical inclusive or (see function 'logior') of
		the following symbol's values:
			MWM_DECOR_ALL MWM_DECOR_BORDER MWM_DECOR_RESIZEH 
			MWM_DECOR_TITLE MWM_DECOR_MENU
			MWM_DECOR_MINIMIZE MWM_DECOR_MAXIMIZE

	:XMN_MWM_FUNCTIONS		XmNmwmFunctions

		<SHELL_WIDGET_CLASS>

		Note: The value supplied or retrieved via resource
		:XMN_MWM_FUNCTIONS is a FIXNUM mask that can be created by
		doing the logical inclusive or (see function 'logior') of
		the following symbol's values:
			MWM_FUNC_ALL MWM_FUNC_RESIZE MWM_FUNC_MOVE
			MWM_FUNC_MINIMIZE MWM_FUNC_MAXIMIZE MWM_FUNC_CLOSE

	:XMN_MWM_INPUT_MODE		XmNmwmInputMode

		<SHELL_WIDGET_CLASS>

		Note: The value supplied or retrieved via resource
		:XMN_MWM_INPUT_MODE is a FIXNUM mask that can be created by
		doing the logical inclusive or (see function 'logior') of
		the following symbol's values:
		   #ifdef MOTIF_1.1
			MWM_INPUT_MODELESS MWM_INPUT_PRIMARY_APPLICATION_MODAL
			MWM_INPUT_SYSTEM_MODAL MWM_INPUT_FULL_APPLICATION_MODAL
		   #endif /* MOTIF_1.1 */
		   #ifdef MOTIF_1.0
			MWM_INPUT_MODELESS MWM_INPUT_APPLICATION_MODAL
			MWM_INPUT_SYSTEM_MODAL
		   #endif

	:XMN_DEPTH			XmNdepth

		<SHELL_WIDGET_CLASS> <WIDGET_CLASS>

	:XMN_WM_TIMEOUT			XmNwmTimeout

		<SHELL_WIDGET_CLASS>

   #ifdef MOTIF_1.1

	:XMN_DIR_LIST_ITEM_COUNT	XmNdirListItemCount

		XM_FILE_SELECTION_BOX_WIDGET_CLASS

	:XMN_FILE_LIST_ITEM_COUNT	XmNfileListItemCount

		XM_FILE_SELECTION_BOX_WIDGET_CLASS

	:XMN_TOP_ITEM_POSITION		XmNtopItemPosition

		XM_LIST_WIDGET_CLASS

	:XMN_POST_FROM_COUNT		XmNpostFromCount

		XM_ROW_COLUMN_WIDGET_CLASS

	:XMN_SCALE_MULTIPLE		XmNscaleMultiple

		XM_SCALE_WIDGET_CLASS

	:XMN_BUTTON_COUNT		XmNbuttonCount

		<XM_ROW_COLUMN_WIDGET_CLASS created w/ :SIMPLE_*>

	:XMN_POST_FROM_BUTTON		XmNpostFromButton

		<XM_ROW_COLUMN_WIDGET_CLASS created w/ :SIMPLE_*>

	:XMN_BUTTON_SET			XmNbuttonSet

		<XM_ROW_COLUMN_WIDGET_CLASS created w/ :SIMPLE_*>

   #endif /* MOTIF_1.1 */

   #ifdef MOTIF_1.0

	:XMN_MIN_WIDTH			XmNminWidth

		<SHELL_WIDGET_CLASS>

	:XMN_MAX_WIDTH			XmNmaxWidth

		<SHELL_WIDGET_CLASS>

	:XMN_MIN_HEIGHT			XmNminHeight

		<SHELL_WIDGET_CLASS>

	:XMN_MAX_HEIGHT			XmNmaxHeight

		<SHELL_WIDGET_CLASS>

	:XMN_WIDTH_INC			XmNwidthInc

		<SHELL_WIDGET_CLASS>

	:XMN_HEIGHT_INC			XmNheightInc

		<SHELL_WIDGET_CLASS>

	:XMN_MIN_ASPECT_X		XmNminAspectX

		<SHELL_WIDGET_CLASS>

	:XMN_MIN_ASPECT_Y		XmNminAspectY

		<SHELL_WIDGET_CLASS>

	:XMN_MAX_ASPECT_X		XmNmaxAspectX

		<SHELL_WIDGET_CLASS>

	:XMN_MAX_ASPECT_Y		XmNmaxAspectY

		<SHELL_WIDGET_CLASS>

    #ifdef MOTIF_1.0
	:XMN_INITIAL_STATE		XmNinitialState

		<SHELL_WIDGET_CLASS>
    #else
		Note: In Motif 1.1, :XMN_INITIAL_STATE is an enumerated
		type, see section on resource representation type
		XtRInitialState.
    #endif /* MOTIF_1.0 */

	:XMN_ICON_X			XmNiconX

		<SHELL_WIDGET_CLASS>

	:XMN_ICON_Y			XmNiconY

		<SHELL_WIDGET_CLASS>

	:XMN_HORIZONTAL_SPACING		XmNhorizontalSpacing

		XM_FORM_WIDGET_CLASS

	:XMN_VERTICAL_SPACING		XmNverticalSpacing

		XM_FORM_WIDGET_CLASS

	:XMN_SASH_SHADOW_THICKNESS	XmNsashShadowThickness

		XM_PANED_WINDOW_WIDGET_CLASS

	:XMN_CURSOR_POSITION		XmNcursorPosition

		XM_TEXT_WIDGET_CLASS

   #endif /* MOTIF 1.0 */

    #ifdef HP_GRAPH_WIDGET

	:XMN_CHILD_SPACING		XmNchildSpacing

		XM_GRAPH_WIDGET_CLASS

	:XMN_SIBLING_SPACING		XmNsiblingSpacing

		XM_GRAPH_WIDGET_CLASS

	:XMN_SNAP_GRID_SIZE		XmNsnapGridSize

		XM_GRAPH_WIDGET_CLASS

	:XMN_DELTA			XmNdelta

		XM_ARC_WIDGET_CLASS

	:XMN_ARC_WIDTH			XmNarcWidth

		XM_ARC_WIDGET_CLASS

	:XMN_DASHES			XmNdashes

		XM_ARC_WIDGET_CLASS

	:XMN_DASH_OFFSET		XmNdashOffset

		XM_ARC_WIDGET_CLASS

    #endif /* HP_GRAPH_WIDGET */
______________________________________________________________________________

#ifdef MOTIF_1.1
** XmRHorizontalInt: [Motif >= 1.1 only]

*** Type Information:

	Resource representation type XmRHorizontalInt corresponds to
	WINTERP-Lisp type FIXNUM. On architectures where the range of type
	'long' is different from the range of type 'int', FIXNUM values
	exceeding the minimum and maximum 'int' limits will cause XLISP to
	signal an error.

	If you specify a string as the value of an XmRHorizontalInt, Motif
	1.1 will automatically convert the string to a horizontal axis
	size or position using Motif's "resolution independence"
	capabilities. For more information on resolution independence, see
	the :XMN_UNIT_TYPE (XmNunitType) resource description in the manual
	pages for XmGadget(3X), XmManager(3X), and XmPrimitive(3X). Also see the
	:XMN_SHELL_UNIT_TYPE (XmNshellUnitType) resource description in
	VendorShell(3X).


*** Resource names and the widget classes they apply to:

	:XMN_BASE_WIDTH			XmNbaseWidth

		<SHELL_WIDGET_CLASS>

	:XMN_MIN_WIDTH			XmNminWidth

		<SHELL_WIDGET_CLASS>

	:XMN_MAX_WIDTH			XmNmaxWidth

		<SHELL_WIDGET_CLASS>

	:XMN_WIDTH_INC			XmNwidthInc

		<SHELL_WIDGET_CLASS>

	:XMN_MIN_ASPECT_X		XmNminAspectX

		<SHELL_WIDGET_CLASS>

	:XMN_MAX_ASPECT_X		XmNmaxAspectX

		<SHELL_WIDGET_CLASS>

	:XMN_ICON_X			XmNiconX

		<SHELL_WIDGET_CLASS>

#endif /* MOTIF_1.1 */

______________________________________________________________________________

#ifdef MOTIF_1.1
** XmRVerticalInt: [Motif >= 1.1 only]

*** Type Information:

	Resource representation type XmRVerticalInt corresponds to
	WINTERP-Lisp type FIXNUM. On architectures where the range of type
	'long' is different from the range of type 'int', FIXNUM values
	exceeding the minimum and maximum 'int' limits will cause XLISP to
	signal an error.

	If you specify a string as the value of an XmRVerticalInt, Motif
	1.1 will automatically convert the string to a vertical axis
	size or position using Motif's "resolution independence"
	capabilities. For more information on resolution independence, see
	the :XMN_UNIT_TYPE (XmNunitType) resource description in the manual
	pages for XmGadget(3X), XmManager(3X), and XmPrimitive(3X). Also see the
	:XMN_SHELL_UNIT_TYPE (XmNshellUnitType) resource description in
	VendorShell(3X).


*** Resource names and the widget classes they apply to:

	:XMN_BASE_HEIGHT		XmNbaseHeight

		<SHELL_WIDGET_CLASS>

	:XMN_MIN_HEIGHT			XmNminHeight

		<SHELL_WIDGET_CLASS>

	:XMN_MAX_HEIGHT			XmNmaxHeight

		<SHELL_WIDGET_CLASS>

	:XMN_HEIGHT_INC			XmNheightInc

		<SHELL_WIDGET_CLASS>

	:XMN_MIN_ASPECT_Y		XmNminAspectY

		<SHELL_WIDGET_CLASS>
		
	:XMN_MAX_ASPECT_Y		XmNmaxAspectY

		<SHELL_WIDGET_CLASS>

	:XMN_ICON_Y			XmNiconY

		<SHELL_WIDGET_CLASS>		

#endif /* MOTIF_1.1 */

______________________________________________________________________________

** XmRKeyboardFocusPolicy:

*** Type Information:

	Resource representation type XmRKeyboardFocusPolicy corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:EXPLICIT		XmEXPLICIT
		:POINTER		XmPOINTER

	You may also specify a STRING value which will be automatically
	converted to XmRKeyboardFocusPolicy by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_KEYBOARD_FOCUS_POLICY	XmNkeyboardFocusPolicy

		<SHELL_WIDGET_CLASS> <POPUP_SHELL_WIDGET_CLASS>

______________________________________________________________________________

** XmRLabelType:

*** Type Information:

	Resource representation type XmRLabelType corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:PIXMAP		XmPIXMAP
		:STRING		XmSTRING

	You may also specify a STRING value which will be automatically
	converted to XmRLabelType by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_LABEL_TYPE			XmNlabelType

		XM_LABEL_WIDGET_CLASS XM_LABEL_GADGET_CLASS

______________________________________________________________________________
#ifdef HP_GRAPH_WIDGET

** XmRLineStyle [HP_GRAPH_WIDGET only]:

*** Type Information:

	Resource representation type XmRLineStyle corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:LINE_SOLID		XmLineSolid
		:LINE_ON_OFF_DASH	XmLineOnOffDash
		:LINE_DOUBLE_DASH	XmLineDoubleDash

	You may also specify a STRING value which will be automatically
	converted to XmRLineStyle by Motif's resource converters.
	These values would be the same as one would specify in
	$HOME/.Xdefaults.

*** Resource names and the widget classes they apply to:

	:XMN_STYLE			XmNstyle

		XM_ARC_WIDGET_CLASS

#endif /* HP_GRAPH_WIDGET */
______________________________________________________________________________

** XmRListSizePolicy:

*** Type Information:

	Resource representation type XmRListSizePolicy corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:VARIABLE		XmVARIABLE
		:CONSTANT		XmCONSTANT
		:RESIZE_IF_POSSIBLE	XmRESIZE_IF_POSSIBLE

	You may also specify a STRING value which will be automatically
	converted to XmRListSizePolicy by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_LIST_SIZE_POLICY		XmNlistSizePolicy

		XM_LIST_WIDGET_CLASS
______________________________________________________________________________

#ifdef MOTIF_1.1
** XmRMultiClick: [Motif >= 1.1 only]

*** Type Information:

	Resource representation type XmRMultiClick corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:MULTICLICK_DISCARD		XmMULTICLICK_DISCARD
		:MULTICLICK_KEEP		XmMULTICLICK_KEEP

	You may also specify a STRING value which will be automatically
	converted to XmRMultiClick by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_MULTI_CLICK		XmNmultiClick

		XM_ARROW_BUTTON_WIDGET_CLASS XM_ARROW_BUTTON_GADGET_CLASS
		XM_DRAWN_BUTTON_WIDGET_CLASS
		XM_PUSH_BUTTON_WIDGET_CLASS XM_PUSH_BUTTON_GADGET_CLASS

#endif /* MOTIF_1.1 */

______________________________________________________________________________

#ifdef MOTIF_1.1
** XmRNavigationType: [Motif >= 1.1 only]

*** Type Information:

	Resource representation type XmRNavigationType corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:NONE			XmNONE
		:TAB_GROUP		XmTAB_GROUP
		:STICKY_TAB_GROUP	XmSTICKY_TAB_GROUP
		:EXCLUSIVE_TAB_GROUP	XmEXCLUSIVE_TAB_GROUP

	You may also specify a STRING value which will be automatically
	converted to XmRNavigationType by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_NAVIGATION_TYPE		XmNnavigationType

		<GADGET_CLASS> <MANAGER_CLASS> <PRIMITIVE_CLASS>
		XM_LIST_WIDGET_CLASS XM_MAIN_WINDOW_WIDGET_CLASS
		XM_ROW_COLUMN_WIDGET_CLASS XM_SCROLL_BAR_WIDGET_CLASS
		XM_TEXT_WIDGET_CLASS XM_TEXT_FIELD_WIDGET_CLASS
	   #ifdef SGI_DROP_POCKET_WIDGET
		SG_FINDER_WIDGET_CLASS
		SG_DROP_POCKET_WIDGET_CLASS
	   #endif /* SGI_DROP_POCKET_WIDGET */

#endif /* MOTIF_1.1 */

______________________________________________________________________________

** XmROrientation:

*** Type Information:

	Resource representation type XmROrientation corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:NO_ORIENTATION		XmNO_ORIENTATION
		:VERTICAL		XmVERTICAL
		:HORIZONTAL		XmHORIZONTAL

	You may also specify a STRING value which will be automatically
	converted to XmROrientation by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_ORIENTATION		XmNorientation

		XM_ROW_COLUMN_WIDGET_CLASS XM_SCALE_WIDGET_CLASS
		XM_SCROLL_BAR_WIDGET_CLASS
		XM_SEPARATOR_GADGET_CLASS XM_SEPARATOR_WIDGET_CLASS
    #ifdef HP_GRAPH_WIDGET
		XM_GRAPH_WIDGET_CLASS
    #endif /* HP_GRAPH_WIDGET */

______________________________________________________________________________

** XmRPacking:

*** Type Information:

	Resource representation type XmRPacking corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:NO_PACKING		XmNO_PACKING
		:PACK_TIGHT		XmPACK_TIGHT
		:PACK_COLUMN		XmPACK_COLUMN
		:PACK_NONE		XmPACK_NONE

	You may also specify a STRING value which will be automatically
	converted to XmRPacking by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_PACKING			XmNpacking

		XM_ROW_COLUMN_WIDGET_CLASS
______________________________________________________________________________

** XmRPixel:

*** Type Information:

	Resource representation type XmRPixel corresponds to the
	WINTERP-Lisp atomic type PIXEL, which is X's way of representing
	a color.

	One may set XmRPixel resources by specifying a STRING color name,
	just as you would in $HOME/.Xdefaults. Alternatively, one can use
	the result of primitive	X_ALLOC_COLOR,
	X_STORE_COLOR/X_ALLOC_N_COLOR_CELLS_NO_PLANES, or the result of
	:get_values on the XmRPixel resource of another widget.


*** Resource names and the widget classes they apply to:

	:XMN_FOREGROUND			XmNforeground

		<MANAGER_WIDGET_CLASS> <PRIMITIVE_WIDGET_CLASS>

	:XMN_BACKGROUND			XmNbackground

		<MANAGER_WIDGET_CLASS> <PRIMITIVE_WIDGET_CLASS> <WIDGET_CLASS>

	:XMN_HIGHLIGHT_COLOR		XmNhighlightColor

		<MANAGER_WIDGET_CLASS> <PRIMITIVE_WIDGET_CLASS>

	:XMN_TOP_SHADOW_COLOR		XmNtopShadowColor

		<MANAGER_WIDGET_CLASS> <PRIMITIVE_WIDGET_CLASS>

	:XMN_BOTTOM_SHADOW_COLOR	XmNbottomShadowColor

		<MANAGER_WIDGET_CLASS> <PRIMITIVE_WIDGET_CLASS>

	:XMN_ARM_COLOR			XmNarmColor

		XM_PUSH_BUTTON_WIDGET_CLASS XM_PUSH_BUTTON_GADGET_CLASS

   #ifdef MOTIF_1.1
	:XMN_TROUGH_COLOR		XmNtroughColor

		XM_SCROLL_BAR_WIDGET_CLASS
   #endif /* MOTIF_1.1 */

	:XMN_SELECT_COLOR		XmNselectColor

		XM_TOGGLE_BUTTON_WIDGET_CLASS XM_TOGGLE_BUTTON_GADGET_CLASS

	:XMN_BORDER_COLOR		XmNborderColor

		<WIDGET_CLASS>

   #ifdef SGI_DROP_POCKET_WIDGET

	:SGN_ACTIVE_PIXEL		SgNactivePixel

		SG_DROP_POCKET_WIDGET_CLASS

   #endif /* SGI_DROP_POCKET_WIDGET */


______________________________________________________________________________

** XmRPixmap, XmRPrimForegroundPixmap, XmRManForegroundPixmap, XmRPrimHighlightPixmap, XmRManHighlightPixmap:

*** Type Information:

	Resource representation type XmR*Pixmap corresponds to the
	WINTERP-Lisp atomic type PIXMAP as returned by primitive
	XM_GET_PIXMAP. Pixmaps are used by widgets to display
	graphical images.
	
	One may set Pixmap resources by specifying the STRING name of
	the pixmap. Pixmaps get named by "installing" an XImage with an
	associated name by using primitive XM_INSTALL_IMAGE. If a named
	pixmap cannot be found, then the pixmap name is taken as a filename
	for an X10 or X11 bitmap file. The pixmap name must either have a
	fully qualified path-name, or be on the	file path specified by
	environment variable XBMLANGPATH, or must be in Motif's default
	pixmap search path. For more information, see the documentation for
	XmGetPixmap(X).

	Additionally, Motif defines the following preinstalled pixmap
	names: "background", "25_foreground", "50_foreground",
	"75_foreground", "vertical", "horizontal", "slant_right",
	"slant_left", "menu_cascade", and "menu_checkmark".
	
	Note that if you specify a string value for a pixmap at
	widget-creation time, Motif's string --> pixmap converters may
	retrieve the wrong colors for the pixmap -- you'll get back a
	pixmap using the default foreground, background, and highlight
	colors of *TOPLEVEL_WIDGET*. If you set a pixmap resource via
	:SET_VALUES, the pixmap will use the widget manager's foreground
	and background colors. If these default colors are not appropriate,
	you should set pixmap resources to the result of primitive XM_GET_PIXMAP.


*** Garbage Collection of Pixmaps:

	Unused pixmaps are garbage collected by WINTERP -- if no
	references to them exist in any WIDGETOBJ or other WINTERP-XLISP
	variable, their server and client-side storage will get reclaimed.
	In other words, PIXMAPs do what you'd expect them to do in a Lispy
	garbage	collected system. This is certainly useful and good to do
	because we can expect pixmaps to take up a reasonable amount of
	client and server space -- we should be efficient about their use,
	especially because Motif has made it easy to do so.

	Motif provides an explicit function XmDestroyPixmap() to deallocate
	unused pixmaps. Unfortunately, it is often difficult for a user to know
	when a pixmap is no longer being used. If a user calls
	XmDestroyPixmap() on a pixmap that is still being used by a widget, 
	a guaranteed coredump will result due to an "X Protocol Error".
	Therefore, WINTERP provides no interface to XmDestroyPixmap();
	instead it extends XLISP's mark/sweep garbage collector to use
	the reference counting and pixmap cacheing scheme of
	XmGetPixmap() and XmDestroyPixmap().

	Unfortunately, the XImage* behind the pixmap still persists
	even if all pixmaps based on a particular Ximage no longer exist.
	Since XImages can be implicitly created inside XmGetPixmap(), or
	through a String-->Xm*Pixmap* conversion it will be very hard to
	get a hold of the actual XImage pointer when all we have access to
	are the name-strings of the previously installed images or the
	filenames of new images installed.  Either we'll have to prevent
	creating cached XImages inside XmGetPixmap() and the
	XmString-->Xm*Pixmap* converters, and do all this ourselves, or we
	can just punt. I'm going to punt on the harder problem, and let
	people that care about this use the primitives XM_INSTALL_IMAGE
	XM_UNINSTALL_IMAGE.

	Rather than having XmGetPixmap() or the String-->Xm*Pixmap*
	converters implicitly create XImage's, you should pre-create
	the necessary <XImage_obj> by using
	XM_INSTALL_IMAGE(XM_GET_IMAGE_FROM_FILE(<image_file_name>)) at
	application startup time. Later, you may explicitly destroy the
	<XImage_obj> via primitive XM_UNINSTALL_IMAGE when the XImage is no
	longer needed.	Destroying an XImage after creating the	necessary
	pixmaps from it	shouldn't cause any protocol errors, so	this is the
	thing to do.


*** Resource names and the widget classes they apply to:


	:XMN_ICON_PIXMAP		XmNiconPixmap

		<SHELL_WIDGET_CLASS> -- XmRPixmap

	:XMN_ICON_MASK			XmNiconMask

		<SHELL_WIDGET_CLASS> -- XmRPixmap

	:XMN_BACKGROUND_PIXMAP		XmNbackgroundPixmap

		<WIDGET_CLASS> -- XmRPixmap
		<XM_MANAGER_WIDGET_CLASS> -- XmRXmBackgroundPixmap
		<XM_PRIMITIVE_WIDGET_CLASS> -- XmRXmBackgroundPixmap

	:XMN_BORDER_PIXMAP		XmNborderPixmap

		<WIDGET_CLASS> -- XmRPixmap

	:XMN_LABEL_INSENSITIVE_PIXMAP	XmNlabelInsensitivePixmap

		XM_LABEL_WIDGET_CLASS -- XmRPixmap
		XM_LABEL_GADGET_CLASS -- XmRGadgetPixmap

	:XMN_SELECT_INSENSITIVE_PIXMAP	XmNselectInsensitivePixmap

		XM_TOGGLE_BUTTON_GADGET_CLASS -- XmRPixmap
		XM_TOGGLE_BUTTON_WIDGET_CLASS -- XmRGadgetPixmap

	:XMN_SELECT_PIXMAP		XmNselectPixmap

		XM_TOGGLE_BUTTON_WIDGET_CLASS -- XmRPrimForegroundPixmap;
		XM_TOGGLE_BUTTON_GADGET_CLASS -- XmRPixmap

	:XMN_CASCADE_PIXMAP		XmNcascadePixmap

		XM_CASCADE_BUTTON_WIDGET_CLASS -- XmRPrimForegroundPixmap
		XM_CASCADE_BUTTON_GADGET_CLASS -- XmRGadgetPixmap

	:XMN_LABEL_PIXMAP		XmNlabelPixmap

		XM_LABEL_WIDGET_CLASS -- XmRPrimForegroundPixmap
		XM_LABEL_GADGET_CLASS -- XmRManForegroundPixmap

	:XMN_HIGHLIGHT_PIXMAP		XmNhighlightPixmap

		<XM_PRIMITIVE_WIDGET_CLASS> -- XmRPrimHighlightPixmap
		<XM_MANAGER_WIDGET_CLASS> -- XmRManHighlightPixmap

	:XMN_ARM_PIXMAP			XmNarmPixmap

		XM_PUSH_BUTTON_WIDGET_CLASS -- XmRPrimForegroundPixmap
		XM_PUSH_BUTTON_GADGET_CLASS -- XmRGadgetPixmap

	:XMN_SYMBOL_PIXMAP		XmNsymbolPixmap

		XM_MESSAGE_BOX_WIDGET_CLASS -- XmRManForegroundPixmap

	:XMN_TOP_SHADOW_PIXMAP		XmNtopShadowPixmap

		<XM_PRIMITIVE_WIDGET_CLASS> -- XmRPrimTopShadowPixmap;
		<XM_MANAGER_WIDGET_CLASS> -- XmRManTopShadowPixmap

	:XMN_BOTTOM_SHADOW_PIXMAP	XmNbottomShadowPixmap

		<XM_PRIMITIVE_WIDGET_CLASS> -- XmRPrimBottomShadowPixmap;
		<XM_MANAGER_WIDGET_CLASS> -- XmRManBottomShadowPixmap

   #ifdef SGI_DROP_POCKET_WIDGET

	:SGN_HISTORY_PIXMAP		SgNhistoryPixmap

		SG_FINDER_WIDGET_CLASS

	:SGN_INSENSITIVE_HISTORY_PIXMAP SgNinsensitiveHistoryPixmap

		SG_FINDER_WIDGET_CLASS

   #endif /* SGI_DROP_POCKET_WIDGET */

______________________________________________________________________________

#ifdef MOTIF_1.0
** XmRPosition: [Motif 1.0 only]

*** Type Information:

	Resource representation type XmRPosition corresponds to
	WINTERP-Lisp type FIXNUM. Note that on some architectures, 
	WINTERP will signal an XLISP error if the FIXNUM is too
	large or too small of an integer.

	You may also specify a STRING value which will be automatically
	converted to XmRPosition by Motif's resource converters.


*** Resource names and the widget classes they apply to:

	:XMN_X				XmNx

		<WIDGET_CLASS> <SHELL_WIDGET_CLASS>

	:XMN_Y				XmNy

		<WIDGET_CLASS> <SHELL_WIDGET_CLASS>

	:XMN_SASH_INDENT		XmNsashIndent

		XM_PANED_WINDOW_WIDGET_CLASS

#endif /* MOTIF_1.0 */

______________________________________________________________________________

#ifdef MOTIF_1.1
** XmRHorizontalPosition: [Motif >= 1.1 only]

*** Type Information:

	Resource representation type XmRHorizontalPosition corresponds to
	WINTERP-Lisp type FIXNUM. Note that on some architectures, 
	WINTERP will signal an XLISP error if the FIXNUM is too
	large or too small of an integer.

	If you specify a string as the value of an XmRHorizontalPosition, Motif
	1.1 will automatically convert the string to a horizontal axis position
	using Motif's "resolution independence"	capabilities. For more
	information on resolution independence, see the :XMN_UNIT_TYPE
	(XmNunitType) resource description in the manual pages for XmGadget(3X),
	XmManager(3X), and XmPrimitive(3X). Also see the :XMN_SHELL_UNIT_TYPE
	(XmNshellUnitType) resource description in VendorShell(3X).

*** Resource names and the widget classes they apply to:

	:XMN_X				XmNx

		<WIDGET_CLASS> <SHELL_WIDGET_CLASS>

	:XMN_SASH_INDENT		XmNsashIndent

		XM_PANED_WINDOW_WIDGET_CLASS

#endif /* MOTIF_1.1 */

______________________________________________________________________________

#ifdef MOTIF_1.1
** XmRVerticalPosition: [Motif >= 1.1 only]

*** Type Information:

	Resource representation type XmRVerticalPosition corresponds to
	WINTERP-Lisp type FIXNUM. Note that on some architectures, 
	WINTERP will signal an XLISP error if the FIXNUM is too
	large or too small of an integer.

	If you specify a string as the value of an XmRVerticalPosition, Motif
	1.1 will automatically convert the string to a vertical axis position
	using Motif's "resolution independence"	capabilities. For more
	information on resolution independence, see the :XMN_UNIT_TYPE
	(XmNunitType) resource description in the manual pages for XmGadget(3X),
	XmManager(3X), and XmPrimitive(3X). Also see the :XMN_SHELL_UNIT_TYPE
	(XmNshellUnitType) resource description in VendorShell(3X).

*** Resource names and the widget classes they apply to:

	:XMN_Y				XmNy

		<WIDGET_CLASS> <SHELL_WIDGET_CLASS>

#endif /* MOTIF_1.1 */

______________________________________________________________________________

** XmRProcessingDirection:

*** Type Information:

	Resource representation type XmRProcessingDirection corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:MAX_ON_TOP		XmMAX_ON_TOP
		:MAX_ON_BOTTOM		XmMAX_ON_BOTTOM
		:MAX_ON_LEFT		XmMAX_ON_LEFT
		:MAX_ON_RIGHT		XmMAX_ON_RIGHT

	You may also specify a STRING value which will be automatically
	converted to XmRProcessingDirection by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.

   #ifdef MOTIF_1.0
	Note -- :GET_VALUES on a horizontally oriented scale or
	scrollbar widget will return :MAX_ON_TOP or :MAX_ON_BOTTOM instead of
	:MAX_ON_LEFT and :MAX_ON_RIGHT. This is due to a bug in Motif 1.0.
   #else
	The problem above has been fixed in Motif 1.1.
   #endif /* MOTIF_1.0 */

*** Resource names and the widget classes they apply to:

	:XMN_PROCESSING_DIRECTION	XmNprocessingDirection

		XM_SCALE_WIDGET_CLASS XM_SCROLL_BAR_WIDGET_CLASS

______________________________________________________________________________

** XmRResizePolicy:

*** Type Information:

	Resource representation type XmRResizePolicy corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:RESIZE_NONE		XmRESIZE_NONE
		:RESIZE_GROW		XmRESIZE_GROW
		:RESIZE_ANY		XmRESIZE_ANY

	You may also specify a STRING value which will be automatically
	converted to XmRResizePolicy by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_RESIZE_POLICY		XmNresizePolicy

		XM_BULLETIN_BOARD_WIDGET_CLASS XM_COMMAND_WIDGET_CLASS
		XM_DRAWING_AREA_WIDGET_CLASS
______________________________________________________________________________

** XmRRowColumnType:

*** Type Information:

	Resource representation type XmRRowColumnType corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:WORK_AREA	XmWORK_AREA
		:MENU_BAR	XmMENU_BAR
		:MENU_POPUP	XmMENU_POPUP
		:MENU_PULLDOWN	XmMENU_PULLDOWN
		:MENU_OPTION	XmMENU_OPTION

	You may also specify a STRING value which will be automatically
	converted to XmRRowColumnType by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_ROW_COLUMN_TYPE		XmNrowColumnType

		XM_ROW_COLUMN_WIDGET_CLASS
______________________________________________________________________________

** XmRScrollBarDisplayPolicy:

*** Type Information:

	Resource representation type XmRScrollBarDisplayPolicy corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:STATIC			XmSTATIC
		:AS_NEEDED		XmAS_NEEDED

	You may also specify a STRING value which will be automatically
	converted to XmRScrollBarDisplayPolicy by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.

*** Resource names and the widget classes they apply to:

	:XMN_SCROLL_BAR_DISPLAY_POLICY	XmNscrollBarDisplayPolicy

		XM_LIST_WIDGET_CLASS XM_SCROLLED_WINDOW_WIDGET_CLASS

______________________________________________________________________________

** XmRScrollBarPlacement:

*** Type Information:

	Resource representation type XmRScrollBarPlacement corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:TOP_LEFT		XmTOP_LEFT
		:BOTTOM_LEFT		XmBOTTOM_LEFT
		:TOP_RIGHT		XmTOP_RIGHT
		:BOTTOM_RIGHT		XmBOTTOM_RIGHT

	You may also specify a STRING value which will be automatically
	converted to XmRScrollBarPlacement by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_SCROLL_BAR_PLACEMENT	XmNscrollBarPlacement

		XM_SCROLLED_WINDOW_WIDGET_CLASS

______________________________________________________________________________

** XmRScrollingPolicy:

*** Type Information:

	Resource representation type XmRScrollingPolicy corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:AUTOMATIC		XmAUTOMATIC
		:APPLICATION_DEFINED	XmAPPLICATION_DEFINED

	You may also specify a STRING value which will be automatically
	converted to XmRScrollingPolicy by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_SCROLLING_POLICY		XmNscrollingPolicy

		XM_SCROLLED_WINDOW_WIDGET_CLASS
______________________________________________________________________________

** XmRSelectionArray:

*** Type Information:

	Resource representation type XmRSelectionArray corresponds to an
	array or list containing the following keyword symbols. The
	first keyword symbol represents the XmText/XmTextField selection that is
	done on the first mouse click, the second keyword represents the
	selection done for two mouse clicks, etc. The following keyword
	symbols represent the valid WINTERP-Lisp values for this type and
	their associated Motif constants:

		:SELECT_POSITION	XmSELECT_POSITION
		:SELECT_WHITESPACE	XmSELECT_WHITESPACE
		:SELECT_WORD		XmSELECT_WORD
		:SELECT_LINE		XmSELECT_LINE
		:SELECT_ALL		XmSELECT_ALL
	    #ifdef MOTIF_1.1
		:SELECT_PARAGRAPH	XmSELECT_PARAGRAPH
	    #endif /* MOTIF_1.1 */

	You may also specify a STRING value which will be automatically
	converted to XmRSelectionPolicy by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.

*** Resource names and the widget classes they apply to:

	:XMN_SELECTION_ARRAY		XmNselectionArray

		XM_TEXT_WIDGET_CLASS
	    #ifdef MOTIF_1.1
		XM_TEXT_FIELD_WIDGET_CLASS
	    #endif /* MOTIF_1.1 */

		Note -- if you set resource :XMN_SELECTION_ARRAY, make 
		sure you also set resource :XMN_SELECTION_ARRAY_COUNT to
		EXACTLY the number of items in the selection array.
______________________________________________________________________________

** XmRSelectionPolicy:

*** Type Information:

	Resource representation type XmRSelectionPolicy corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:SINGLE_SELECT		XmSINGLE_SELECT
		:MULTIPLE_SELECT	XmMULTIPLE_SELECT
		:EXTENDED_SELECT	XmEXTENDED_SELECT
		:BROWSE_SELECT		XmBROWSE_SELECT

	You may also specify a STRING value which will be automatically
	converted to XmRSelectionPolicy by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_SELECTION_POLICY		XmNselectionPolicy

		XM_LIST_WIDGET_CLASS

______________________________________________________________________________

** XmRSeparatorType:

*** Type Information:

	Resource representation type XmRSeparatorType corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:NO_LINE		XmNO_LINE
		:SINGLE_LINE		XmSINGLE_LINE
		:DOUBLE_LINE		XmDOUBLE_LINE
		:SINGLE_DASHED_LINE	XmSINGLE_DASHED_LINE
		:DOUBLE_DASHED_LINE	XmDOUBLE_DASHED_LINE
		:SHADOW_ETCHED_IN	XmSHADOW_ETCHED_IN
		:SHADOW_ETCHED_OUT	XmSHADOW_ETCHED_OUT

	You may also specify a STRING value which will be automatically
	converted to XmRSeparatorType by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_SEPARATOR_TYPE		XmNseparatorType

		XM_SEPARATOR_GADGET_CLASS XM_SEPARATOR_WIDGET_CLASS
______________________________________________________________________________

** XmRShadowType:

*** Type Information:

	Resource representation type XmRShadowType corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:SHADOW_ETCHED_IN	XmSHADOW_ETCHED_IN
		:SHADOW_ETCHED_OUT	XmSHADOW_ETCHED_OUT
		:SHADOW_IN		XmSHADOW_IN
		:SHADOW_OUT		XmSHADOW_OUT

	You may also specify a STRING value which will be automatically
	converted to XmRShadowType by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_SHADOW_TYPE		XmNshadowType

		XM_BULLETIN_BOARD_WIDGET_CLASS XM_DRAWN_BUTTON_WIDGET_CLASS
		XM_FRAME_WIDGET_CLASS

______________________________________________________________________________

** XmRShort:

*** Type Information:

	Resource representation type XmRShort corresponds to
	WINTERP-Lisp type FIXNUM. Note that on some architectures, 
	WINTERP will signal an XLISP error if the FIXNUM is too
	large or too small of an integer.

	You may also specify a STRING value which will be automatically
	converted to XmRShort by Motif's resource converters.


*** Resource names and the widget classes they apply to:

	:XMN_NUM_COLUMNS		XmNnumColumns

		XM_ROW_COLUMN_WIDGET_CLASS

	:XMN_DECIMAL_POINTS		XmNdecimalPoints

		XM_SCALE_WIDGET_CLASS

	:XMN_TEXT_COLUMNS		XmNtextColumns

		XM_SELECTION_BOX_WIDGET_CLASS

	:XMN_COLUMNS			XmNcolumns

		XM_TEXT_WIDGET_CLASS
	   #ifdef MOTIF_1.1
		XM_TEXT_FIELD_WIDGET_CLASS
	   #endif /* MOTIF_1.1 */

	:XMN_ROWS			XmNrows

		XM_TEXT_WIDGET_CLASS

   #ifdef MOTIF_1.0

	:XMN_SHADOW_THICKNESS		XmNshadowThickness

		XM_BULLETIN_BOARD_WIDGET_CLASS
		XM_CASCADE_BUTTON_WIDGET_CLASS XM_CASCADE_BUTTON_GADGET_CLASS
		XM_DRAWN_BUTTON_WIDGET_CLASS <XM_GADGET_CLASS>
		XM_LABEL_WIDGET_CLASS XM_LABEL_GADGET_CLASS
		<XM_MANAGER_WIDGET_CLASS> <XM_PRIMITIVE_WIDGET_CLASS>
		XM_PUSH_BUTTON_WIDGET_CLASS XM_PUSH_BUTTON_GADGET_CLASS
		XM_SCROLLED_WINDOW_WIDGET_CLASS

	:XMN_MARGIN_WIDTH		XmNmarginWidth

		XM_BULLETIN_BOARD_WIDGET_CLASS XM_DRAWING_AREA_WIDGET_CLASS
		XM_FRAME_WIDGET_CLASS
		XM_LABEL_WIDGET_CLASS XM_LABEL_GADGET_CLASS
		XM_PANED_WINDOW_WIDGET_CLASS XM_TEXT_WIDGET_CLASS

		Note: if :get_values of :XMN_MARGIN_WIDTH on
		XM_ROW_COLUMN_WIDGET_CLASS retrieves bogus values use resource
		:XMN_RCMARGIN_WIDTH instead.
		This is may be a Motif 1.0 bug on some architectures.

	:XMN_MARGIN_HEIGHT		XmNmarginHeight

		XM_BULLETIN_BOARD_WIDGET_CLASS XM_DRAWING_AREA_WIDGET_CLASS
		XM_FRAME_WIDGET_CLASS
		XM_LABEL_WIDGET_CLASS XM_LABEL_GADGET_CLASS
		XM_PANED_WINDOW_WIDGET_CLASS XM_TEXT_WIDGET_CLASS

		Note: if :get_values of :XMN_MARGIN_HEIGHT on
		XM_ROW_COLUMN_WIDGET_CLASS retrieves bogus values use resource
		:XMN_RCMARGIN_HEIGHT instead.
		This may be a Motif 1.0 bug on some architectures.

	:XMN_HIGHLIGHT_THICKNESS	XmNhighlightThickness

		<XM_GADGET_CLASS> <XM_PRIMITIVE_WIDGET_CLASS>
		XM_SCALE_WIDGET_CLASS

	:XMN_MARGIN_LEFT		XmNmarginLeft

		XM_LABEL_WIDGET_CLASS XM_LABEL_GADGET_CLASS

	:XMN_MARGIN_RIGHT		XmNmarginRight

		XM_LABEL_WIDGET_CLASS XM_LABEL_GADGET_CLASS

	:XMN_MARGIN_TOP			XmNmarginTop

		XM_LABEL_WIDGET_CLASS XM_LABEL_GADGET_CLASS

	:XMN_MARGIN_BOTTOM		XmNmarginBottom

		XM_LABEL_WIDGET_CLASS XM_LABEL_GADGET_CLASS

	:XMN_LIST_SPACING		XmNlistSpacing

		XM_LIST_WIDGET_CLASS

	:XMN_LIST_MARGIN_WIDTH		XmNlistMarginWidth

		XM_LIST_WIDGET_CLASS

	:XMN_LIST_MARGIN_HEIGHT		XmNlistMarginHeight

		XM_LIST_WIDGET_CLASS

	:XMN_MAIN_WINDOW_MARGIN_WIDTH	XmNmainWindowMarginWidth

		XM_MAIN_WINDOW_WIDGET_CLASS

	:XMN_MAIN_WINDOW_MARGIN_HEIGHT	XmNmainWindowMarginHeight

		XM_MAIN_WINDOW_WIDGET_CLASS

	:XMN_SHOW_AS_DEFAULT		XmNshowAsDefault

		XM_PUSH_BUTTON_WIDGET_CLASS XM_PUSH_BUTTON_GADGET_CLASS

	:XMN_SCROLLED_WINDOW_MARGIN_WIDTH XmNscrolledWindowMarginWidth

		XM_SCROLLED_WINDOW_WIDGET_CLASS

	:XMN_SCROLLED_WINDOW_MARGIN_HEIGHT XmNscrolledWindowMarginHeight

		XM_SCROLLED_WINDOW_WIDGET_CLASS

	:XMN_MARGIN			XmNmargin

		XM_SEPARATOR_WIDGET_CLASS XM_SEPARATOR_GADGET_CLASS

   #endif /* MOTIF_1.0 */

   #ifdef MOTIF_1.2

	:XMN_POSITION_INDEX		XmNpositionIndex

		constraint resource from XM_ROW_COLUMN_WIDGET_CLASS parent

   #endif /* MOTIF_1.2 */

______________________________________________________________________________

** XmRString:

*** Type Information:

	Resource representation type XmRString corresponds to winter-Lisp
	type STRING.

*** Garbage Collection of strings:

	XLISP will reclaim storage on any STRING values that are no
	longer referenced inside WINTERP.


*** Resource names and the widget classes they apply to:

	:XMN_ACCELERATOR		XmNaccelerator

		XM_LABEL_WIDGET_CLASS XM_LABEL_GADGET_CLASS

	:XMN_MENU_ACCELERATOR		XmNmenuAccelerator

		XM_ROW_COLUMN_WIDGET_CLASS

	:XMN_STRING			XmNvalue

		XM_TEXT_WIDGET_CLASS

		Note -- :XMN_STRING is an alias for resource XmNvalue on 
		the Motif Text Widget. Motif 1.0 & 1.1 has a bug in that it
		inconsistently declares the value associated with the
		"message" XmNvalue as 'int' for other widget classes, and
		as a 'string' for the text widget. Thus, to retrieve or
		set the string in a text widget, use this resource name,
		or use text widget methods :GET_STRING and :SET_STRING.

	:XMN_GEOMETRY			XmNgeometry

		<SHELL_WIDGET_CLASS>

	:XMN_TITLE			XmNtitle

		<SHELL_WIDGET_CLASS>

	:XMN_ICON_NAME			XmNiconName

		TOP_LEVEL_SHELL_WIDGET_CLASS TOP_LEVEL_POPUP_SHELL_WIDGET_CLASS

	:XMN_MWM_MENU			XmNmwmMenu

		<SHELL_WIDGET_CLASS>

    #ifdef MOTIF_1.1
	:XMN_MNEMONIC_CHAR_SET		XmNmnemonicCharSet

		XM_LABEL_WIDGET_CLASS XM_LABEL_GADGET_CLASS
		XM_ROW_COLUMN_WIDGET_CLASS

		Note -- :XMN_MNEMONIC_CHAR_SET is to be set to a CharSet
		value for Motif. Example values would be "", which is
		equivalent to the C Motif constant XmSTRING_DEFAULT_CHARSET;
		another typical	value is "ISO8859-1", which is equivalent
		to the C Motif constants XmSTRING_ISO8859_1, XmSTRING_OS_CHARSET,
		and XmFALLBACK_CHARSET. For Motif 1.1, potential values for
		<charset> are: "" (default) "ISO8859-1" "ISO8859-2"
		"ISO8859-3" "ISO8859-4" "ISO8859-5" "ISO8859-6"	"ISO8859-7"
		"ISO8859-8" "ISO8859-9" "JISX0201.1976-0"
		"GB2312.1980-0" "GB2312.1980-1" "JISX0208.1983-0"
		"JISX0208.1983-1" "KSC5601.1987-0" "KSC5601.1987-1".
		For Motif 1.2, the default has changed to
		XmFONTLIST_DEFAULT_TAG, thus <charset> would be the string
		"FONTLIST_DEFAULT_TAG_STRING".

	:XMN_MENU_POST			XmNmenuPost

		XM_ROW_COLUMN_WIDGET_CLASS
    #endif /* MOTIF_1.1 */

   #ifdef SGI_DROP_POCKET_WIDGET

	:SGN_ICON_DATA_BASE_PATH	SgNiconDataBasePath

		SG_DROP_POCKET_WIDGET_CLASS

   #endif /* SGI_DROP_POCKET_WIDGET */


______________________________________________________________________________

** XmRStringDirection:

*** Type Information:

	Resource representation type XmRStringDirection corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:STRING_DIRECTION_L_TO_R	XmSTRING_DIRECTION_L_TO_R
		:STRING_DIRECTION_R_TO_L	XmSTRING_DIRECTION_R_TO_L

	You may also specify a STRING value which will be automatically
	converted to XmRStringDirection by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_STRING_DIRECTION		XmNstringDirection

		XM_LABEL_WIDGET_CLASS XM_LABEL_GADGET_CLASS XM_LIST_WIDGET_CLASS
	    #ifdef MOTIF_1.0
		XM_BULLETIN_BOARD_WIDGET_CLASS
	    #endif /* MOTIF_1.0 */
	    #ifdef MOTIF_1.1
		<XM_MANAGER_WIDGET_CLASS>
	    #endif /* MOTIF_1.1 */
	   #ifdef SGI_DROP_POCKET_WIDGET
		SG_FINDER_WIDGET_CLASS
	   #endif /* SGI_DROP_POCKET_WIDGET */

______________________________________________________________________________

** XmRStringTable:

*** Type Information:

	One may set an XmRStringTable resource by passing a
	ARRAY or LIST of STRINGs.

*** Resource names and the widget classes they apply to:

    #ifdef MOTIF_1.1
	:XMN_BUTTON_MNEMONIC_CHAR_SETS		XmNbuttonMnemonicCharSets

		<XM_ROW_COLUMN_WIDGET_CLASS created w/ :SIMPLE_*>

		Note -- this XmCreateSimple*() resource is write-only and can
		only be set at widget-creation-time. Setting this resource
		via :SET_VALUES will do nothing, and retrieval using :GET_VALUES
		will signal an error.
	:XMN_BUTTON_ACCELERATORS		XmNbuttonAccelerators

		<XM_ROW_COLUMN_WIDGET_CLASS created w/ :SIMPLE_*>

		Note -- this XmCreateSimple*() resource is write-only and can
		only be set at widget-creation-time. Setting this resource
		via :SET_VALUES will do nothing, and retrieval using :GET_VALUES
		will signal an error.
    #endif /* MOTIF_1.1 */

	:XMN_ARGV				XmNargv

		APPLICATION_SHELL_WIDGET_CLASS

		Note -- Although resource XmNargv takes values that are arrays
		of strings, the usual Xtoolkit b.s. strikes again because this
		resource doesn't work like normal resources with respect to
		copying values passed during creation or :SET_VALUES. Further
		Xtoolkit stupidities prevent retrieval of this resource using
		:GET_VALUES. Therefore Winterp-Resource :XMN_ARGV does not
		actually exist, instead, use the following methods:
		   (send <Application_Shell_Widget_Instance> :SET_ARGV <args>)
		   (send <Application_Shell_Widget_Instance> :GET_ARGV).
______________________________________________________________________________

#ifdef MOTIF_1.2
** XmRTearOffModel: [MOTIF >= 1.2 only]

*** Type Information:

	Resource representation type XmRTearOffModel corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:TEAR_OFF_ENABLED	XmTEAR_OFF_ENABLED
		:TEAR_OFF_DISABLED	XmTEAR_OFF_DISABLED

	You may also specify a STRING value which will be automatically
	converted to XmRTearOffModel by Motif's resource converters.
	These values would be the same as one would specify in
	$HOME/.Xdefaults.

*** Resource names and the widget classes they apply to:

	:TEAR_OFF_ENABLED		XmTEAR_OFF_ENABLED

		XM_ROW_COLUMN_WIDGET_CLASSn

	:TEAR_OFF_DISABLED		XmTEAR_OFF_DISABLED

		XM_ROW_COLUMN_WIDGET_CLASS

#endif /* MOTIF_1.2 */

______________________________________________________________________________

#ifdef MOTIF_1.1
** XmRTextPosition: [Motif >= 1.1 only]

*** Type Information:

	Resource representation type XmRTextPosition corresponds to
	WINTERP-Lisp type FIXNUM. Only non-negative values are allowed.
	Negative values will signal an error.

*** Resource names and the widget classes they apply to:

	:XMN_TOP_CHARACTER		XmNtopCharacter

		XM_TEXT_WIDGET_CLASS

		Note: XmNtopCharacter in Motif 1.1 corresponds to resource
		XmNtopPosition from Motif 1.0. The name was changed in
		Motif 1.1.

	:XMN_CURSOR_POSITION		XmNcursorPosition

		XM_TEXT_WIDGET_CLASS XM_TEXT_FIELD_WIDGET_CLASS

#endif /* MOTIF_1.1 */

______________________________________________________________________________

** XmRTranslationTable:

*** Type Information:

	Resource representation type XmRTranslationTable corresponds to the
	atomic type XT_TRANSLATIONS as returned by primitive
	XT_PARSE_TRANSLATION_TABLE.

	One may set XmRTranslationTable resources by specifying a STRING
	translation table, just as you would in file $HOME/.Xdefaults.
	Alternatively, one can use the result of :get_values on another
	widget's XmRTranslationTable resource or use primitive
	XT_PARSE_TRANSLATION_TABLE as a XmRTranslationTable value.

	For more information on the syntax of the string representation of
	translation tables, see the X11r4 documentation "X Toolkit
	Intrinsics -- C Language Interface": "Appendix B: Translation Table
	Syntax" and "Chapter 10: Translation Management".


*** Resource names and the widget classes they apply to:

	:XMN_TEXT_TRANSLATIONS		XmNtextTranslations

		XM_BULLETIN_BOARD_WIDGET_CLASS

	:XMN_TRANSLATIONS		XmNtranslations

		<WIDGET_CLASS>

______________________________________________________________________________

** XmRUnitType:

*** Type Information:

	Resource representation type XmRUnitType corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:PIXELS			XmPIXELS
		:100TH_MILLIMETERS	Xm100TH_MILLIMETERS
		:1000TH_INCHES		Xm1000TH_INCHES
		:100TH_POINTS		Xm100TH_POINTS
		:100TH_FONT_UNITS	Xm100TH_FONT_UNITS

	You may also specify a STRING value which will be automatically
	converted to XmRUnitType by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_UNIT_TYPE			XmNunitType

		<XM_GADGET_CLASS> <XM_MANAGER_WIDGET_CLASS>
		<XM_PRIMITIVE_WIDGET_CLASS>

	:XMN_SHELL_UNIT_TYPE		XmNshellUnitType

		<SHELL_WIDGET_CLASS>

______________________________________________________________________________

** XmRVisualPolicy:

*** Type Information:

	Resource representation type XmRVisualPolicy corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated Motif constants:

		:VARIABLE		XmVARIABLE
		:CONSTANT		XmCONSTANT

	You may also specify a STRING value which will be automatically
	converted to XmRVisualPolicy by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_VISUAL_POLICY		XmNvisualPolicy

		XM_SCROLLED_WINDOW_WIDGET_CLASS

______________________________________________________________________________

** XmRWhichButton:

*** Type Information:

	Resource representation type XmRWhichButton corresponds to an
	enumerated type. The following keyword symbols represent the valid
	WINTERP-Lisp values for this type and their associated X constants:

		:BUTTON1		Button1
		:BUTTON2		Button2
		:BUTTON3		Button3
		:BUTTON4		Button4
		:BUTTON5		Button5

	You may also specify a STRING value which will be automatically
	converted to XmRWhichButton by Motif's resource converters.
	These values would be the same as one would specify in $HOME/.Xdefaults.


*** Resource names and the widget classes they apply to:

	:XMN_WHICH_BUTTON		XmNwhichButton

		XM_ROW_COLUMN_WIDGET_CLASS

______________________________________________________________________________

** "XmRWidget", XmRMenuWidget:

*** Type Information:

	Resource representation type "XmRWidget" corresponds to WINTERP-Lisp
	OBJECT type WIDGETOBJ.

	Note that Motif 1.0 nor the Xtoolkit define a representation type
	"XmRWidget" -- this is a fake type used for all resources that
	expect a value of type 'Widget'. In many cases,	Motif 1.0
	misdeclares such values as being of representation type	XmRWindow.
	Additionally, the fake representation type "XmRWidget" subsumes the
	type XmRMenuWidget, which is used for a few Motif resources. This
	won't matter for automatic string-->XmRWidget conversions because Motif
	doesn't provide a converters to XmRWidget, XmRMenuWidget, nor XmRWindow.


*** Garbage collection of WIDGETOBJs

	Every WIDGETOBJ that gets created will not be garbage collected
	until the widget is destroyed. This is needed for proper operation
	of the get-moused-widget function, and for getting back the correct
	WIDGETOBJ when a WIDGETOBJ is retrieved from the Motif Toolkit
	internals.  This could be made optional in the future because some
	memory could be saved, and garbage collection times potentially
	reduced if only the widgets that are actually being referenced in
	Lisp code are protected against g.c.

	When a WIDGETOBJ gets :DESTROY'd, all its WINTERP-XLISP memory and
	resources may be garbage collected. This includes any PIXMAPs,
	CALLBACKOBJs, EVHANDLEROBJs, etc that correspond to the widget.


*** Resource names and the widget classes they apply to:

    #ifdef MOTIF_1.1
	:XMN_TRANSIENT_FOR		XmNtransientFor

		TRANSIENT_POPUP_SHELL_WIDGET_CLASS TRANSIENT_SHELL_WIDGET_CLASS
    #endif /* MOTIF_1.1 */

	:XMN_SUB_MENU_ID		XmNsubMenuId

		XM_CASCADE_BUTTON_WIDGET_CLASS XM_CASCADE_BUTTON_GADGET_CLASS
		XM_ROW_COLUMN_WIDGET_CLASS

		Note -- Motif (mis)declares this resource as 
		representation type XmRMenuWidget. I'm throwing it in
		with "XmRWidget" because these resources are WIDGETOBJs.

	:XMN_MENU_HELP_WIDGET		XmNmenuHelpWidget

		XM_ROW_COLUMN_WIDGET_CLASS 
		
		Note -- Motif (mis)declares this resource as 
		representation type XmRMenuWidget. I'm throwing it in
		with "XmRWidget" because these resources are WIDGETOBJs.

		Note -- resource name :XMN_MENU_HELP_WIDGET is defined
		only for a row column widget created with the :menu_bar
		or :simple_menu_bar option. Using this resource with other
		variants of the	row column widget is underfined and
		unguaranteed.

	:XMN_MENU_HISTORY		XmNmenuHistory

		XM_ROW_COLUMN_WIDGET_CLASS

		Note -- Motif (mis)declares this resource as 
		representation type XmRMenuWidget. I'm throwing it in
		with "XmRWidget" because these resources are WIDGETOBJs.

		Note -- resource name :XMN_MENU_HISTORY is defined
		only for row column widgets created with the 
		:popup_menu, :simple_popup_menu, :pulldown_menu, or
		:simple_pulldown_menu options. Using this resource with
		other variants of the row column widget	is undefined and
		unguaranteed.

	:XMN_DEFAULT_BUTTON		XmNdefaultButton

		XM_BULLETIN_BOARD_WIDGET_CLASS

		Note -- Motif (mis)declares this resource as representation
		XmRWindow. I'm throwing it in with "XmRWidget" because these
		resources are WIDGETOBJs.

	:XMN_CANCEL_BUTTON		XmNcancelButton

		XM_BULLETIN_BOARD_WIDGET_CLASS

		Note -- Motif (mis)declares this resource as representation
		XmRWindow. I'm throwing it in with "XmRWidget" because these
		resources are WIDGETOBJs.

	:XMN_TOP_WIDGET			XmNtopWidget

		constraint resource from XM_FORM_WIDGET_CLASS parent

		Note -- Motif (mis)declares this resource as representation
		XmRWindow. I'm throwing it in with "XmRWidget" because these
		resources are WIDGETOBJs.

	:XMN_BOTTOM_WIDGET		XmNbottomWidget

		constraint resource from XM_FORM_WIDGET_CLASS parent

		Note -- Motif (mis)declares this resource as representation
		XmRWindow. I'm throwing it in with "XmRWidget" because these
		resources are WIDGETOBJs.

	:XMN_LEFT_WIDGET		XmNleftWidget

		constraint resource from XM_FORM_WIDGET_CLASS parent

		Note -- Motif (mis)declares this resource as representation
		XmRWindow. I'm throwing it in with "XmRWidget" because these
		resources are WIDGETOBJs.

	:XMN_RIGHT_WIDGET		XmNrightWidget

		constraint resource from XM_FORM_WIDGET_CLASS parent

		Note -- Motif (mis)declares this resource as representation
		XmRWindow. I'm throwing it in with "XmRWidget" because these
		resources are WIDGETOBJs.

	:XMN_HORIZONTAL_SCROLL_BAR	XmNhorizontalScrollBar

		XM_LIST_WIDGET_CLASS XM_SCROLLED_WINDOW_WIDGET_CLASS

		Note -- Motif (mis)declares this resource as representation
		XmRWindow. I'm throwing it in with "XmRWidget" because these
		resources are WIDGETOBJs.

	:XMN_VERTICAL_SCROLL_BAR	XmNverticalScrollBar

		XM_LIST_WIDGET_CLASS XM_SCROLLED_WINDOW_WIDGET_CLASS

		Note -- Motif (mis)declares this resource as representation
		XmRWindow. I'm throwing it in with "XmRWidget" because these
		resources are WIDGETOBJs.

	:XMN_COMMAND_WINDOW		XmNcommandWindow

		XM_MAIN_WINDOW_WIDGET_CLASS

		NPM recommendation: DON'T USE THIS RESOURCE. It really is
		only defined to work for a XmCommand widget parented by an
		XmMainWindow instance. 

		Note -- Motif (mis)declares this resource as representation
		XmRWindow. I'm throwing it in with "XmRWidget" because these
		resources are WIDGETOBJs.

	:XMN_MENU_BAR			XmNmenuBar

		XM_MAIN_WINDOW_WIDGET_CLASS

		Note -- Motif (mis)declares this resource as representation
		XmRWindow. I'm throwing it in with "XmRWidget" because these
		resources are WIDGETOBJs.

    #ifdef MOTIF_1.1
	:XMN_MESSAGE_WINDOW		XmNmessageWindow

		XM_MAIN_WINDOW_WIDGET_CLASS

		Note -- Motif (mis)declares this resource as representation
		XmRWindow. I'm throwing it in with "XmRWidget" because these
		resources are WIDGETOBJs.
    #endif /* MOTIF_1.1 */

	:XMN_WORK_WINDOW		XmNworkWindow

		XM_SCROLLED_WINDOW_WIDGET_CLASS XM_MAIN_WINDOW_WIDGET_CLASS

		Note -- Motif 1.0 (mis)declares this resource as representation
		XmRWindow. I'm throwing it in with "XmRWidget" because these
		resources are WIDGETOBJs.

	:XMN_CLIP_WINDOW		XmNclipWindow

		XM_SCROLLED_WINDOW_WIDGET_CLASS

		Note -- Motif 1.0 (mis)declares this resource as representation
		XmRWindow. I'm throwing it in with "XmRWidget" because these
		resources are WIDGETOBJs.

    #ifdef HP_GRAPH_WIDGET

	:XMN_TO				XmNto

		XM_ARC_WIDGET_CLASS

	:XMN_FROM			XmNfrom

		XM_ARC_WIDGET_CLASS

    #endif /* HP_GRAPH_WIDGET */

______________________________________________________________________________

** "XmRWidgetClass":

*** Type Information:

	Resource representation type XmRWidgetClass corresponds to
	WINTERP-Lisp OBJECT. In particular, this OBJECT must be a class
	object that is a subclass of WIDGET_CLASS.

	Note that neither Motif nor the Xtoolkit define a representation type
	"XmRWidgetClass" -- this is a fake type used for all resources that
	expect a value of type 'WidgetClass'.


*** Resource names and the widget classes they apply to:

	:XMN_ENTRY_CLASS		XmNentryClass

		XM_ROW_COLUMN_WIDGET_CLASS

		Note -- Motif 1.0 & 1.1 misdeclares resource XmNentryClass as
		representation type XmRInt. The value for this resource is
		actually a 'WidgetClass' pointer.

    #ifdef HP_GRAPH_WIDGET

	:XMN_DEFAULT_NODE_CLASS		XmNdefaultNodeClass

		XM_GRAPH_WIDGET_CLASS

    #endif /* HP_GRAPH_WIDGET */

______________________________________________________________________________

** XmRWindow:

*** Type Information:

	Resource representation type XmRWindow corresponds to WINTERP-Lisp
	atomic type WINDOW. This type is returned by some callbacks, as
	well as by WIDGET_CLASS method :WINDOW.


*** Resource names and the widget classes they apply to:

	:XMN_ICON_WINDOW		XmNiconWindow

		<SHELL_WIDGET_CLASS>

	:XMN_WINDOW_GROUP		XmNwindowGroup

		<SHELL_WIDGET_CLASS>

______________________________________________________________________________

#ifdef MOTIF_1.1
** "XmRWindowGravity": [Motif >= 1.1 only]

*** Type Information:

	Resource representation type "XmRWindowGravity" corresponds to an
	enumerated type. Note that neither Motif nor the Xtoolkit define a
	representation type "XmRWindowGravity". Resources of this type are
	declared as XmRInt, even though they work like enumerated types.

	The following keyword symbols represent the valid WINTERP-Lisp
	values for this type and their associated <X11/X.h> constants:

		:FORGET_GRAVITY		ForgetGravity
		:NORTH_WEST_GRAVITY	NorthWestGravity
		:NORTH_GRAVITY		NorthGravity
		:NORTH_EAST_GRAVITY	NorthEastGravity
		:WEST_GRAVITY		WestGravity
		:CENTER_GRAVITY		CenterGravity
		:EAST_GRAVITY		EastGravity
		:SOUTH_WEST_GRAVITY	SouthWestGravity
		:SOUTH_GRAVITY		SouthGravity
		:SOUTH_EAST_GRAVITY	SouthEastGravity
		:STATIC_GRAVITY		StaticGravity

*** Resource names and the widget classes they apply to:

	:XMN_WIN_GRAVITY		XmNwinGravity

		<SHELL_WIDGET_CLASS> <POPUP_SHELL_WIDGET_CLASS>

#endif /* MOTIF_1.1 */

______________________________________________________________________________

** XmRXmString:

*** Type Information:

	Resource representation type XmRXmString corresponds to the atomic
	type XM_STRING as returned by primitives XM_STRING_CREATE_L_TO_R and
	XM_STRING_CREATE.

	Any XM_STRING value needed by a Motif function, method or resource
	may be substituted for a STRING. WINTERP will automatically
	call XmStringCreateLtoR() to convert STRING values to XM_STRING values.
	
	Note that Motif XmStrings are problematic in that the XmString
	resources you set via :SET_VALUES (or at widget creation time) are
	guaranteed not to be EQ, EQL or EQUAL to the ones you retrieve via
	:GET_VALUES or via a widget method.

	In order to check for XmString equality, you have to call
	XmStringCompare(), via primitive XM_STRING_COMPARE.
	XmStringCompare() is quite inefficient, so be careful about how you
	use it. For example, you should ignore the way the Motif
	documentation shows you to use the XmList widget. Intead, use the 
	technique demonstrated above in the section "Example of using OOP
	features of XLISP with Motif widgets".

	In order to retrieve a STRING value from an XM_STRING value, use
	primitive XM_STRING_GET_L_TO_R.

*** Garbage collection of XM_STRINGs:

	Storage associated with XM_STRINGs is freed via XmStringFree() when
	a XM_STRING node gets garbage collected. Garbage collection of
	XM_STRINGs occurs when they are no longer accessible by a Lisp variable.


*** Resource names and the widget classes they apply to:

	:XMN_DIALOG_TITLE		XmNdialogTitle

		XM_BULLETIN_BOARD_WIDGET_CLASS

	:XMN_PROMPT_STRING		XmNpromptString

		XM_COMMAND_WIDGET_CLASS

	:XMN_COMMAND			XmNcommand

		XM_COMMAND_WIDGET_CLASS

	:XMN_TEXT_STRING		XmNtextString

		XM_SELECTION_BOX_WIDGET_CLASS

	:XMN_LABEL_STRING		XmNlabelString

		XM_DRAWN_BUTTON_WIDGET_CLASS
		XM_LABEL_WIDGET_CLASS XM_LABEL_GADGET_CLASS
		XM_ROW_COLUMN_WIDGET_CLASS
	    #ifdef HP_GRAPH_WIDGET
		XM_ARC_WIDGET_CLASS
	    #endif /* HP_GRAPH_WIDGET */

	:XMN_LIST_LABEL_STRING		XmNlistLabelString

		XM_FILE_SELECTION_BOX_WIDGET_CLASS XM_SELECTION_BOX_WIDGET_CLASS

	:XMN_APPLY_LABEL_STRING		XmNapplyLabelString

		XM_FILE_SELECTION_BOX_WIDGET_CLASS XM_SELECTION_BOX_WIDGET_CLASS

	:XMN_DIR_SPEC			XmNdirSpec

		XM_FILE_SELECTION_BOX_WIDGET_CLASS

	:XMN_FILTER_LABEL_STRING	XmNfilterLabelString

		XM_FILE_SELECTION_BOX_WIDGET_CLASS

	:XMN_DIR_MASK			XmNdirMask

		XM_FILE_SELECTION_BOX_WIDGET_CLASS

	:XMN_ACCELERATOR_TEXT		XmNacceleratorText

		XM_LABEL_WIDGET_CLASS XM_LABEL_GADGET_CLASS

	:XMN_MESSAGE_STRING		XmNmessageString

		XM_MESSAGE_BOX_WIDGET_CLASS

	:XMN_OK_LABEL_STRING		XmNokLabelString

		XM_MESSAGE_BOX_WIDGET_CLASS XM_SELECTION_BOX_WIDGET_CLASS

	:XMN_CANCEL_LABEL_STRING	XmNcancelLabelString

		XM_MESSAGE_BOX_WIDGET_CLASS XM_SELECTION_BOX_WIDGET_CLASS

	:XMN_HELP_LABEL_STRING		XmNhelpLabelString

		XM_MESSAGE_BOX_WIDGET_CLASS XM_SELECTION_BOX_WIDGET_CLASS

	:XMN_TITLE_STRING		XmNtitleString

		XM_SCALE_WIDGET_CLASS

	:XMN_SELECTION_LABEL_STRING	XmNselectionLabelString

		XM_SELECTION_BOX_WIDGET_CLASS

    #ifdef MOTIF_1.1
	:XMN_DIRECTORY			XmNdirectory

		XM_FILE_SELECTION_BOX_WIDGET_CLASS

	:XMN_PATTERN			XmNpattern

		XM_FILE_SELECTION_BOX_WIDGET_CLASS

	:XMN_DIR_LIST_LABEL_STRING	XmNdirListLabelString

		XM_FILE_SELECTION_BOX_WIDGET_CLASS

	:XMN_NO_MATCH_STRING		XmNnoMatchString

		XM_FILE_SELECTION_BOX_WIDGET_CLASS

	:XMN_FILE_LIST_LABEL_STRING	XmNfileListLabelString

		XM_FILE_SELECTION_BOX_WIDGET_CLASS

	:XMN_OPTION_LABEL		XmNoptionLabel

		<XM_ROW_COLUMN_WIDGET_CLASS created w/ :SIMPLE_OPTION_MENU>
    #endif /* MOTIF_1.1 */

   #ifdef SGI_DROP_POCKET_WIDGET

	:SGN_NAME			SgNname

		SG_DROP_POCKET_WIDGET_CLASS

   #endif /* SGI_DROP_POCKET_WIDGET */


______________________________________________________________________________

** XmRXmStringTable:

*** Type Information:

	One may set an XmRXmStringTable resource by passing a
	ARRAY or LIST value containing either STRING or XM_STRING nodes.
	Any STRING values are automatically converted to XmStrings via
	XmStringCreateLtoR().

	Limitations in the design of Motif/Xtk prevent WINTERP from being 
	able to retrieve XmRXmStringTable resources using WIDGET_CLASS
	method :GET_VALUES. Accessor methods are provided to allow
	retrieval of these resources....


*** Garbage Collection of XmRXmStringTable:

	A Motif XmStringTable is represented as an array or list of
	XmStrings.  The XmStrings in these sequences will get garbage
	collected if the vector or array holding them gets collected.


*** Resource names and the widget classes they apply to:

	:XMN_HISTORY_ITEMS		XmNhistoryItems

		XM_COMMAND_WIDGET_CLASS
		[note: :GET_VALUES can't retrieve this resource, use method
		       (send <commandwidget> :GET_HISTORY_ITEMS)]

	:XMN_ITEMS			XmNitems

		XM_LIST_WIDGET_CLASS
		[note: :GET_VALUES can't retrieve this resource, use method
		       (send <listwidget> :GET_ITEMS)]

	:XMN_SELECTED_ITEMS		XmNselectedItems

		XM_LIST_WIDGET_CLASS
		[note: :GET_VALUES can't retrieve this resource, use method
		       (send <listwidget> :GET_SELECTED_ITEMS)]

	:XMN_LIST_ITEMS			XmNlistItems

		XM_SELECTION_BOX_WIDGET_CLASS
		[note: :GET_VALUES can't retrieve this resource, use method
		       (send <selectionbox> :GET_LIST_ITEMS)]

    #ifdef MOTIF_1.1
	:XMN_DIR_LIST_ITEMS		XmNdirListItems

		XM_FILE_SELECTION_BOX_WIDGET_CLASS
		[note: :GET_VALUES can't retrieve this resource, use method
		       (send <fileselboxwidget> :GET_DIR_LIST_ITEMS)]

	:XMN_FILE_LIST_ITEMS		XmNfileListItems

		XM_FILE_SELECTION_BOX_WIDGET_CLASS
		[note: :GET_VALUES can't retrieve this resource, use method
		       (send <fileselboxwidget> :GET_FILE_LIST_ITEMS)]

	:XMN_BUTTONS			XmNbuttons

		<XM_ROW_COLUMN_WIDGET_CLASS created w/ :SIMPLE_*>
		[note: this resource can be set only at widget-creation time
		setting via :SET_VALUES will do nothing, and retrieval via
		:GET_VALUES will signal an error.]

	:XMN_BUTTON_ACCELERATOR_TEXT	XmNbuttonAcceleratorText

		<XM_ROW_COLUMN_WIDGET_CLASS created w/ :SIMPLE_*>
		[note: this resource can be set only at widget-creation time
		setting via :SET_VALUES will do nothing, and retrieval via
		:GET_VALUES will signal an error.]
    #endif /* MOTIF_1.1 */

______________________________________________________________________________

** Missing Resources in WINTERP:

	The current version of WINTERP does not allow access to the 
	following resources:

	XmNsimpleCallback: this is a special inconsistent way of setting
		callbacks on <XM_ROW_COLUMN_WIDGET_CLASS created w/ :SIMPLE_*>.
		I suggest using XM_ROW_COLUMN_WIDGET_CLASS's XmNentryCallback
		instead. See "Note on XmCreateSimple*() routines" above for
		details. Also, see  ./../examples/fake-app.lsp and
		./../examples/RowColumn.lsp.

	XmNchildren/XmNnumChildren: this read-only resource may not be
		retrieved via WINTERP's :GET_VALUES in a straightforward
		fashion. Instead, use method
			(send <composite_widget> :GET_CHILDREN)

	XmNargv/XmNargc: due to inconsistent behavior of the XmNargv
		resource you must set and retrieve this resource via the
		following methods on APPLICATION_SHELL_WIDGET_CLASS:
			(send <application-shell-widget> :SET_ARGV)
			(send <application-shell-widget> :GET_ARGV)

	XmNpostFromCount/XmNpostFromList: these seem to be internal,
		undocumented resources on XmRowColumn, therefore I'm not going
		to interface these. If you figure out what these are used
		for, and need to use them, add a method on
		XM_ROW_COLUMN_WIDGET_CLASS that is similar to method
		./../src-server/wc_WIDGET.c:Widget_Class_Method_GET_CHILDREN().

	XmNcolormap: I haven't interfaced this Core/Shell resource because
		WINTERP does not provide a type COLORMAP yet. If I ever
		need to fiddle with colormaps directly, this can be added
		trivially.

	XmNatom: I haven't interfaced this Xm/Protocols.c resource because
		it seems to be an undocumented, internal resource used by
		the protocol manager.
		
	XmNtitleEncoding: / XmNiconNameEncoding: I haven't interfaced these
		shell widget resources because I haven't provided a type 
		ATOM yet. I'll probably add these when I add interfaces to
		the protocol manager functionality.

	XmNextensionType:  I haven't interfaced this resource because
		it seems to be an undocumented, internal resource used by
		Motif.

	XmNoutputCreate/XmNinputCreate/XmNinsertPosition/XmNcreatePopupChildProc:
		These resources take a C function-pointer. The kinds of
		things done by these procedures are probably too low-level
		to interface to the WINTERP. If you need access to these in
		WINTERP the simplest thing to do is create a trivial
		subclass (essentially a C wrapper) of the desired widget-class
		such that this resource gets set to the desired
		creation/insert/popup procedure that is implemented in C.

	XmNuserData: this resource is used internally by WINTERP. If you
		need to attach your own data to widgets, you may do it by
		declaring a subclass of the desired widget-class containing
		instance variables and methods to access the instance variables.

	XmNsource: This XmText resource takes a C function pointer. The kinds of
		things done by these procedures are probably too low-level
		to interface to the WINTERP. If you need access to these in
		WINTERP the simplest thing to do is create a trivial
		subclass (essentially a C wrapper) of the XmText such
		that this resource gets set to the desired C-implemented
		procedure.

	XmNqualifySearchDataProc/XmNdirSearchProc/XmNfileSearchProc:

		These XmFileSelectionBox resources take a C function
		pointer. The kinds of things done by these procedures are
		probably too low-level to interface to the WINTERP. If you
		need access to these in WINTERP the simplest thing to do is
		create a trivial subclass (essentially a C wrapper) of the
		XmFileSelectionBox class such that these resources get set
		to the desired C-implemented procedure.

	XmNscreen: this Core resource hasn't been interfaced because
		WINTERP does not yet support multiple screens and does
		not have a type SCREEN. At some point, it may get updated
		to support multiple screens, at which point I'll interface
		this resource.

	XmNvisual: this Shell resource hasn't been interfaced yet because
		WINTERP does not support type VISUAL yet, and I haven't
		needed to use VISUAL in my applications.

==============================================================================

* Future work, missing features.

	If you add any of the features described below, please send your
	modifications to the winterp mailing list winterp@netcom.com .

** Motif 1.2 Drag-and-Drop

	Might as well wait for Motif 2.0/X11r6 since this will
	supposedly have a simpler and more standardized interface.

	In the mean-time, I use SGI IndigoMagic SgDropPocket SgFinder...

** Cursor Support:

	Ability to change cursor in TANGO:WIDGET_CLASS and
	XM_GRAPH_WIDGET_CLASS....

	Add cursor as a primitive type.

	XmGetMenuCursor()

** Support for Multiple Displays.

	The X11r3 toolkit upon which Motif 1.0 is based does not support 
	multiple displays properly, and therefore Motif 1.0 does not
	support multiple displays either. The X11r4 Xtoolkit supposedly
	supports multiple displays, so we might expect bug-free multiple
	display support in Motif 1.1 (??). Eventually, I hope to update
	WINTERP to support multiple display.

** <Xm/CutPaste.h> -- XmClipboard functionality.

	The following Motif functionality is missing from WINTERP
	I didn't get around to adding these due to lack of time and 
	interest. I'm sure I'll be needing this functionality eventually,
	so you can expect that they'll be included in a future WINTERP
	release. Feel free to interface these functions and send me your code!

		XmClipboardBeginCopy(), XmClipboardStartCopy(),
		XmClipboardCopy(), XmClipboardEndCopy(), XmClipboardCancelCopy(),
		XmClipboardCopyByName(), XmClipboardUndoCopy(),
		XmClipboardLock(), XmClipboardUnlock(),
		XmClipboardStartRetrieve(), XmClipboardRetrieve(),
		XmClipboardEndRetrieve(), XmClipboardInquireCount(),
		XmClipboardInquireFormat(), XmClipboardInquireLength(),
		XmClipboardInquirePendingItems(), XmClipboardWithdrawFormat(),
		XmClipboardRegisterFormat().

** <X11/Selection.h> -- X11r3 selection capabilities.

	The following Motif functionality is missing from WINTERP
	I didn't get around to adding these due to lack of time and 
	interest. Are these really necessary if we interface XmClipboard??

		XtOwnSelection(), XtDisownSelection(), XtGetSelectionValue(),
		XtGetSelectionValues(), XtSetSelectionTimeout(),
		XtGetSelectionTimeout().

** <X11/Protocols.h> -- Window Manager Protocol interfaces.

	The following Motif functionality is missing from WINTERP
	I didn't get around to adding these due to lack of time and 
	interest.

		XmAddWMProtocols(), XmRemoveWMProtocols(), 
		XmAddWMProtocolCallback(), XmRemoveWMProtocolCallback(),
		XmActivateWMProtocol(), XmDeactivateWMProtocol(),
		XmSetWMProtocolHooks(), XmAddProtocols(),
		XmRemoveProtocols(), XmAddProtocolCallback(), 
		XmRemoveProtocolCallback(), XmActivateProtocol(),
		XmDeactivateProtocol(), XmSetProtocolHooks()

** <X11/PassivGrab.h>

	The following Motif functionality is missing from WINTERP
	I didn't get around to adding these due to lack of time and 
	interest. Using these with Motif could cause problems anyways.

		XtGrabKey(), XtUngrabKey(), XtGrabKeyboard(), XtUngrabKeyboard()

** XtAppAddWorkProc()/XtAppRemoveWorkProc():

	This might be useful for scheduling periodic garbage collects that
	can occur when WINTERP is otherwise idle.

** Missing XmString and XmFontList functionality:

	XmStringFreeContext(), XmStringGetNextComponent(), 
	XmStringPeekNextComponent(), XmStringGetNextSegment(), 
	XmFontListCreate(), XmStringCreateFontList(), XmFontListFree(),
	XmFontListAdd(), XmFontListCopy(), XmStringNConcat(),
	XmStringNCopy(), XmStringBaseline(), XmStringWidth(), XmStringHeight(),
	XmStringExtent(), XmStringDraw(), XmStringDrawImage(), 
	XmStringDrawUnderline().

	If you need any of the above, feel free to add them to
	./../src-server/w_XmString.c and send me the changes....

** More interactive builder-like functions:

*** Widget and Resource "palette"
	
	It gets tedious having to remember widget class names and resource
	names. Create a browser that will allow you to visually construct
	the arguments for widget creation and widget :set_values.

	Such functionality would serve as the basis for a builder. Much of this
	could be done in Lisp, without having to modify C code.

*** Interactively place a newly created widget inside a manager.

*** Interactively move existing widgets around.

*** Colorpicker:

	Be able to mouse on a color-source widget followed by a
	color-destination widget. The color-destination widget will take on
	the background/foreground colors of another widget.

	Allow optional creation of a palette of widgets for picking
	specific preset color combinations.

	Both of these could easily be done as Lisp-only extensions to
	WINTERP. See ./../examples/colorsetr.lsp for a first attempt...
	

*** Resource browser:

	Be able to bring up a browser that allows you to inspect and alter
	the resources on a widget. Alterations on a widget are returned
	as name/value pairs that can be passed on to future invocations of
	:set_values or :new.
