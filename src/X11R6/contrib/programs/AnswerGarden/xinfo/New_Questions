@begin(header)
author: ackerman=ag@.ics.uci.edu
show_author: ShowNone
author_organization: Harvard X Class
node_expert: ackerman=ag@ics.uci.edu 
expiration_date: 10/17/93
last_modifier: ackerman=ag@.ics.uci.edu
last_mod_date: 11/07/91
mod_num: 7
@end(header)
-----------------------------------------------
These are some of the questions asked by
class members.  (Some are edited.)  These 
questions are commonly-asked questions,
and they will be included in the Answer Garden.
-----------------------------------------------


@begin(Q)
Is there any way to find out information about
an existing GC, such as what its line attributes
have been set to?
@end(Q)

@begin(A)
Yes, use XGetGCValues:

     Status XGetGCValues(display, gc, valuemask, values_return)
           Display *display;
           GC gc;
           unsigned long valuemask;
           XGCValues *values_return;

You set the mask for whatever values you want, and the results are
returned in the XGCValues struct.  
@end(A)

@begin(Q)
What is the difference between a Tile and a Stipple when doing
a fill (graphics) operation?
@end(Q)

@begin(A)
The tile is the pattern that is used to fill a surface.  The stipple
is used like a stencil; that is, you paint through it.  The values
for XSetFillStyle include:

FillSolid		fill with a solid color (the foreground color of
			the GC)
FillTiled		fill with a pattern (the tile in the GC)
FillStippled		fill with a solid color (the foreground) masked
			by the stipple pattern 
FillOpaqueStippled	fill with a pattern (the tile) masked by the
			stipple pattern

Stipple patterns are used for effects like "greying out" menu items
or other inactive regions.  If you had an on-off pattern for a
stipple, and painted a picture through that, you would get an
on-off pattern in the final result.
@end(A)

@begin(Q)
Okay in the XFillPolygon routine there is something called

	XPoint	*points; /* pointer to array of points that define polygon*/

XPoint is defined as

	typedef struct
	  {
	    short	x,y;
	  } XPoint;

How do I set up a bunch of points to be sent to XFillPolygon?
@end(Q)

@begin(A)
You want an array of XPoints.  The XFillPolygon uses an array of
XPoint's with an argument for the number of points as well:

     XFillPolygon(display, d, gc, points, npoints, shape, mode)
           Display *display;
           Drawable d;
           GC gc;
           XPoint *points;
           int npoints;
           int shape;
           int mode;

So you would set up an array of XPoint's:

	XPoint fred[55];

Fill in each point's x and y, and then call

	XFillPolygon(the_display, the_window, the_gc, fred, 55, Complex,
		     CoordModeOrigin);
@end(A)

@begin(Q)
> The result was that resizing the window to a smaller screen worked
> (it drew the geography once, like I want it to).
> But when resizing the window to make it bigger, the window was still
> drawn 2X).
@end(Q)

@begin(A)
Yes, the backing store will kick in when the backing store contents
are defined as valid.  When you resize the window to be smaller, the
server uses the backing store.  No expose event is generated.

You can get the same effect by using bit_gravity (also a window
attribute) which says what part of the visible window to use.  Note
that backing store is better, if available, since it isn't effected
by partially obscured windows.

On the other hand, when you resize the window to be biggerr, the 
backing store contents are no longer considered to be valid, and 
an expose event is generated by the server.  

I believe this is a "feature" of the server.  It is true on at least
the DecStation server, and may be present in other servers as well.

The way to avoid this problem is to maintain state (ignore 2 expose
events in a row or do a ClearWindow only on the first expose).
@end(A)

@begin(Q)
Do subwindows somehow result in the receipt of extra exposure
events?
@end(Q)

@begin(A)
No and yes.  If you did not do an XSelectInput on the subwindow for
exposure events, you should get no extra exposure events per se.

However, some servers may generate additional exposure events in a
series for the top-level window.  That is, the server may generate
a series of exposure events, one for each region of the window that
is exposed.  Depending on the server implementation, the presence
of a subwindow could cause additional exposure events in this
series to be generated.  If you are drawing only when the count
field in the XEvent is zero, this shouldn't be a problem.  
@end(A)

@begin(Q)
I am trying to use XQueryTextExtents to figure out the size of
the bounding box around the text string.

I am confused by the definition in the structure of

	XID fid;

How do you fill in the XQueryTextExtents structure with this value?

What is an XID, how do you get one, how do you set its value of
fid properly?
@end(Q)

@begin(A)
The XID is a documentation convention.  You can use either
a font id (such as in the fontstruct) or a GContext (which
is seldom used).  You can just use font_struct->fid.

However, note that if you are doing a XLoadQueryFont, it
returns a fontstruct, which is a client-side data structure.
Once you have it, you do not want to do a XQueryTextExtents,
which requires a round trip to the server (and is therefore
very expensive since it's a synchronous call).  You want to
do an XTextExtents, which is an equivalent call but which
uses the fontstruct on the client-side to do its calculations.
@end(A)

