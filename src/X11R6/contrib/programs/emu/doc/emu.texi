\input texinfo  @c -*-texinfo-*-
@comment %**start of header (This is for running Texinfo on a region.)
@comment emu.texi,v 1.8 1994/06/05 14:24:21 me Exp
@setfilename emu
@settitle Emu Reference Manual
@synindex vr fn

@comment
@comment emu.texi,v
@comment Revision 1.8  1994/06/05  14:24:21  me
@comment Even more changes by Jordan
@comment
@comment Revision 1.7  1994/06/05  10:59:43  me
@comment My last-minute changes
@comment
@comment Revision 1.6  1994/06/05  10:44:08  me
@comment Jordan's last minute rework
@comment
@comment Revision 1.4  1994/06/03  17:38:00  me
@comment Jordan's newer version
@comment
@comment
@comment %**end of header (This is for running Texinfo on a region.)

@ifinfo
This file documents the features of the @code{emu} terminal emulation
system.

Copyright 1990 by PCS Computer Systeme, GmbH. Munich, West Germany.
Copyright 1994 by Jordan K. Hubbard and Michael W. Elbel

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
NO EVENT SHALL PCS, THE AUTHORS, OR THEIR HOUSEPETS BE LIABLE FOR
ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. SO DON'T SUE US.
THANK YOU.

@ignore
Permission is granted to process this file through @TeX{} and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled ``Copyright Information'' is included exactly as in the
original, and provided that the entire resulting derived work is distributed
under the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled ``Copyright Information'' and this
permission notice may be included in translations approved by
the authors instead of in the original English.
@end ifinfo

@setchapternewpage odd
@titlepage
@sp 12
@center @titlefont{The Emu Manual}
@sp 4
@center by Jordan K. Hubbard
@center with Michael W. Elbel
@sp 2
@center Edition 1.1 for @code{emu} 1.3
@sp 2
@center June 1994
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1990 PCS Computer Systeme, GmbH
Copyright @copyright{} 1994 Jordan K. Hubbard and Michael W. Elbel
@sp 2
Published by Jordan K. Hubbard and Michael W. Elbel
Lurking-on-the-Internet Publishers, UnInc.
Munich / Dublin

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
copyright notice and section entitled ``Copyright Information'' is
included exactly as in the original.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled ``Copyright Information'' may be
included in a translation approved by the authors instead of in the 
original English.
@end titlepage
@page

@node Top, Introduction, , (DIR)

@dfn{Emu} is a programmable, flexible terminal emulator for the @emph{X
Window System}.  Rather than being one monolithic application, emu is
written as a set of general-purpose widgets that can be used by other
applications.  Emu is also fully extensible, and supports a configurable
terminal emulation mechanism.

@menu
* Introduction::		Introductory comments.
* Copyright Information::	Important copyright information.
* Terms::                       Terms used in this manual.
* General Structure::           How it's all 
* The Emu Client::		The @code{emu} sample client.
* The Terminal::		Using the @code{term} widget.
* The Canvas::  		Using the @code{termCanvas} widget.
* The Comblock Interface::      Using the communications block mechanism.
* Index::			Index of features and concepts.
* References::			Other material of interest.
@end menu

@node Introduction, Terms, Top, Top
@unnumbered Introduction
@cindex introduction

One of the oldest and, perhaps, most used X utilities is the ubiquitous
@code{xterm} program.  An indispensible part of the @code{X Window
System}, it is nonetheless showing its age.  Due largely to creeping
featurism and the somewhat strenuous process of being ported to a number
of varied and idiosyncratic platforms, the @code{xterm} source has also
reached a state where further extension and maintainance has become
a non-trivial exercise.

In 1990, we faced the choice of either further extending
@code{xterm} or starting over from scratch.  After a long evaluation,
we came to the conclusion that further attempts to modify @code{xterm}
would benefit neither us or the X community at large.

Combining our altruistic impulses with a genuine need for a VT220
compliant @code{xterm}, we then set out to completely rewrite
@code{xterm} from scratch.  Using some of the lessons learned from the
original @code{xterm} (design vs creeping mutation) and taking full
advantage of having a nice toolkit to work with (something, to be fair,
the original designers did not have), we managed to add many new
features without significantly exceeding the size of the old
@code{xterm} program.  We were also able to use the toolkit's widget
mechanism almost exclusively as a framework, a major win in and of
itself.

A secondary, but by no means trivial, design goal was to release not so
much "an @code{xterm} done right" but also a set of tools with which
users could go well beyond what is initially offered here.  Given that
the needs of users are many and varied, we focused more on providing a
logical and portable framework than on providing a single-purpose canned
solution.  Using this system, users can easily add custom terminal
emulators, display @dfn{canvases}, menus and other 'decorations' using
either an @code{Athena} or @code{Motif} @emph{look and feel} as desired.
Application writers will also now find it quite simple to use a
@emph{slave} @code{xterm} from a larger application; one simply creates a
couple of widgets and takes advantage of the hooks provided for getting
at the incoming and outgoing data streams.  A number of programmers
accustomed to fighting with the old @code{xterm}'s @emph{slave mode}
should now find life much easier.  Like the @code{X group} itself, we
have attempted to provide mechanism, not policy, wherever possible.

The end result, after almost 2 man years of work, is something both
simpler and more complicated than the original @code{xterm}.  As we were
stuck for a really clever name, we decided to call it @dfn{emu}, which
is short for emu-lator.  Whether or not the code makes one think of
large, hairy, flightless birds is purely a subjective issue and we
refuse to touch it.

Being the kind souls that we are, we present this code free of charge to
the X user community for their collective enjoyment and/or amusement.
Caveat Emptor.

@node Terms, Copyright Information, Introduction, Top
@unnumbered Glossary of Terms
@cindex terms

In this manual, a number of special terms will be used that should be
understood before going any further.  Some of them may not make much
sense initially, but it will at least be clear what the various
buzzwords and abbreviations mean (each abbreviation will also be
expanded the first time it's used, so it's not necessary to memorize
everything at this juncture).

@table @samp
@item auxTrans
@cindex auxilliary translation
An @dfn{AUXilliary TRANSlation}.  Used by the @dfn{termCanvas} widget to
change the meanings of various keycodes (I.E. the keyboard mapping) on
the fly. @code{auxTrans Entries}. @refill

@item canvas
@cindex canvas
Generally refers to the @dfn{termCanvas} widget, though it can refer to
any @code{canvas} widget being used for character or graphics I/O by the
@dfn{term} widget. @xref{The Canvas}. @refill

@item comblock
@cindex comblock
A data structure used by the @dfn{ComBlock} for data exchange, as well as
a permanent 'scratch pad' for @dfn{IOP} programs to store data of general
interest. @xref{The Comblock Interface} @refill

@item comblock communications protocol
@cindex comblock communications protocol
This mouthful refers to a specialized protocol used by the @code{term}
widget and its @code{canvas} to pass @dfn{requests} and ancillary
information back and forth. @xref{The Comblock Interface}. @refill

@item emu
@cindex emu
Refers both to the @dfn{emu} client program and the system as a whole.
@xref{The Emu Client}. @refill

@item emulation
@cindex emulation
A collection of @dfn{FLUT}s, @code{auxTrans} entries, @dfn{ROP}s and
@dfn{input sequences} that describe a complete terminal emulation. @refill

@item FLUT
@cindex FLUT
A Font LookUp Table. Used by the @code{termCanvas} widget to map ASCII
characters to actual font glyphs. @xref{OP_CHANGE_FLUT}. @refill

@item IOP
@cindex IOP
An Intermediate OPeration. Used by the @code{canvas} and @code{term}
widgets as well as the menu package. @code{IOP}'s are the workhorses of
the @code{emu} package and, aggregated, form a small but functional
programming language. @xref{The IOP Language}. @refill

@item parser
@cindex parser
Escape sequence parsers come in two flavors, @emph{hard} and
@emph{soft}. A @code{hard} parser is one compiled directly into the
@code{term} widget for a specific terminal type. A @code{soft} parser is
defined wholly in the resource database and can be modified without
having to recompile anything. @refill

@item operation code
@cindex operation code
@cindex opcode
A unique integer id identifying some @code{canvas} action to be
performed. A request may or may not take parameters, which are then
found in the @code{comblock}. @refill

@item sequence list
@cindex sequence list
A comma separated list of one or more @code{requests}. @dfn{Sequence
Lists} are only encountered as parts of @xref{Input Sequences} and
@code{ROPs}. @refill

@item ROP
@cindex ROP
A Reverse OPeration. This is basically the mirror image of an
@xref{Input Sequences}. Rather than describing characters going in, it
describes an @emph{outgoing} action to be performed (though this need
not necessarily result in any characters being output). @xref{ROP
Sequences}. @refill

@item input sequence
@cindex input sequence
A @code{request list} followed by a bracket delimited string of tokens.
Each token describes either a character to be expected as input or an
@code{IOP} to be performed along the way. Refer to @xref{Input Sequences} for
more information, as this is somewhat complicated.

@item input sequence list
@cindex input sequence list
One or more @code{input sequences} that, as a unit, form part of an
@dfn{emulation}.
@refill

@item term
@cindex term
Refers to the @code{term} widget which wraps around the @code{canvas}
and any ancillary widgets. @refill

@end table

@node Copyright Information, General Structure, Terms, Top
@unnumbered Copyright Information

@display
Copyright @copyright{} 1990 PCS Computer Systeme, GmbH
Pfaelzer-Wald-Str 36, D-8000 Munich 90, West Germany.

Copyright @copyright{} 1994 Jordan K. Hubbard and Michael W. Elbel

Everyone is permitted to copy, modify and distribute copies of this
license document, provided that the section ``Copyright Information'' is
included exactly as in the original.

                        All Rights Reserved

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

We would also like to request that any enhancements to this software, or
its documentation, be sent back to one of the authors for inclusion in
subsequent releases. While you are certainly not in any way legally
required to do so, such cooperation will result in a better emu for all
concerned and is thus kindly requested.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL PCS, THE AUTHORS, OR THEIR HOUSEPETS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
@end display

@node General Structure, The Emu Client, Copyright Information, Top
@chapter Structure of the @code{Emu} System.
@cindex structure
@cindex emu, system

What has been referred to so far as @emph{The Emu System} is really
nothing more than two widgets and a sample client (@pxref{The Emu Client}).
What makes it a @emph{system} is more the way it all fits together and
provides a framework for future expansion.

To better understand the system, it is probably a good idea at this
point to break it down into its component parts and attempt to describe,
briefly, what each part does. What follows should only be considered a
brief overview since each topic is described in much more detail in its
own section of this manual.

The first item of interest is the @code{term} widget, which basically
manages all aspects of the operating system dependent interface: PTY
allocation, process management, and terminal mode manipulation. To put
it another way, the @code{term} widget can be thought of as analgous to
the communications hardware of an actual terminal, minus the screen and
keyboard.

The @code{term} widget also handles all parsing of special input
sequences (more commonly referred to as 'escape sequences) from the
process, turning them into operation codes (@pxref{Input Sequences})
that the @code{canvas} understands.

Finally, the @code{term} widget provides a number of features and hooks
for applications that want to do fancier I/O control and/or additional
widget management. While the @code{term} widget typically manages just
one @code{canvas} child, it can also manage other children (even
additional canvases) as necessary (@pxref{The Terminal}).  This is
typically used to implement scrollbars and menubars.

The second (and complimentary) widget of interest is the @code{canvas}.
The @code{canvas} is in charge of all 'screen' output, as well as the
translation of @code{keycode} sequences into ascii characters and mouse
controlled cut and paste operations.  Using the analogy of a physical
terminal again, the @code{canvas} widget would be the CRT and keyboard
part.

The @code{canvas} compliments the @code{term} widget by supporting a set
of generic operations, such as moving the cursor, inserting or deleting
text, etc, which the @code{term} widget then 'requests' it to perform as
its recognises various input sequences in its parser
description. Likewise, the @code{canvas} relies on the @code{term}
widget to communicate with the process when dispatching of I/O from the
keyboard or cut buffer/selection mechanism is required.

As stated earlier, the term 'canvas' actually refers to any widget that
can speak the ComBlock protocol with the @code{term} widget, not just
the particular widget we supply. In theory, any number of @code{canvas}
widgets can, and may, exist for doing various types of display I/O. At
the time of this writing the one @code{canvas}, called the
@code{termCanvas} (@pxref{The Canvas}), exists for doing
reasonably sophisticated text display (basic text + VT220
attributes). In time, there will probably be a number of additional
canvases that support generic graphics operations, auxilliary input
devices, etc. A client application will then have the option of creating
any number of @code{term}/@code{canvas} pairs (or one @code{term} with
multiple @code{canvases}) to suit a particular need. @refill

The final part of the system is the @code{emu} sample client, which will
typically be all the average user sees or cares about. Most of the
client is rather simple. It first creates a shell widget to interact
with the window manager, as is normal, and provides a number of command
line options to get directly at various @code{term} and
@code{termCanvas} resources.  It then creates a @code{term} widget as its
child and, in turn, a @code{termCanvas} widget and several optional
control widgets under it.  As previously stated, the @code{term} widget
does not really care about any widgets other than its @code{canvas},
though it will readily manage them. This feature is used by the
@code{emu} client to optionally create a scrollbar and menu bar. Since
the @code{term} widget does not know or care about either of these, the
management of their size and position is left to the @code{emu} client
itself. This is handled through a @dfn{callback} provided by the
@code{term} widget which is called whenever a @dfn{Resize},
@code{GeometryRequest} or @code{Realize} occurs. The @code{emu} client
then adjusts things accordingly. The scrollbar callbacks are likewise
handled by the client with the scrollbar motion being translated into
@code{canvas} scroll requests.

While this approach may seem to put an undue burden on the client
program, it has helped to keep the @code{term} and @code{termCanvas}
widgets free of application specific code, and makes the decoupling
of GUI elements and terminal emulation possible.

Also part of the @code{emu} client is the configurable @code{menu}
package. Through the toolkit translation mechanism, any number of menus
can be automatically attached to the @code{term} widget without it
having to know or care. Unlike the menu code in the old @code{xterm}
program, a menu's actions (as well as appearance) are completely user
configurable. @xref{Menu Configuration}.

Summary:

The general philosophy of the @code{emu} system was to provide two, very
general purpose, communication and text manipulation widgets with ample
room for future expansion. All 'decoratations' like scrollbars, menu
bars and menus are implemented on the client side through hooks made
available by the widgets for that purpose. This approach also allowed
the @code{emu} client to provide either @dfn{Athena} or @dfn{Motif}
widget look-and-feel at very little added cost.

@node The Emu Client, The Terminal, General Structure, Top
@chapter Using The @code{Emu} Client
@cindex client
@cindex emu, client

The @code{emu} client is used in much the same way as the old
@code{xterm} program was, though there are a few new command line
options. Since the @code{emu} system also relies much more heavily on
resources than the old @code{xterm}, installation of the application
defaults is almost mandatory before @code{emu} will work properly.
Without its resources, the typical emu client does not even know how to
emulate a terminal!

Virtually all aspects of the @code{emu} system are user configurable
with almost nothing being assumed about specific terminal types,
keyboards, output fonts or menus.  Of course, should the standard
@code{VT220 Emulation} included with @code{emu} be sufficient for your
needs, you won't need to worry about any of this, but should you need
it, the ability to customize just about everything is there.

@menu
* Emulation Design::	Designing a new emulation.
* Menu Configuration::	Configuring menus in the @code{emu} client.
@end menu

@node Emulation Design, Menu Configuration, , The Emu Client
@section Designing a New Emulation.
@cindex emulations, writing

Writing a new (or modifying an existing) @code{Emulation} generally consists
of 3 basic steps:

@itemize @bullet
@item
Determining which set of escape sequences are to be emulated and how
the terminal generally behaves. Most terminals have various quirks that
must be taken into account when writing the various @xref{Input Sequences}
and @xref{ROP Sequences} for them, so it is important to understand the
terminal in question fairly well before writing any configuration code.

@item
Familiarizing yourself with the different types of operations the @code{canvas}
supports and begin mapping out the correspondence between terminal features and
@code{canvas} request types.

@item
Writing the first @xref{ROP Sequences} for initializing the terminal to
get a feel for writing @code{IOP} code. Start with a very basic subset
of the terminal's escape sequences and work your way up, testing your
emulation carefully as you go along. It's easy to introduce grammer
ambiguities by injudicious use of @code{%s} and @code{%d} sequences
(@pxref{The IOP Language}), so new sequences should be added with care.
@end itemize

@node Menu Configuration, , Emulation Design, The Emu Client
@section Menu Configuration
@cindex menus
@cindex menu configuration

Emu's menus are very straight-forward, the menu module (as with the rest
of emu) providing a simple mechanism without trying to determine usage
policy.  The module provides facilities for creating, managing,
popping-up, and attaching policy (functionality) to menus.  It does not
dictate how many menus or menu items exist, what is in each menu, what
functions it performs, or how it is popped up.  This is all user
configurable, and is specified via the resource manager.  Menus are,
therefore, fully extensible and configurable.

@menu
* Menu Resources:: What can be configured and how, examples.
* Menu Item Resources:: What can be configured and how, examples.
@end menu

@node Menu Resources, Menu Item Resources, , Menu Configuration
@subsection Menu Resources
@cindex menu configuration parameters
@cindex menu translations
@cindex menu names
@cindex menu ROPs

The emu menus are configurable through the resource file.  All Athena
Form, MenuButton (both for menu bar), SimpleMenu, Sme, SmeBSB, and
SmeLine, or Motif XmRowColumn, XmCascadeButton (both for menu bar),
XmPopupMenu, XmPushButtonGadget, XmLabelGadget, and XmSeparatorGadget
resources are available for customization.  Please see the appropriate
Intrinsics, Athena or Motif documentaion for further clarification of
these resources.

In addition to these standard widget resources, the number of menus, the
number of menu items, and the position of menu item separators are
settable via resources.  For each menu item it is also possible to
specify what functionality (action) lies behind it.

Menus are configured via the screen translations by specifying a menu
name to pop-up and a key/button sequence indicating how to activate it.
For example, the default configuration could look like:

@example
    *term.screen.Translations: #override\n\
        Ctrl ~Shift<Btn1Down>:          XpEmuPopupMenu(menu1) \n\
        Ctrl ~Shift<Btn2Down>:          XpEmuPopupMenu(menu2, 302) \n\
        Ctrl ~Shift<Btn3Down>:          XpEmuPopupMenu(menu3, 303) \n\
        Ctrl  Shift<Btn3Down>:          XpEmuPopupMenu(menu4) \n
@end example

These translations show that pressing 'Ctrl', but not
'Shift', Pops-Up A Menu Called 'Menu1'.  The name
'menu1' actually becomes the name of the menu widget when it is
created.  It is necessary to have this name since it is used further for
qualifying resources.  The second and third menus are specified in a
similar fashion but by pressing (mouse) button2 and button3,
respectively.  The fourth menu is also activated by pressing button3,
but this time the 'Ctrl' And 'Shift' keys must be pressed.

'XpEmuPopupMenu' expects at least a menu name as a parameter.  If
other actions (ROPs) are desired on a per menu, not menu item, basis
then additional parameters (ROP numbers) may be declared after the menu
name.  These actions are performed each time just before the menu is
popped-up.  The second and third menu declarations illustrates such a
situation.

@node Menu Item Resources, , Menu Resources, Menu Configuration
@subsection Menu Item Resources
@cindex menu item configuration parameters

The following resources control the behavior of individual menu items.

@menu
* Number Of Menu Items::          How many menu items there are.
* Menu Item Line Separators::     Controlling menu appearance.
* Menu Item Labels::              The individual labels to assign menu items.
* Menu Item Actions::             Configuring what menu items do.
@end menu

@node Number Of Menu Items, Menu Item Labels, , Menu Item Resources
@subsection Number Of Menu Items
The menu package creates the number of user specified items.  The
default configuration for 'menu1' might look like:

@example
    *menu1.numberItems:             8
@end example

This resource must be given.

@node Menu Item Labels, Menu Item Line Separators, Number Of Menu Items, Menu Item Resources
@subsection Menu Item Labels

It is not necessary to specify menu item labels; the toolkit default is
to use the menu item widget name, which is, e.g., 'item1'.  The
resource file, however, does specify item label defaults for the
declared menus.  The 'menu1' defaults could be:

@example
    *menu1*item1.label:             Redraw
    *menu1*item2.label:             Reset all
    *menu1*item3.label:             Set TTY sane
    *menu1*item4.label:             Set TTY origin
    *menu1*item5.label:             Send INT signal
    *menu1*item6.label:             Send HUP signal
    *menu1*item7.label:             Send TERM signal
    *menu1*item8.label:             Send KILL signal
@end example

@node Menu Item Line Separators, Menu Item Actions, Menu Item Labels, Menu Item Resources
@subsection Menu Item Line Separators
@cindex menu item line separators

In order that menu items within a menu may be functionally (or otherwise)
grouped, line separators may be specified in the resource file.  Items after
which to put line separators are indicated as such:

@example
    *menu1.itemLines:               item1 item4
@end example

@node Menu Item Actions, , Menu Item Line Separators, Menu Item Resources
@subsection Menu Item Actions
@cindex menu item actions

In most cases, it is necessary that for each menu item an action is
specified.  The action resource is, in effect, the function that is
invoked when the menu item is selected.  This resource may either be a
number (ROP action) or a string (emulation action).  For example,
'menu1''s items could have ROP action numbers as given below:

@example
    *menu1*item1.action:            310
    *menu1*item2.action:            311
    *menu1*item3.action:            312
    *menu1*item4.action:            313
    *menu1*item5.action:            314
    *menu1*item6.action:            315
    *menu1*item8.action:            316
    *menu1*item9.action:            317
    *menu1*item10.action:           318
    *menu1*item11.action:           319
@end example

An example of emulation action specification is shown by the possible
default 'menu4' action resources:

@example
    *menu4*item1.action:            tty
    *menu4*item2.action:            emu
@end example

Code

Menus are created at that moment the user first clicks a particular
button.

The menu package has three explicit contact points to the rest of the
emu program.  The first is for initialization, which simply registers
the exportable actions (XpEmuPopupMenu) with the translation manager.
This initialization routine (XpEmuInitializeMenus) is the only routine
that must be called by the emu client program.

The second point of contact is for the dispatching of actions
(XpEmuMenuDispatch) when menu items are clicked.  This is done indirectly
via the single menu item callback (DoInteract).  The callback passes the
respective menu item ROP action number or emulation action string, specified
in the resource file, to the emu program.  If no ROP number or emulation
name exists for the selected menu item, the widget label, or lastly, the
widget name are used.  This indicates the selection is an emulation.

The third contact point is the complement of the second.  It is for the
emu program to tell the menu module to perform some action
(XpEmuMenuAction).  The actions the menu package can perform are limited
to activating/deactivating (sensitizing) and marking/unmarking menu items.

The making of a menu consists of detecting the number of items and
possible separator lines via the resource manager, and then creating the
menu with the single menu callback.  No local menu call data exists; all
necessary menu information is stored in and derived from the resource
manager or the toolkit.  In this way, no local data structures are necessary,
no local memory is allocated, and therefore, the number of menus and the
number of menu items are dynamic and may be of any size.  Also, by using a
single callback with user specifiable ROP actions, functionality is attached
at menu realization time by the resource manager.

@node The Terminal, The Canvas, The Emu Client, Top
@chapter The Term Widget
@cindex term widget
@cindex termWidget

The @code{term} Widget is used to encapsulate three basic things in
the general task of emulating a terminal:

@itemize @bullet

@item
All terminal I/O and most of the generally convoluted system
dependencies that go into writing any kind of application that must
allocate @code{PTY}s and muck around with different types of terminal
information structures on the many and varied incarnations of
@code{UNIX}(tm).

@item
All the the GUI elements comprising a @code{terminal emulator} from the
user's perspective as it is a @code{composite} widget and can manage
multiple children.  Typically, this will be a @code{canvas} and perhaps
a scrollbar and some menus.

@item
The actual task of parsing escape sequences and providing terminal
emulation.  The @code{term} widget also provides something fairly unique
in this regard in that it supports the specification of both the typical
@emph{hard wired} parsers (as in the current @code{xterm}) and a more
dynamic specification process through a small, fast interpreted language
called @code{IOP} (@pxref{The IOP Language}).  This allows you to
configure @code{emu} to emulate entirely arbirary terminals (within the
basic capabilities of the display @code{canvas}) from simple resource
manager descriptions, and to change emulations on the fly.

@end itemize

@menu
* Term Resources::              Term Widget resources.
* New Architectures::           Porting the @code{term} code to a new machine
* Managing Children::           How to manage GUI objects.
* The IOP Language::		The IOP language for terminal emulation
@end menu

@node Term Resources, New Architectures, , The Terminal
@section Term Widget Resources
@cindex resources
@cindex term widget resources

The following X-Toolkit resources are provided by the Term widget.

@table @code
@item command
@cindex shell command
This is the shell command to invoke when first starting up the term
widget.  This is typically a shell, and defaults to @file{/bin/sh}.

@item commandArgs
@cindex command arguments
Any arguments to pass to the shell command in @code{command}.

@item termType
@cindex terminal type
The terminal type to initially configure the emulator for.  Defaults
to @code{xterm}.

@item canvas
@cindex canvas
How to register a @code{canvas} widget with the terminal emulator.
Usually done at startup time.

@item iopRequestProc
@cindex IOP request procedure
A callback list of procedures to call when the @code{IOP} call @code{C}
is invoked.  See @code{IOP Glossary} for more details.

@item layoutProc
@cindex layout procedure
A layout procedure to call when a child requests a size or position
change.  This is typically used for effective management of things like
@code{canvas}s that want to toggle between 80 and 132 columns, for
example.

@item processDeath
@cindex process death handler
A callback list of procedures to call when the sub-process (or any
subprocess) managed by the term widget ties.

@item readSize
@cindex read size
The number of bytes to try to buffered read from a pty at once.
Increasing this can result in better I/O performance but at a possible
loss in interactive response.  The default settings are probably best
left alone.

@item inParser
@cindex input parser
A callback list of procedures to call when input comes in from the
sub-process.  By default, the parser(s) are at the end of this list, but
you are free to add your own procedures to the beginning if you want
early access to the data.  Each callback in the list is passed a pointer
to the input buffer and length, which they are free to adjust if they wish
to "remove" input meant for them alone.

@item outParser
@cindex output parser
A callback list of procedures to call on outgoing data to the
sub-process.  This typically might be used for post-processing of data
before it actually reaches the tty output routines, but is typically
left NULL.

@item utmpInhibit
@cindex utmp
@cindex utmp inhibit
If the writing of utmp entries is supported, inhibit it.  By default
this is false.

@item loginShell
@cindex login shell
Set if you want the sub-process to be invoked as a login shell.

@item rops
@cindex ROP
A list of ROPs for general usage.

@end table

@node New Architectures, Managing Children, Term Resources, The Terminal
@section Porting To New Architectures
@cindex new architectures

The task of allocation ptys, getting and setting tty values and dealing
with things like @code{utmp} entries are all encapsulated by a set of
standardized routines for each OS type in the @file{term/sysdep}
directory.  The routines are also layered in such a way as to support
the specification of new operating system definitions in terms of
existing ones, and for this no documentation will suffice so well as
simply looking at the existing examples. A fairly rich set exists for
@code{System V}, @code{BSD} and @code{Linux} architectures, and in all
likelyhood it should require little more that adapting an existing set
of descriptions when porting to a new machine at this point.

By convention, the system dependent routines should be implemented
in two files under the @file{term/sysdep} directory:

@itemize @bullet

@item
term/sysdep/proc_<new_os_type>.i
Which encapsulates all the process handling functions.

@item
term/sysdep/tty_<new_os_type>.i
Which encapsulates all the tty handling functions.

@end itemize

These two files are then selectively pulled in with @code{#ifdef}s in
the files @file{term/process.c} and @file{term/tty.c}, respectively.
Look in these two files to see how existing systems are configured
before doing anything else.

The following routines comprise the @emph{system encapsulation} API
as implented in proc_*.i and tty_*.i:

These should be implemented in proc_<new_os_type>.i:

@table @code

@item void process_init(TermWidget w)
@cindex process_init

Should do whatever's necessary to fork() off a process, initialize the
new process group, chown the slave end appropriately, etc etc.  Look at
one of the existing examples for more details.

@item int process_wait(int *failcode)
@cindex process_wait

Does whatever's necessary to wait() for a process that's died (this
routine is only called in the event of child death). The routine should
return the process id of the recently deceased with the value it
returned (unmodified) being also stored in "failcode".

@end table

And these should be implemented in tty_<new_os_type>.i:

@table @samp

@item String tty_find_pty(TermWidget w)
@cindex tty_find_pty

Search for a free pty on the system and open it, assigning the
appropriate Term widget file descriptors to the newly opened master end.
Return the name of the master end as a string. Look at the existing
examples for a good place to start; they're already pretty general.

@item void tty_set_size(TermWidget w, int rows, int cols, int width, int height)
@cindex tty_set_size

Do whatever SIGWINCH'y type things that are necessary to let term's
subprocess know that the window size has changed. This routing is
optional, though certain editors may misbehave without it.

@item void tty_add_utmp(TermWidget w)
@cindex tty_add_utmp

Add a utmp and/or wtmp entry for the term widget's tty. This routine
is optional, though certain unix programs may fail without it.

@item void tty_remove_utmp(TermWidget w)
@cindex tty_remove_utmp

Remove a utmp and/or wtmp entry for the term widget's tty. This routine
is optional, though it most certainly should be implemented if
tty_add_utmp() is.


The next three routines pass a private data structure around (the contents
of which are left to their discretion) which is treated as a "generic"
pointer value by the rest of the system.

@item Generic tty_get_values(TermWidget w)
@cindex tty_get_values

Returns the current tty values for term's PTY. If "w" is NULL, then returns
current values for invoking tty (only done once). This routine is optional,
though performance without it may be marginal on some systems, depending
on defaults.

@item Generic tty_get_sane(TermWidget w)
@cindex tty_get_sane

Returns a "sane" set of values which will result in law and order
being restored on a PTY when applied. This routine is optional, though
performance without it may be marginal on some systems, depending on
defaults.

@item void tty_set_values(TermWidget w, Generic values)
@cindex tty_set_values

Sets tty values for term's PTY to be "values" (assumed to be the
product of an earlier call to tty_get_values() or tty_get_sane()).
This routine is optional, though performance without it may be
marginal on some systems, depending on defaults.

@end table

@node Managing Children, The IOP Language, New Architectures, The Terminal
@section Managing Child Widgets
@cindex child widgets
@cindex managing children

NOTE: This section currently unimplemented due to lack of time.  Please
see the sample client code that deals with scrollbars for a pretty
reasonable example of how to do some of this.  The canvas creation code
also deals with the @code{term} widgets' handling of children.

@node The IOP Language, , Managing Children, The Terminal
@section The IOP Language
@cindex IOP Language

The @code{IOP} is the low-level workhorse of the @code{emu} package,
doing everything from on-the-fly coordinate transformation in
@code{Input Sequences} to setting flags, sending signals or invoking
processes from menus!  It is used in the consruction of so-called
@emph{soft parsers}, and is described in the overview.

@menu
* IOP Overview::	All about IOPs.
* IOP Glossary::        All the IOP codes in summary.
* Input Sequences::	Constructing a sequence based parser.
* ROP Sequences::	Writing output and auxilliary work sequences.
@end menu

@node IOP Overview, IOP Glossary, , The IOP Language
@subsection IOP Overview
@cindex IOP Overview

@code{IOP} code looks something like the @code{Forth} language, on which
it is in fact loosely based. Like @code{Forth}, IOPs have a stack on
which they can store and manipulate data. Also provided are 128 typed
registers for general storage of data and inter-widget communication
(@pxref{The Comblock Interface}).

While it may appear at first glance that @code{IOP} represents serious
engineering over-kill, let us assure you that each and every feature
of @code{IOP} was added only after identifying a clear need for it.
The examples given below only scratch the surface of what a more
advanced, real-life terminal might desire in the way of emulation and,
if you look at the @file{tdesc/*} examples, you'll soon see that
emulating terminals such as the @code{vt220} requires a fairly
sophisticated array of tools!

@code{IOPs} can be (and usually are) imbeded in @code{ROP} or @code{Input}
sequences by using the special @code{Meta} characters % and/or @{@}
characters.

For example, take the following IOP sequence:

@example
			%ga%1%+%2%*%pa
@end example

While this may look like a line of tty noise to the uninitiated user,
it's actually quite simple. The first @code{IOP} is @var{%ga}, which
means `Get Register @var{A} And Push It On The Stack.' The next
@code{IOP}, @var{%1} simply pushes a literal integer `1' onto the stack.
The @var{%+} @code{IOP} pops off two stack items (in this case, the
contents of register `a' and 1) and adds them together, pushing the
result onto the stack.  Now @var{%2} is pushed and @var{%*} pops
it, and the earlier result from @var{%+}, multiplying them together and
pushing the result. Finally, @var{%pa} 'Pops the stack into
register @var{a}' and we're done.

Another way of specifying @code{IOP} sequences is to use the `%@{@}'
delimiters, which mean 'treat all characters in the following sequence
as @code{IOP} characters. The above sequence could thus also be more
easily expressed as:

@example
			%@{ga 1 + 2 * pa@}
@end example

The whitespace between @code{IOP} characters is not generally required
(thus you could also say: %@{ga1+2*pa@}), but serves to make the code more
readable and is encouraged.

String, character and numeric constants be pushed on the stack as
`pseudo IOPS' in the following manner:

@table @code
@item nnn
Where @code{nnn} is one or more decimal digits.

@item 'n'
Where @code{n} is a single character or character specifier (e.g. \nnn,
^n, etc).

@item 'n..n'
Where @code{n..n} is one or more ascii characters. As with character
constants, the standard `C style' character escapes are supported.

@end table

@node IOP Glossary, Input Sequences, IOP Overview, The IOP Language
@subsection IOP Glossary.
@cindex IOP
@cindex IOP Glossary

The following @code{IOP} characters are supported by @code{emu}:

@table @code

@item +
@cindex IOP +
Adds the top two stack items, pushing the result.

@item -
@cindex IOP -
Subtracks the top two stack items, pushing the result.

@item *
@cindex IOP *
Pop the top two stack items and multiply them, pushing the result.

@item /
@cindex IOP /
Divide the top two stack items, pushing the result.

@item &
@cindex IOP &
Bitwise AND's the top two stack items, pushing the result.

@item ^
@cindex IOP ^
Pop the top two stack items, bitwise-not them, pushing the result.

@item |
@cindex IOP |
Pop the top two stack items, bitwise-or them, pushing the result.

@item ~
@cindex IOP ~
Pop the top stack item and complement it, pushing the result.

@item p@samp{a}
@cindex IOP p
Pop the top of stack and store in register @samp{a}.

@item g@samp{a}
@cindex IOP g
Get the contents of register @samp{a} and push on the stack.

@item G
@cindex IOP G
@emph{Indirect get from register} - pops the top of stack and uses is as a
register name, pushing the value of that register in its place.

@item P
@cindex IOP P
@emph{Indirect pop to register} - pops two items from the top of stack,
using the top value as a register name and the other as the value to store
into it.

@item C
@cindex IOP C
Pops an integer from the stack and uses it as an operation code
in a direct call to the @code{canvas}.

@item c@samp{a}
@cindex IOP c
Pushes argument @samp{a} onto the stack as a character.  In a ROP this
acts differently in that it actually writes the character out to the tty
(and in which case the value @samp{a} is also optional, the top stack
item being popped and output when not specified).

@item d@samp{a}
@cindex IOP d
If in an IOP, push the argument @samp{a} as an int.  If a ROP, pop the
stack and output the value as an integer to the tty (ignoring @samp{a}).

@item s@samp{a}
@cindex IOP s
If in an IOP, push the argument @samp{a} as a string.  If a ROP, pop the
stack and output the string value to the tty (ignoring @samp{a}).

@item ba
@cindex IOP ba
Pops a string from the stack and appends it to the input stream
buffer.

@item bs
@cindex IOP bs
Pops a string from the stack and replaces the input stream with
it, discarding any previous contents.

@item @@
@cindex IOP @@
Given the following two stack items (rightmost on top):
<value> <CB_CHAR_TYPE|CB_INT_TYPE|CB_STR_TYPE|CB_ANY_TYPE>
Pop them and "cast" the <value> accordingly, pushing the cast value
back onto the stack.

@item X
@cindex IOP X
Drop the top stack item.

@item D
@cindex IOP D
Duplicate the top stack item, pushing the duplicate.

@item S
@cindex IOP S
Swap the top two stack items.

@item ?
@cindex IOP ?
Denote the start of a conditional expression, e.g.:

        gv ? OP_WRAP_AROUND : OP_DONT_WRAP ;

Would get the contents of register @samp{v} and, if non-zero, push
the opcode for WRAP_AROUND, else DONT_WRAP.

@item :
@cindex IOP :
Denote the `else' clause of a conditional expression.

@item ;
@cindex IOP ;
Denote the `endif' part of a conditional expression (terminate the
conditional expression).

@item =
@cindex IOP =
Pop the two stack items and push a 1 or 0 if they are or are not
equal to eachother (works for strings as well as integers).

@item >
@cindex IOP >
Pop the top two stack items and push a 1 or 0 depending on whether or
not the top stack item is greater than the first.  Works for both
strings and integers.

@item <
@cindex IOP <
Pop the top two stack items and push a 1 or 0 depending on whether or
not the top stack item is less than the first.  Works for both strings
and integers.

@item A
@cindex IOP A
Pops top two stack items and pushes the `logical AND' (e.g. they're both
non-zero) of the two.  Generally used in conditional expressions.

@item !
@cindex IOP !
Pops the top stack item and pushes its `logical NOT'.

@item O
@cindex IOP O
Pops the top two stack items and pushes its `logical OR' (e.g. one of the
two is non-zero).

@item f
@cindex IOP f
Pops top of stack as a generic pointer and free()s it (dangerous!  Make
sure you know what you're doing).

@item j@samp{a}
@cindex IOP j
Jumps to a label (see IOP @code{L}), where @samp{a} is the single character
label in question.

@item L@samp{a}
@cindex IOP L
Declare a single-character label @samp{a}, which can be jumped directly
to (see IOP @code{j}).

@item R
@cindex IOP R
Pop a ROP code from the stack and recursively call it.

@item I
@cindex IOP I
Pop the top of stack and use as a signal number to send the process
(e.g. kill).

@item l
@cindex IOP l
Pop the top of the stack as a string and push the length of it.

@item t
@cindex IOP t
Pop the top of the stack as a string and set the window manager `title'
hint to it (XtNtitle).

@item i
@cindex IOP i
Pop the top of the stack as a string and set the window manager `icon
label' hint to it (XtNiconName).

@item $
@cindex IOP $
`Tokenize' a string.  This is a little difficult to describe, though
easy to do (see examples in the existing parsers).  First the the two
top stack items and popped, using the topmost as a "seperator character"
and the second as a string to index it with.  What is pushed back are
two stack items - the chunk of the string @emph{following} the index
(e.g. "what's left") and the chunk leading up to the index.  In such a
way it is possible to write loops that take a string apart using a known
seperator character.  When no further instances of the seperator can be
found, the untouched string is pushed followed by an empty string ("").

@item Tg
@cindex IOP Tg
Get the current tty settings and push them onto the stack as an
opaque (ANY) type.

@item Ti
@cindex IOP Ti
Get the initial tty settings and push them onto the stack as an
opaque (ANY) type.  The initial settings were the ones first gotten
from the tty structure when @code{emu} started up.

@item Td
@cindex IOP Td
Get the sane tty settings and push them onto the stack as an opaque
(ANY) type.  The sane settings are the ones defined internally by
whomever ported emu to your platform as the ones to be used when a
return to "sanity" is required (e.g. settings that are known to be
"good").

@item Ts
@cindex IOP Ts
Pop the settings from the top of stack and set the current tty settings
with them.

@item U
@cindex IOP U
Pop the top of stack as a string and send it to the emu client using
the "IOP request" callback list provided for that purpose.  This is used
for out-of-band communications.  See @code{XpNiopRequestProc} in the
@code{term} widget.

@end table

@node Input Sequences, ROP Sequences, IOP Glossary, The IOP Language
@section Input Sequences
@cindex input sequences

The basic premise behind parsing escape sequences (or @code{input
sequences}) in the @code{term} widget is that for any given terminal
escape sequence you want to essentially perform one or more operations
on the @code{canvas}, and that it should be fairly easy to express a
complete emulation as the set of all actions to be performed when a any
conceivable sequence comes in.

For example, let's say we want to write a very simple little terminal
emulation for a terminal that only has escape sequences for moving the
cursor up, down, left right and to any arbitrary position on the screen.
Let's also assume that such a terminal can ring its bell and handles
newlines and carriage returns correctly.  So, what might the input
sequences for such a terminal look like?

First, let's define our hypothetical terminal's escape sequence set (as
would typically be found in its documentation) so we can know just what
it is we're trying to emulate:

@example
        <ESC>J          - move cursor down
        <ESC>K          - move cursor up
        <ESC>H          - move cursor left
        <ESC>L          - move cursor right
        <ESC>=xy        - where x and y are ascii characters depicting
                        - a 255x255 screen space.
        ^G              - ring the bell
        ^M              - move to beginning of line
        ^J              - move to next line
@end example

Ok, so that's our goal.  Now we need to describe this set of sequences
to @code{emu} in a way it will understand, and in terms of the basic
operations supported by its canvas.  @code{Emu} expects such information
in the form of an @code{X-Toolkit} resource in the following format:

@example

Emu.term.<term name>-ops:  SEQUENCE [.. SEQUENCE ]

Where a SEQUENCE consists of:

        OP-CODE[,OP-CODE,..] <input-sequence>
@end example

A complete emulation description is then essentially nothing more than a
list of @code{SEQUENCE}s, each consiting of one or more @code{OP-CODE}s
and an @code{input} description.

Whenever a given @code{input-sequence} in the emulation description is
seen, each @code{OP-CODE}, or Operation Code, in the list is sent to the
@code{canvas} following the parsing and execution of any @code{IOP}
instructions imbeded in the @code{input-sequence} itself (see below).

The @code{OP-CODES} are generally specified using macros which represent
the unique operation code numbers in the @code{canvas}, which if you
look in @file{include/xt_ops.h} you can see the complete set of.  Due to
the way that @code{xrdb} works, it is possible to push the emulation
descriptions through the C pre-processor first for substitution and thus
gain this level of @code{canvas} opcode/description independance.

Sound confusing?  It is, at first, so let's just cut to the chase and
show you what the description would look like (taken in the same order)
in the resource database and describe it in more detail afterwards:

@example
*term.funkyTerm-ops: \
        OP_MOVE_REL_ROW         <\EJ%1%py>	        \
        OP_MOVE_REL_ROW         <\EK%-1%py>	        \
        OP_MOVE_REL_COLUMN	<\EH%-1%px>	        \
        OP_MOVE_REL_COLUMN	<\EL%1%px>	        \
        OP_MOVE_ABS		<\E=%c%px%c%py>         \
        OP_RING_BELL		<^G>			\
        OP_MOVE_ABS_COLUMN	<%0%px\r>               \
        OP_MOVE_REL_ROW         <%1%py\n>
@end example

To truly understand this you should also read the @xref{The IOP
Language} chapter, but we can (hopefully) describe this simple example
in enough detail to make it obvious enough on its own here.

Starting with the first line for handling the @samp{<ESC>J} sequence, we
see the opcode OP_MOVE_REL_ROW, which means, not surprisingly, "move the
cursor to a relative position in the current row".  We also see the
sequence @key{\EJ} (ESCAPE-J) followed by the @code{IOP} commands
@samp{%1}, which pushes the literal 1 onto stack, and @samp{%py}, which
pops the stack and stores it into register @code{y}.

Looking briefly into the @xref{Canvas Functions} section for a moment,
we see that OP_MOVE_REL_ROW takes its argument in register @code{y} and
so this all makes some sense - we're asking the @code{canvas} to move
the cursor down one relative column position.  In general, the
convention is that negative arguments move the cursor left or up
(depending on the operation) and positive arguments move the cursor
right or down.  In this context, the second sequence for ESCAPE-K makes
sense, as do the next two (though we notice that the OP_MOVE_REL_COLUMN
functions take their arguments in register @code{x} instead of @code{y},
this is just convention).

The OP_MOVE_ABS_COLUMN is slightly more complex in that we see the
unfamiliar @code{IOP} command @samp{%c} invoked, but this is pretty
simple as well - it just matches the next character in the input stream,
which is then pushed unchanged as an integer value into register
@code{x} (the second character going into @code{y}).

The final 3 calls are simple indeed - ring the bell on a ^G (Control-G),
move the cursor to the beginning of the current line on ^M (carriage
return) and move down one line on ^J (newline).  Voila!  We've just
created a terminal emulation!

Needless to say, actual terminals, especially fairly intelligent ones,
rarely make things this easy and you've considerably more reading ahead
of you if you truly wish to create one from scratch!  It is suggested
that you start with @xref{The IOP Language} and then @xref{Canvas
Functions} to gain a good understanding of the underlying mechanisms.

Then take a look at the @code{vt220} emulation in the @file{tdesc/}
directory for real and fairly complex examples.  It is possible to have
an amazing degree of `execution' take place in the @code{input-sequence}
alone due to the ability to imbed @code{IOP} code in it, and only a real
example will suffice in showing just how far you can go with it.  It
helps to print the @xref{IOP Glossary} out and stick it up next to your
terminal as well!

@node ROP Sequences, , Input Sequences, The IOP Language
@section ROP Sequences
@cindex reverse operations
@cindex rops

@code{ROP}s, or Reverse OPerations, are simply special instances of
@code{IOP} code that don't correspond to any actual @code{Input
Sequence}.  Rather, they're used by menus, the @code{canvas} at
initialization time (the reserved @code{ROP} @code{ROP_INIT_CANVAS} is
always called when @code{emu} first starts up and is used to put the
@code{canvas} into a known state) and by emulations that wish to
@emph{output} data to the tty, such as for terminal ID or "report
current position" sequences.

Because @code{ROP}s are more intended for output, rather that input
operations, they can in fact cause certain primitives in the @code{IOP}
language to behave somewhat differently.  Such differences, when they
occur, are noted in the relevant portions of the @xref{IOP Glossary}.

Rather than give many examples of @code{ROP} usage here, it will be left
to the user to examine some of the existing examples since, with the
possible exception of @code{ROP_INIT_CANVAS}, most uses of @code{ROP}
calls are only used in special-case situations where the user is already
likely to know exactly what they're doing.  Suffice to say that
@code{ROP}s are designed to enable the user to create arbirary
@code{IOP} "routines" that can be called at any time and are not tied to
the tty input state machine that governs when @xref{Input Sequences} are
invoked.

@node The Canvas, The Comblock Interface, The Terminal, Top
@chapter The Canvas Widget
@cindex termCanvas widget

The @code{TermCanvas widget} (referred to hereafter as the
@code{canvas}) is the portion of emu that provides the actual screen
output and keyboard handling for emu.

The @code{canvas} manages a @code{virtual screen} (referred to hereafter
as the @code{screen}) of a configurable size, plus an area where text
which scrolls off the top of the screen is stored (the @code{save area}).

The @code{canvas} also supplies a text cursor (the @code{cursor}) of
configurable size and blink rate.

Text can be exchanged with other clients via the Toolkit's @code{Selection
Mechanism}.

@menu
* Canvas Resources::	        The resources provided by the @code{canvas}
* Canvas Actions::		Xt actions the @code{canvas} supports
* Canvas Communications Model:: How the @code{canvas} interfaces to the world
* Character Attributes::	Which character attributes may be used
* Color::			Color handling in the @code{canvas}
* Canvas Functions::		List of supported functions
@end menu

@node Canvas Resources, Canvas Actions, , The Canvas
@section Canvas Resources

The following X-Toolkit resources are provided by the @code{canvas}

@table @code
@item lines
@cindex lines
The height of the canvas in terminal lines. The default is 24.

@item columns
@cindex columns
The width of the canvas in terminal lines. The default is 80.

@item font
@cindex font
The font to use for normal text. The default is @code{XtDefaultFont}
(@code{fixed}).

@item boldFont
@cindex boldFont
The font to use for bold text. If not set, it will be automatically derived
from @code{font}.

@item dWideFont
@cindex dWideFont
(Only present if emu is compiled with double sized fonts enabled)
The font to use for double width, single height, normal text.
If not set, it will be automatically derived from @code{font}.

@item dWHighFont	     
@cindex dWHighFont	     
(Only present if emu is compiled with double sized fonts enabled)
The font to use for double width, double height, normal text.
If not set, it will be automatically derived from @code{font}.

@item dWideBFont	     
@cindex dWideBFont	     
(Only present if emu is compiled with double sized fonts enabled)
The font to use for double width, single height, bold text.
If not set, it will be automatically derived from @code{font}.

@item dWHighBFont	     
@cindex dWHighBFont	     
(Only present if emu is compiled with double sized fonts enabled)
The font to use for double width, double height bold text.
If not set, it will be automatically derived from @code{font}.

@item underlineWidth
@cindex underlineWidth
The thickness of the understrike line. The default is 1 pixel.

@item foreground
@cindex foreground
The text color. The default is @code{XtDefaultForeground} (@code{black}).

@item background
@cindex background
The window's background color. The default is @code{XtDefaultBackground}
(@code{white}).

@item cursorFg
@cindex cursorFg
The text cursor foreground color. The default is @code{XtDefaultForeground}.

@item cursorBg
@cindex cursorBg
The text cursor background color. The default is @code{XtDefaultBackground}.

@item cursorHeight
@cindex cursorHeight
The text cursor height in pixels. The maximum is the height of the font. 
To make the cursor as high as the cursor, specify 0. The default is 0.

@item cursorWidth
@cindex cursorWidth
The cursor width in pixels. The maximum is the width of the font. 
To make the cursor as wide as the cursor, specify 0. The default is 0.

@item cursorBlinking
@cindex cursorBlinking
A boolean flag to determine whether the cursor should blink. 
The default is @code{True}.

@item blinkInterval
@cindex blinkInterval
To specify how fast the cursor blinks, in milliseconds. 
The default is 500 msec.

@item blinkWOFocus
@cindex blinkWOFocus
A boolean flag to determine whether the cursor should continue blinking 
when the canvas looses the input focus. The default is @code{False}.

@item textBlinkInterval
@cindex textBlinkInterval
To specify how fast the blinking text blinks, in milliseconds. 
The default is 500 msec.

@item wrapAround
@cindex wrapAround
A boolean flag to determine whether text should wrap around the end of 
the line. The default is @code{True}.

@item insertMode
@cindex insertMode
A boolean flag to determine whether inserted Text should be inserted 
or overwrite the existing characters. The default is @code{False}.

@item bellVolume
@cindex bellVolume
The volume of the bell in %. The default is 100.

@item defTabWidth
@cindex defTabWidth
The default tabulator width to be used. The default is 8.

@item termType
@cindex termType
The terminal type under which the canvas looks up its resources.
There is no default.

@item setSize
@cindex setSize
A function to call when the canvas gets resized.
There is no default.

@item output
@cindex output
A function to call with output generated by the canvas (e.g. through
keystrokes in the canvas). There is no default.

@item notifyFirstMap
@cindex notifyFirstMap
A function to call when the canvas is mapped for the first time.
There is no default.

@item pointerShape
@cindex pointerShape
The font glyph of the cursor font to use for the mouse cursor
inside the canvas window. The default is @code{xterm}

@item saveLines
@cindex saveLines
The size of the @code{save area} in lines. The default is 64 or @code{lines},
whichever is larger.

@item multiClickTime
@cindex multiClickTime
The maximum time interval between two subsequent mouse clicks that should be 
treated as belonging to a multi click. The default is 300 msec.

@item jumpScrollLines
@cindex jumpScrollLines
The maximum number of lines that should be scrolled at a time if jump 
scrolling is enabled. The default is 10.

@end table

@node Canvas Actions, Canvas Communications Model, Canvas Resources, The Canvas
@section Canvas Actions
@comment  node-name,  next,  previous,  up

The @code{canvas} supports the following toolkit actions:

@table @code
@item focus-in()
@cindex focus-in
Should be called when the widget gets the input focus. 
The cursor shape changes to solid and optionally starts blinking.

@item focus-out()
@cindex focus-out
Should be called when the widget loses the input focus. 
The cursor shape changes to outline and optionally stops blinking.

@item key-input([<string>])
@cindex key-input
Called without an argument it translates the @kbd{KeySym} that caused the
action to a Latin-1 string. If @kbd{Mod1} is pressed with the Key, the highest
Bit of each character of the resulting string gets set to allow 
traditional recognition of the @kbd{Meta} key. The resulting string is 
sent to the @code{reverse parser}. With an argument @code{key-input} uses 
the given string instead.

@item select-start()
@cindex select-start
Starts the selection at the position of the mouse cursor.

@item select-extend()
@cindex select-extend
Extends the selection to the current mouse cursor position.

@item select-end()
@cindex select-end
Ends the selection and transforms the selection into a string for 
later retrieval.

@item insert-selection()
@cindex insert-selection
Retrieve the selection and send it to the @code{reverse parser}

@item call-parser(<opcode>, <buffer>, [<register>, <value>], ...)
@cindex call-parser
Calls the @code{reverse parser} with the specified opcode and buffer 
(use @code{""} if the buffer is not needed). 
If register/value pairs are provided it sets the registers accordingly.

@item call-canvas(<opcode>, <buffer>, [<register>, <value>], ...)
@cindex call-canvas
Executes the specified @code{opcode} in the canvas. The buffer and any
supplied registers are set accordingly.

@end table

@node Canvas Communications Model, Character Attributes, Canvas Actions, The Canvas
@section Canvas Communications Model
@cindex Canvas Communications Model
The @code{canvas} communicates with the outside world (that is to say,
the @code{term} widget (@xref{The Terminal})) using a mechanism
called a @code{comblock}.  The @code{comblock} provides a general
purpose communications buffer of sorts, containing space not only for
characters to be displayed (the @code{buffer}) but also a set of
registers for placing the parameters for various higher level requests
into.  See the @xref{Canvas Functions} section for more details on
which request types, and the registers they use, are supported (see also
@xref{The Comblock Interface}).

Any number of canvas instances can be created by an application, and it
is theoretically possible for a @code{term} Widget to multiplex
communications between multiple instances, all the necessary frame-work
is in place for such things though the default @code{emu} client assumes
only one canvas and always communicates with the first one created.

@node Character Attributes, Color, Canvas Communications Model, The Canvas
@section Character Attributes

The following character attributes are defined in @file{emu/include/xt_ops.h}
and can be @code{or}ed together in any combination to change the way
characters are displayed.

@table @code
@item ATT_NONE
@cindex ATT_NONE
normal text - using @code{screen.font}

@item ATT_BOLD
@cindex ATT_BOLD
bold text - using @code{screen.boldFont}

@item ATT_UNDERL
@cindex ATT_UNDERL
underlined - the underline width can be set via 
@code{screen.underlineWidth}

@item ATT_BLINK
@cindex ATT_BLINK
blinking - the blink rate can be set via @code{textBlinkInterval}

@item ATT_REVERSE
@cindex ATT_REVERSE
reverse text - the background and text colors are exchanged.

@end table

If the canvas is compiled with support for double sized fonts, the
following line attributes are available and can be used to change
the way whole lines are displayed. Only one of the attributes may
be specified at a time.

@table @code
@item LINE_D_NORMAL
@cindex LINE_D_NORMAL
normal text height and width

@item LINE_D_WIDE
@cindex LINE_D_WIDE
double wide text - all character cells are twice as wide as normal -
using @code{screen.DWideFont} or @code{screen.DWideBFont}.

@item LINE_D_UPPER
@cindex LINE_D_UPPER
double wide, double high text, upper half - all character cells are
twice as wide as normal - using @code{screen.DWHighFont} or 
@code{screen.DWHighBFont}. Characters will be drawn and clipped so
that the upper half of a double wide, double high font is visible.

@item LINE_D_LOWER
@cindex LINE_D_LOWER
double wide, double high text, lower half - all character cells are
twice as wide as normal - using @code{screen.DWHighFont} or 
@code{screen.DWHighBFont}. Characters will be drawn and clipped so
that the lower half of a double wide, double high font is visible.

@end table

@node Color, Canvas Functions, Character Attributes, The Canvas
@section Color Handling

To allow for text color attributes, the canvas supports one of 16
foreground and background colors for each character. The mapping between
logical character colors and actual X colors is done via a @code{color
index table (CIT)}, the entries in which can be set through the canvas
function @xref{OP_SET_CIT_CELL}.  The selection of logical foreground
and background colors on the canvas is done through the functions
@xref{OP_CHANGE_FG_COLOR} and @xref{OP_CHANGE_BG_COLOR}.

@node Canvas Functions, , Color, The Canvas
@section Canvas Functions

The following functions are recognized by the @code{canvas}, the
constants for which are defined in @file{emu/include/xt_ops.h}.  Data is
exchanged via the given @code{comblock} (@pxref{The Comblock Interface}).

@menu

Basic character insertion:
* OP_INSERT::			buffer = string to insert

Cursor movement:
* OP_MOVE_ABS::			x = column, y = line
* OP_MOVE_REL::			x = delta column, y = delta line
* OP_MOVE_ABS_COLUMN::		x = column
* OP_MOVE_ABS_ROW::		y = line
* OP_MOVE_REL_COLUMN::		x = delta column
* OP_MOVE_REL_ROW::		y = delta line
* OP_MOVE_REL_ROW_SCROLLED::	y = delta line

Write modes:
* OP_INSERT_MODE::		no args
* OP_OVERWRITE_MODE::		no args

Deleting and erasing:
* OP_DELETE_CHARS::		a = number of characters to delete
* OP_DELETE_TO_EOL::		no args
* OP_DELETE_LINES::		a = number of lines to delete
* OP_DELETE_TO_EOSCR::		no args
* OP_ERASE_CHARS::		a = number of characters to erase
* OP_ERASE_LINE_LEFT::		no args
* OP_ERASE_LINES::		a = number of lines to erase
* OP_ERASE_FROM_TOSCR::		no args
* OP_CLEAR_SCREEN::		no args

Inserting:
* OP_INSERT     		buffer = String to insert
* OP_INSERT_LINES::		a = number of lines to insert

Define the scrolling region:
* OP_SET_SCROLL_REGION::	a = start line, b = end line

Ring the bell:
* OP_RING_BELL::		no args

Tab handling:
* OP_HOR_TAB::			no args
* OP_SET_TAB_CUR_COL::		no args
* OP_SET_TAB_COL::		x = column
* OP_SET_TABS_EQ_WIDTH::	a = distance
* OP_CLEAR_TAB_CUR_COL::	no args
* OP_CLEAR_TAB_COL::		x = column
* OP_CLEAR_ALL_TABS::		no args

Character Attributes:
* OP_SET_ATTRIBUTE::		a = attribute(s)
* OP_CLEAR_ATTRIBUTE::		b = attribute(s)

Changing the Keyboard Translations e.g. for different Codes on the
Cursor Keys and Number Keys depending on the Keyboard mode:
* OP_OVERRIDE_TRANSLATIONS::	a = name of the translation

Change the FLUT e.g. for different character set:
* OP_CHANGE_FLUT::		a = name of the resource, b = offset to use

Reports from the canvas to the parser for further use in the parser.
They all have no arguments, the canvas however fills the comblock with data:
* OP_CANVAS_SIZE::		return x = columns, y = lines
* OP_CANVAS_CURSOR_POS::	return x = column, y = line
* OP_CANVAS_ATTRIBS::		return a = attributes
* OP_CANVAS_SCROLL_REGION::	return a = start line, b = end line
* OP_CANVAS_WRAP_MODE::		return a = boolean flag
* OP_CANVAS_REVERSE_MODE::	return a = boolean flag
* OP_CANVAS_CURSOR_ON::		return a = boolean flag
* OP_CANVAS_CURSOR_BLINKING::	return a = boolean flag
* OP_CANVAS_CURSOR_SIZE::	return x = width, y = height in pixels

Redraw the screen:
* OP_REDRAW_SCREEN::		no args

Change the current fonts:
* OP_CHANGE_FONTS::		a = normal font, b = bold font or empty string

Scrolling the screen and the saved area:
* OP_SCROLL_SCREEN_ABSOLUTE::	a = save line to scroll to
* OP_SCROLL_SCREEN_RELATIVE::	a = number of lines to scroll

General mode settings:
* OP_CURSOR_OFF::		no args
* OP_CURSOR_ON::		no args
* OP_SET_SCREEN_SIZE::		no args
* OP_WRAP_AROUND::		no args
* OP_DONT_WRAP::		no args
* OP_CURSOR_POS_REL_TO_SCR_REG:: no args
* OP_CURSOR_POS_ABSOLUTE::	no args
* OP_REVERSE_VIDEO::		no args
* OP_NORMAL_VIDEO::		no args
* OP_SAVE_FLUT::		no args
* OP_RESTORE_FLUT::		no args
* OP_SET_CURSOR_BLINK::		a = flag
* OP_SET_CURSOR_SIZE::		x = width, y = height in pixels

Color settings:
* OP_CHANGE_FG_COLOR::		a = number of the color to use
* OP_CHANGE_BG_COLOR::		b = number of the color to use
* OP_SET_CIT_CELL::		a = cell number, b = fg color, c = bg color
* OP_CANVAS_DISPLAY_CELLS::	return a = number of color cells

Control jump scrolling:
* OP_SET_JUMP_SCROLL::		a = number of lines to jump scroll
* OP_GET_JUMP_SCROLL::		return a = current setting of js lines

Setting line attibutes:
* OP_SET_LINE_ATTRIBUTES::	a = attribute

@end menu

@node OP_INSERT, OP_MOVE_ABS, ,Canvas Functions   
@comment  node-name,  next,  previous,  up
OP_INSERT		buffer = String to insert

The text in the @code{comblock}'s buffer is inserted at the current
cursor position with the current attributes.  If @code{insert mode} is
on, characters to the right, including the cursor position are shifted
to the right.  If @code{line-wrap} mode is on, characters beyond the
right border of the screen are wrapped to the next line.

@node OP_MOVE_ABS, OP_MOVE_REL, OP_INSERT, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_MOVE_ABS		x = column, y = line

Move the cursor to the absolute row and column position given in register
@kbd{x} and @kbd{y}. If the @code{relative-positioning} flag is set, the
start line of the scroll-region is added to y and the cursor is restricted
to the scroll region.  With the flag off the cursor is able to leave the
scroll region.

@node OP_MOVE_REL, OP_MOVE_ABS_COLUMN, OP_MOVE_ABS, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_MOVE_REL		x = delta column, y = delta line

Move the cursor relative to the current position by the amount of rows and 
columns given in register @kbd{x} and @kbd{y}. The cursor is restricted to
the scroll region.

@node OP_MOVE_ABS_COLUMN, OP_MOVE_ABS_ROW, OP_MOVE_REL, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_MOVE_ABS_COLUMN	x = column

Move the cursor to the absolute column given in register @kbd{x} on the
current line.
		
@node OP_MOVE_ABS_ROW, OP_MOVE_REL_COLUMN, OP_MOVE_ABS_COLUMN, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_MOVE_ABS_ROW		y = line

Move the cursor to the absolute row given in register @kbd{y} in the current
column. Rules for positioning relative to the scroll region and leaving the
region apply as in @code{OP_MOVE_ABS}.

@node OP_MOVE_REL_COLUMN, OP_MOVE_REL_ROW, OP_MOVE_ABS_ROW, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_MOVE_REL_COLUMN	x = delta column

Move the cursor relative to the current position in the current row. 
The delta is given in register @kbd{x}.

@node OP_MOVE_REL_ROW, OP_MOVE_REL_ROW_SCROLLED, OP_MOVE_REL_COLUMN, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_MOVE_REL_ROW		y = delta line

Move the cursor relative to the current position in the current column. 
The delta is given in register @kbd{y}. The cursor is restricted to the
scroll region.

@node OP_MOVE_REL_ROW_SCROLLED, OP_INSERT_MODE, OP_MOVE_REL_ROW, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_MOVE_REL_ROW_SCROLLED y = delta line

Move the cursor relative to the current postion in the current column.
The delta is given in register @kbd{y}. If the cursor would leave the scroll
region, the text inside the region is scrolled accordingly.

@node OP_INSERT_MODE, OP_OVERWRITE_MODE, OP_MOVE_REL_ROW_SCROLLED, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_INSERT_MODE		(no args)

Turn insert mode on.

@node OP_OVERWRITE_MODE, OP_DELETE_CHARS, OP_INSERT_MODE, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_OVERWRITE_MODE	(no args)

Turn overwrite mode on - insert mode off.

@node OP_DELETE_CHARS, OP_DELETE_TO_EOL, OP_OVERWRITE_MODE, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_DELETE_CHARS		a = number of characters to delete

Delete characters in the current line starting at the cursor position. 
The number of characters to be deleted is specified in register @kbd{a}. 
Characters to the right of the deleted ones are shifted to the left.

@node OP_DELETE_TO_EOL, OP_DELETE_LINES, OP_DELETE_CHARS, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_DELETE_TO_EOL	(no args)

Delete characters in the current line from the cursor position up to the 
end of the line.

@node OP_DELETE_LINES, OP_DELETE_TO_EOSCR, OP_DELETE_TO_EOL, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_DELETE_LINES		a = number of lines to delete

Deletes the number of lines specified in register @kbd{a}, and scrolls the
lines under the deleted area up. The cursor is set to the left border of
the screen. The deleted area starts at the current line. This action is
restricted to the scrolling region.

@node OP_DELETE_TO_EOSCR, OP_ERASE_CHARS, OP_DELETE_LINES, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_DELETE_TO_EOSCR	(no args)

Deletes all characters after the cursor till the end of the screen.

@node OP_ERASE_CHARS, OP_ERASE_LINE_LEFT, OP_DELETE_TO_EOSCR, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_ERASE_CHARS		a = number of characters to erase

Erase characters in the current line starting at the cursor position. 
The number of characters to be erased is specified in register @kbd{a}.

@node OP_ERASE_LINE_LEFT, OP_ERASE_LINES, OP_ERASE_CHARS, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_ERASE_LINE_LEFT	(no args)

Erases characters from the beginning of the current line to and including 
the cursor position.
		
@node OP_ERASE_LINES, OP_ERASE_FROM_TOSCR, OP_ERASE_LINE_LEFT, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_ERASE_LINES		a = number of lines to erase

Erases the number of lines specified in register @kbd{a}.

@node OP_ERASE_FROM_TOSCR, OP_CLEAR_SCREEN, OP_ERASE_LINES, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_ERASE_FROM_TOSCR	(no args)

Erases characters from the top of the screen up to and including the 
cursor position.

@node OP_CLEAR_SCREEN, OP_INSERT_LINES, OP_ERASE_FROM_TOSCR, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_CLEAR_SCREEN		(no args)

Clears the whole screen.

@node OP_INSERT_LINES, OP_SET_SCROLL_REGION, OP_CLEAR_SCREEN, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_INSERT_LINES		a = number of lines to insert

Inserts the number of lines specified in register @kbd{a} at the current
line. Existing lines are scrolled down accordingly. 
The cursor is set to the left border of the screen. This operation
is restricted to the scroll region.

@node OP_SET_SCROLL_REGION, OP_RING_BELL, OP_INSERT_LINES, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_SET_SCROLL_REGION	a = start line, b = end line

Sets the scoll region to start at the line specified in register @kbd{a},
and end at the line specified in register @kbd{b}.

@node OP_RING_BELL, OP_HOR_TAB, OP_SET_SCROLL_REGION, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_RING_BELL		(no args)

Calls 'XBell' with the volume specified in the resource bellVolume 
(default is 100%).

@node OP_HOR_TAB, OP_SET_TAB_CUR_COL, OP_RING_BELL, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_HOR_TAB		(no args)

Move the cursor to the next right tab in the current line. If there is
no tab to the right of the cursor, the cursor is set to the right border
of the screen.

@node OP_SET_TAB_CUR_COL, OP_SET_TAB_COL, OP_HOR_TAB, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_SET_TAB_CUR_COL	(no args)

Sets a tab stop at the current column.

@node OP_SET_TAB_COL, OP_SET_TABS_EQ_WIDTH, OP_SET_TAB_CUR_COL, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_SET_TAB_COL		x = column

Sets a tab stop at the column specified in register @kbd{x}.

@node OP_SET_TABS_EQ_WIDTH, OP_CLEAR_TAB_CUR_COL, OP_SET_TAB_COL, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_SET_TABS_EQ_WIDTH	a = distance

Sets up tabs with a distance specified in register @kbd{a}.

@node OP_CLEAR_TAB_CUR_COL, OP_CLEAR_TAB_COL, OP_SET_TABS_EQ_WIDTH, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_CLEAR_TAB_CUR_COL	(no args)

Clears a tab stop at the current column.

@node OP_CLEAR_TAB_COL, OP_CLEAR_ALL_TABS, OP_CLEAR_TAB_CUR_COL, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_CLEAR_TAB_COL	x = column

Clears a tab stop at the column specified in register @kbd{x}.

@node OP_CLEAR_ALL_TABS, OP_SET_ATTRIBUTE, OP_CLEAR_TAB_COL, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_CLEAR_ALL_TABS	(no args)

Clears all tabs.

@node OP_SET_ATTRIBUTE, OP_CLEAR_ATTRIBUTE, OP_CLEAR_ALL_TABS, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_SET_ATTRIBUTE	a = attribute(s)

Sets the attributes given in register @kbd{a} (more than one can be
@code{or}ed together).

@node OP_CLEAR_ATTRIBUTE, OP_OVERRIDE_TRANSLATIONS, OP_SET_ATTRIBUTE, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_CLEAR_ATTRIBUTE	b = attribute(s)

Clears the attributes given in register @kbd{b} (more than one can be
@code{or}ed together).

@node OP_OVERRIDE_TRANSLATIONS, OP_CHANGE_FLUT, OP_CLEAR_ATTRIBUTE, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_OVERRIDE_TRANSLATIONS	a = name of the translation

Retrieves the resource @code{<term-type>-auxTrans-<name>} and overrides the 
current translations with the resource. <name> is given in register @kbd{a}.

@node OP_CHANGE_FLUT, OP_CANVAS_SIZE, OP_OVERRIDE_TRANSLATIONS, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_CHANGE_FLUT	a = name of the resource, b = offset to use

Retrieves the resource @code{<term-type>-flut-<name>} and changes the flut 
according to the info found there. <name> is given in register @kbd{a},
register @kbd{b} specifies the integer offset in the flut to use.	

@node OP_CANVAS_SIZE, OP_CANVAS_CURSOR_POS, OP_CHANGE_FLUT, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_CANVAS_SIZE		(return) x = columns, (return) y = lines

The canvas returns its size in registers @kbd{x} and @kbd{y}.

@node OP_CANVAS_CURSOR_POS, OP_CANVAS_ATTRIBS, OP_CANVAS_SIZE, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_CANVAS_CURSOR_POS	(return) x = column, (return) y = line

The canvas returns the current cursor position in registers @kbd{x}
and @kbd{y}.

@node OP_CANVAS_ATTRIBS, OP_CANVAS_SCROLL_REGION, OP_CANVAS_CURSOR_POS, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_CANVAS_ATTRIBS	(return) a = attributes

The canvas returns the current attribues in register @kbd{a} (all @code{or}ed
together).

@node OP_CANVAS_SCROLL_REGION, OP_CANVAS_WRAP_MODE, OP_CANVAS_ATTRIBS, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_CANVAS_SCROLL_REGION	return a = start line, b = end line

Return start and end line of the scroll region in registers @kbd{a}
and @kbd{b}.

@node OP_CANVAS_WRAP_MODE, OP_CANVAS_REVERSE_MODE, OP_CANVAS_SCROLL_REGION, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_CANVAS_WRAP_MODE	return a = boolean flag

Report in register @kbd{a} whether line wrap mode is on.

@node OP_CANVAS_REVERSE_MODE, OP_CANVAS_CURSOR_ON, OP_CANVAS_WRAP_MODE, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_CANVAS_REVERSE_MODE	return a = boolean flag

Report in register @kbd{a} whether the canvas screen is in reverse video.

@node OP_CANVAS_CURSOR_ON, OP_CANVAS_CURSOR_BLINKING, OP_CANVAS_REVERSE_MODE, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_CANVAS_CURSOR_ON	return a = boolean flag

Report in register @kbd{a} whether the cursor is visible.

@node OP_CANVAS_CURSOR_BLINKING, OP_CANVAS_CURSOR_SIZE, OP_CANVAS_CURSOR_ON, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_CANVAS_CURSOR_BLINKING return a = boolean flag

Report in register @kbd{a} whether the cursor is blinking.

@node OP_CANVAS_CURSOR_SIZE, OP_REDRAW_SCREEN, OP_CANVAS_CURSOR_BLINKING, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_CANVAS_CURSOR_SIZE	return x = width, y = height in pixels

Return the current cursor size in registers @kbd{x} and @kbd{y}.

@node OP_REDRAW_SCREEN, OP_CHANGE_FONTS, OP_CANVAS_CURSOR_SIZE, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_REDRAW_SCREEN	no args

Clears and redraws the entire screen.

@node OP_CHANGE_FONTS, OP_SCROLL_SCREEN_ABSOLUTE, OP_REDRAW_SCREEN, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_CHANGE_FONTS		a = normal font, b = bold font or empty string

Changes the current fonts to the names given in registers @kbd{a} (normal
font), and @kbd{b} (bold font). The fonts only get installed when they are
both of the same size. If the bold font is an empty string, the canvas
tries to derive a bold font from the normal one. If double sized font
support is compiled into the canvas, it automatically generates names
for the double sized fonts as well.

If an empty string is passed for the normal font, the canvas uses the 
initial one (e.g. specified in the resource database).

@node OP_SCROLL_SCREEN_ABSOLUTE, OP_SCROLL_SCREEN_RELATIVE, OP_CHANGE_FONTS, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_SCROLL_SCREEN_ABSOLUTE a = save line to scroll to

Viewing the save area and the actual screen as continuous lines with line 0
being the beginning of the actual screen, numbering the save area negative
upwards, this function places line -a at the top of the screen (0 thus re-
presenting the normal case with only the actual screen showing).

@node OP_SCROLL_SCREEN_RELATIVE, OP_CURSOR_OFF, OP_SCROLL_SCREEN_ABSOLUTE, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_SCROLL_SCREEN_RELATIVE a = number of lines to scroll

Scrolls save area and actual screen a lines down (negative a results in
scrolling upwards).

@node OP_CURSOR_OFF, OP_CURSOR_ON, OP_SCROLL_SCREEN_RELATIVE, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_CURSOR_OFF		(no args)

Switches cursor off.

@node OP_CURSOR_ON, OP_SET_SCREEN_SIZE, OP_CURSOR_OFF, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_CURSOR_ON		(no args)

Switches cursor on.

@node OP_SET_SCREEN_SIZE, OP_WRAP_AROUND, OP_CURSOR_ON, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_SET_SCREEN_SIZE	(no args)

Sets the screen size to the values given in registers @kbd{x} and @kbd{y}.

@node OP_WRAP_AROUND, OP_DONT_WRAP, OP_SET_SCREEN_SIZE, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_WRAP_AROUND		(no args)

Turns line wrap around on.

@node OP_DONT_WRAP, OP_CURSOR_POS_REL_TO_SCR_REG, OP_WRAP_AROUND, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_DONT_WRAP		(no args)

Turns line wrap around off.

@node OP_CURSOR_POS_REL_TO_SCR_REG, OP_CURSOR_POS_ABSOLUTE, OP_DONT_WRAP, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_CURSOR_POS_REL_TO_SCR_REG	(no args)

Makes cursor positioning relative to the scroll region.

@node OP_CURSOR_POS_ABSOLUTE, OP_REVERSE_VIDEO, OP_CURSOR_POS_REL_TO_SCR_REG, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_CURSOR_POS_ABSOLUTE	(no args)

Makes cursor positioning absolute.

@node OP_REVERSE_VIDEO, OP_NORMAL_VIDEO, OP_CURSOR_POS_ABSOLUTE, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_REVERSE_VIDEO	(no args)

Puts the canvas in reverse video.

@node OP_NORMAL_VIDEO, OP_SAVE_FLUT, OP_REVERSE_VIDEO, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_NORMAL_VIDEO	(no args)

Puts the canvas in normal video.

@node OP_SAVE_FLUT, OP_RESTORE_FLUT, OP_NORMAL_VIDEO, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_SAVE_FLUT		(no args)

Saves the current flut. Only one flut can be saved at a time, subsequent 
calls will overwrite the previous saved flut.

@node OP_RESTORE_FLUT, OP_SET_CURSOR_BLINK, OP_SAVE_FLUT, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_RESTORE_FLUT		(no args)

Restores flut to the last saved value.

@node OP_SET_CURSOR_BLINK, OP_SET_CURSOR_SIZE, OP_RESTORE_FLUT, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_SET_CURSOR_BLINK	a = boolean flag

Depending on the value in register @kbd{a}, cursor blinking gets turned on
or off.

@node OP_SET_CURSOR_SIZE, OP_CHANGE_FG_COLOR, OP_SET_CURSOR_BLINK, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_SET_CURSOR_SIZE	x = width, y = height in pixels

Sets the cursor size to the values in registers @kbd{x} and @kbd{y}.

@node OP_CHANGE_FG_COLOR, OP_CHANGE_BG_COLOR, OP_SET_CURSOR_SIZE, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_CHANGE_FG_COLOR	a = number of the color to use

Changes the foreground color in which text is being drawn to the one
specified in register @kbd{a}.

@node OP_CHANGE_BG_COLOR, OP_SET_CIT_CELL, OP_CHANGE_FG_COLOR, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_CHANGE_BG_COLOR	b = number of the color to use

Changes the background color with which text is being drawn to the one
specified in register @kbd{b}.

@node OP_SET_CIT_CELL, OP_CANVAS_DISPLAY_CELLS, OP_CHANGE_BG_COLOR, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_SET_CIT_CELL		a = cell number, b = fg color, c = bg color

Sets the fore- and background colors of the CIT cell specified in register 
@kbd{a} to the values specified in registers @kbd{b} and @kbd{c}.

@node OP_CANVAS_DISPLAY_CELLS, OP_SET_JUMP_SCROLL, OP_SET_CIT_CELL, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_CANVAS_DISPLAY_CELLS	return a = number of color cells

Returns the number of color cells that the screen on which the canvas
is running supports. This can be used to determine whether a emulation
should use color or not (B/W screen vs. color screen).

@node OP_SET_JUMP_SCROLL, OP_GET_JUMP_SCROLL, OP_CANVAS_DISPLAY_CELLS, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_SET_JUMP_SCROLL	a = number of lines to jump scroll

Sets the maximum number of lines the canvas should scroll at a time to
the value in register @kbd{a}.

@node OP_GET_JUMP_SCROLL, OP_SET_LINE_ATTRIBUTES, OP_SET_JUMP_SCROLL, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_GET_JUMP_SCROLL	return a = current setting of js lines

Returns the number of lines the canvas will maximally scroll at a time
in register @kbd{b}.

@node OP_SET_LINE_ATTRIBUTES, , OP_GET_JUMP_SCROLL, Canvas Functions
@comment  node-name,  next,  previous,  up
OP_SET_LINE_ATTRIBUTES	a = attribute

Sets the attributes of the current line to the one given in register 
@kbd{a}. Right now it is not allowed to set more than one attribute
at a time.

@node The Comblock Interface, Index, The Canvas, Top
@chapter The ComBlock Interface
@cindex Comblock Interface
@cindex The ComBlock
@cindex comblock

The various parts of @code{emu} use the @code{comblock} interface to
exchange information and as such it's important for at least the emu
programmer (or widget user) to understand something of how it works.

A comblock is a structure containing some buffer storage and a set of
@code{registers} in which operands for @code{canvas actions} are passed
(@pxref{Canvas Functions}).  Though the @code{comblock} should really
be regarded as an opaque structure and only manipulated through its
accessor functions and macros (see @file{include/common.h}), it helps for the
purpose of this document to describe its internals:

@example

typedef struct _comblock @{
     int opcode;			/* operation code */
     unsigned char buffer[BUF_SZ];	/* data buffer */
     int nbytes;			/* data buffer length */
     Register regs[CB_NREGS];		/* register array */
@} ComBlock, *ComBlockPtr;

@end example

Registers are defined as:

@example

typedef struct _reg @{
     int type;				/* data type */
     Generic data;			/* data ptr */
@} Register;

@end example

@samp{Register.type} tells what type of data (int, string, float, etc)
is contained in the register.

@samp{Register.data} is a pointer to the data, or the data itself if a
it can be contained in the storage provided by a pointer cell (usually
32 bits).

@samp{ComBlock.opcode} identifies a specific operation to be performed.

@samp{ComBlock.buffer} is used to transmit large amounts of data,
generally I/O between the @code{term} and @code{canvas} widgets.

@samp{ComBlock.nbytes} tells how many bytes are in the @samp{buffer}.

@samp{ComBlock.regs} contains a set of general purpose registers.

Each register can hold several types of data:

@enumerate
@item
@cindex CB_INT_TYPE
CB_INT_TYPE     - An integer.

@item
@cindex CB_STR_TYPE
CB_STR_TYPE     - A string.

@item
@cindex CB_CHAR_TYPE
CB_CHAR_TYPE    - An ASCII character.

@item
@cindex CB_ANY_TYPE
CB_ANY_TYPE     - Some generic data item (user defined).

@end enumerate

The comblock is allocated in the @code{term} widget and uses it to
transfer data between the @code{parser}, @code{reverse parser} and
@code{canvas} sections.  It is also used by the @code{parser} and
@code{reverse parser} for private storage.

The current policy is to use registers @samp{a} to @samp{d} and @samp{x}
to @samp{z} to pass arguments and return values.  Registers with lower
case letter or numberic names should only be used for private data of
the @code{parser}, upper case letters should only be used by the
@code{reverse parser}.  These conventions help to keep things straight.

Finally, when using the @code{comblock}, the following accessor
functions/macros should be used:

@table @code

@item reg_size
@findex reg_size
@cindex Register Size
This macro should be used when allocating space for registers or
when you otherwise need to know the `size' of a register.

@item reg_type(reg)
@findex reg_type
@cindex Register Type
This macro should be used to access the type field of a register.
The @code{reg} argument is a character denoting the register name.

@item reg_data(reg)
@findex reg_data
@cindex Register Data
This macro should be used to access the data field of a register.
The @code{reg} argument is a character denoting the register name.

@item cb_size
@findex cb_size
@cindex ComBlock Size
This macro should be used when allocating space for ComBlocks or
when you otherwise need to know the `size' of a ComBlock.

@item cb_opcode(cb)
@findex cb_opcode
@cindex ComBlock Operation Code
This macro should be used for accessing the ComBlock operation code
(also known as a `requested action').  The @code{cb} argument is the
ComBlock structure to be examined.

@item cb_buffer(cb)
@findex cb_buffer
@cindex ComBlock Buffer
This macro should be used for accessing the buffer area of the ComBlock.
The @code{cb} argument is the ComBlock structure to be examined.

@item cb_nbytes(cb)
@findex cb_nbytes
@cindex ComBlock Buffer Length
This macro should be used for accessing the buffer length field of the
ComBlock.  The @code{cb} argument is the ComBlock structure to be examined.

@item cb_regs(cb)
@findex cb_regs
@cindex ComBlock Registers
This macro should be used for accessing the register array area of the
ComBlock (as one chunk).  The @code{cb} argument is the ComBlock structure
to be examined.

@item cb_reg(cb, reg)
@findex cb_reg
@cindex ComBlock Register
This macro should be used for accessing an individual register in the
ComBlock (though see the following 2 calls first).  The @code{cb} argument
is the ComBlock structure to be examined and the @code{reg} argument is the
register name.

@item cb_reg_type(cb, reg)
@findex cb_reg_type
@cindex ComBlock Register Type
This macro should be used for accessing the type field of an individual
register in the ComBlock.  This is a short-hand combination of
@code{cb_reg} and @code{reg_type}.  The @code{cb} argument is the
ComBlock structure to be examined and the @code{reg} argument is the
register name.

@item cb_reg_data(cb, reg)
@findex cb_reg_data
@cindex ComBlock Register Data
This macro should be used for accessing the data field of an individual
register in the ComBlock.  This is a short-hand combination of
@code{cb_reg} and @code{reg_type}.  The @code{cb} argument is the
ComBlock structure to be examined and the @code{reg} argument is the
register name.

@end table


@node Index, References, The Comblock Interface, Top
@unnumbered Index

@printindex cp
@printindex fn
@contents

@node References, , Index, Top
@chapter References

[1] McCormack, Joel. Asente, Paul and Swick, Ralph R. @i{X Toolkit Intrinsics
- C Language Interface} Massachusetts Institute of Technology, 1985, 1986,
1987, 1988

[2] Swick, Ralph R. and Weissman, Terry. @i{X Toolkit Athena Widgets - C
Language Interface}  Massachusetts Institute of Technology, 1985, 1986, 1987,
 1988

@bye

