\begindata{text,538492872}
\textdsversion{12}
\template{be2guide}
\define{global
}
\define{underline
menu:[Font~1,Underline~41]
attr:[Flags Underline Int Set]}
\define{index
menu:[Title,Index~91]
attr:[FontFace Italic Int Set]}
\define{indexi
menu:[Title,InvisibleIndex~92]
attr:[Script PreviousScriptMovement Point -2]
attr:[Flags Hidden Int Set]
attr:[FontFace Italic Int Set]}
\define{itemize
}
\define{fixedtext
menu:[Region~4,Fixedtext]
attr:[Justification LeftJustified Point 0]
attr:[FontFace FixedFace Int Set]
attr:[FontFamily AndyType Int 0]
attr:[FontSize ConstantFontSize Point 10]}
\define{fixedindent
menu:[Region~4,Fixedindent]
attr:[LeftMargin LeftMargin Cm 83230]
attr:[Justification LeftJustified Point 0]
attr:[FontFace FixedFace Int Set]
attr:[FontFamily AndyType Int 0]
attr:[FontSize ConstantFontSize Point 10]}
\define{paramname
menu:[Font~1,Paramname]
attr:[FontFace Italic Int Set]}
\formatnote{\chapter{Style}}\indexi{Style}


A \italic{style} is a collection of attributes which can be applied to a 
region of data.  These attributes provide information about the layout and 
appearance of data to which the style is applied. 



\section{Quick reference list for Style}


\fixedtext{void \bold{style_}AddAttribute }\fixedindent{(struct style 
*\paramname{style}, char *\paramname{name}, char *\paramname{value});} 

\fixedtext{\bold{style_}AddChangeBar }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}AddContinueIndent }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{void \bold{style_}AddCounterStyle }\fixedindent{(struct style 
*\paramname{style}, char *\paramname{NewStyle});} 

\fixedtext{\bold{style_}AddFlag }\fixedindent{(struct style 
*\paramname{style}, \paramname{flag});} 

\fixedtext{\bold{style_}AddHidden }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}AddHinge }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}AddNewFontFace }\fixedindent{(struct style 
*\paramname{style}, \paramname{newface});} 

\fixedtext{\bold{style_}AddNewPage }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}AddNoWrap }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}AddOverBar }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}AddPassThru }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}AddReadOnly }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{void \bold{style_}AddTabChange }\fixedindent{(struct style 
*\paramname{style}, enum style_TabAlignment \paramname{TabOp}, long 
\paramname{Where}, enum style_Unit \paramname{Unit});} 

\fixedtext{\bold{style_}AddUnderline }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{void \bold{style_}ClearCounterStyles }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}ClearNewFontFaces }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}ClearOldFontFaces }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{void \bold{style_}ClearTabChanges }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{void \bold{style_}Copy }\fixedindent{(struct style 
*\paramname{style}, struct style *\paramname{dest});} 

\fixedtext{void \bold{style_}FinalizeObject }\fixedindent{(struct style 
*\paramname{self});} 

\fixedtext{\bold{style_}GetAddedFontFaces }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{char *\bold{style_}GetAttribute }\fixedindent{(struct style 
*\paramname{style}, char *\paramname{name});} 

\fixedtext{\bold{style_}GetCounterInitialValue }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{void \bold{style_}GetCounterName }\fixedindent{(struct style 
*\paramname{style}, char *\paramname{RetrievedCName});} 

\fixedtext{void \bold{style_}GetCounterParent }\fixedindent{(struct style 
*\paramname{style}, char *\paramname{RetrievedParent});} 

\fixedtext{\bold{style_}GetCounterPosition }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}GetCounterScope }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{void \bold{style_}GetCounterStyles }\fixedindent{(struct style 
*\paramname{style}, long *\paramname{RefNumStyles}, char 
***\paramname{RefStyleStrings});} 

\fixedtext{void \bold{style_}GetFontFamily }\fixedindent{(struct style 
*\paramname{style}, char *\paramname{FontName}, int \paramname{bufsize});} 

\fixedtext{void \bold{style_}GetFontScript }\fixedindent{(struct style 
*\paramname{style}, enum style_ScriptMovement *\paramname{RefBasis}, long 
*\paramname{RefOperand}, enum style_Unit *\paramname{RefUnit});} 

\fixedtext{void \bold{style_}GetFontSize }\fixedindent{(struct style 
*\paramname{style}, enum style_FontSize *\paramname{RefBasis}, long 
*\paramname{RefOperand});} 

\fixedtext{\bold{style_}GetJustification }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{char *\bold{style_}GetMenuName }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{char *\bold{style_}GetName }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{void \bold{style_}GetNewAbove }\fixedindent{(struct style 
*\paramname{style}, enum style_SpacingValue *\paramname{RefBasis}, long 
*\paramname{RefOperand}, enum style_Unit *\paramname{RefUnit});} 

\fixedtext{void \bold{style_}GetNewBelow }\fixedindent{(struct style 
*\paramname{style}, enum style_SpacingValue *\paramname{RefBasis}, long 
*\paramname{RefOperand}, enum style_Unit *\paramname{RefUnit});} 

\fixedtext{void \bold{style_}GetNewBottomMargin }\fixedindent{(struct style 
*\paramname{style}, enum style_MarginValue *\paramname{RefBasis}, long 
*\paramname{RefOperand}, enum style_Unit *\paramname{RefUnit});} 

\fixedtext{void \bold{style_}GetNewIndentation }\fixedindent{(struct style 
*\paramname{style}, enum style_MarginValue *\paramname{RefBasis}, long 
*\paramname{RefOperand}, enum style_Unit *\paramname{RefUnit});} 

\fixedtext{void \bold{style_}GetNewInterlineSpacing }\fixedindent{(struct 
style *\paramname{style}, enum style_SpacingValue *\paramname{RefBasis}, long 
*\paramname{RefOperand}, enum style_Unit *\paramname{RefUnit});} 

\fixedtext{void \bold{style_}GetNewInterparagraphSpacing }\fixedindent{(struct 
style *\paramname{style}, enum style_SpacingValue *\paramname{RefBasis}, long 
*\paramname{RefOperand}, enum style_Unit *\paramname{RefUnit});} 

\fixedtext{void \bold{style_}GetNewLeftMargin }\fixedindent{(struct style 
*\paramname{style}, enum style_MarginValue *\paramname{RefBasis}, long 
*\paramname{RefOperand}, enum style_Unit *\paramname{RefUnit});} 

\fixedtext{void \bold{style_}GetNewRightMargin }\fixedindent{(struct style 
*\paramname{style}, enum style_MarginValue *\paramname{RefBasis}, long 
*\paramname{RefOperand}, enum style_Unit *\paramname{RefUnit});} 

\fixedtext{void \bold{style_}GetNewTopMargin }\fixedindent{(struct style 
*\paramname{style}, enum style_MarginValue *\paramname{RefBasis}, long 
*\paramname{RefOperand}, enum style_Unit *\paramname{RefUnit});} 

\fixedtext{\bold{style_}GetRemovedFontFaces }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{void \bold{style_}GetTabChangeList }\fixedindent{(struct style 
*\paramname{style}, long *\paramname{RefNumTabChanges}, struct tabentry 
**\paramname{RefTabChanges});} 

\fixedtext{boolean \bold{style_}InitializeObject }\fixedindent{(struct style 
*\paramname{self});} 

\fixedtext{\bold{style_}IsAllAddedFontFace }\fixedindent{(struct style 
*\paramname{style}, \paramname{testface});} 

\fixedtext{\bold{style_}IsAllRemovedFontFace }\fixedindent{(struct style 
*\paramname{style}, \paramname{testface});} 

\fixedtext{\bold{style_}IsAnyAddedFontFace }\fixedindent{(struct style 
*\paramname{style}, \paramname{testface});} 

\fixedtext{\bold{style_}IsAnyRemovedFontFace }\fixedindent{(struct style 
*\paramname{style}, \paramname{testface});} 

\fixedtext{boolean \bold{style_}IsAttribute }\fixedindent{(struct style 
*\paramname{style}, char *\paramname{name});} 

\fixedtext{\bold{style_}IsChangeBarAdded }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsChangeBarRemoved }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsChangeBarUnchange }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsContinueIndentAdded }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsContinueIndentRemoved }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsContinueIndentUnchange }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsHiddenAdded }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsHiddenRemoved }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsHiddenUnchange }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsHingeAdded }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsHingeRemoved }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsHingeUnchange }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsNewPageAdded }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsNewPageRemoved }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsNewPageUnchange }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsNoWrapAdded }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsNoWrapRemoved }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsNoWrapUnchange }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsOverBarAdded }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsOverBarRemoved }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsOverBarUnchange }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsPassThruAdded }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsPassThruRemoved }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsPassThruUnchange }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsReadOnlyAdded }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsReadOnlyRemoved }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsReadOnlyUnchange }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsUnderlineAdded }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsUnderlineRemoved }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}IsUnderlineUnchange }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{long \bold{style_}ReadAttr }\fixedindent{(struct style 
*\paramname{style}, FILE *\paramname{fp});} 

\fixedtext{long \bold{style_}ReadMenu }\fixedindent{(struct style 
*\paramname{style}, FILE *\paramname{fp});} 

\fixedtext{long \bold{style_}Read }\fixedindent{(struct style 
*\paramname{style}, FILE *\paramname{fp});} 

\fixedtext{void \bold{style_}RemoveAttribute }\fixedindent{(struct style 
*\paramname{style}, char *\paramname{name});} 

\fixedtext{\bold{style_}RemoveChangeBar }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}RemoveContinueIndent }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}RemoveFlag }\fixedindent{(struct style 
*\paramname{style}, \paramname{flag});} 

\fixedtext{\bold{style_}RemoveHidden }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}RemoveHinge }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}RemoveNewPage }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}RemoveNoWrap }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}RemoveOldFontFace }\fixedindent{(struct style 
*\paramname{style}, \paramname{oldface});} 

\fixedtext{\bold{style_}RemoveOverBar }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}RemovePassThru }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}RemoveReadOnly }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}RemoveUnderline }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{void \bold{style_}Reset }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}SetCounterInitialValue }\fixedindent{(struct style 
*\paramname{style}, \paramname{newval});} 

\fixedtext{void \bold{style_}SetCounterName }\fixedindent{(struct style 
*\paramname{style}, char *\paramname{NewCName});} 

\fixedtext{void \bold{style_}SetCounterParent }\fixedindent{(struct style 
*\paramname{style}, char *\paramname{NewParent});} 

\fixedtext{\bold{style_}SetCounterPosition }\fixedindent{(struct style 
*\paramname{style}, \paramname{newpos});} 

\fixedtext{\bold{style_}SetCounterScope }\fixedindent{(struct style 
*\paramname{style}, \paramname{newscope});} 

\fixedtext{void \bold{style_}SetFontFamily }\fixedindent{(struct style 
*\paramname{style}, char *\paramname{NewFont});} 

\fixedtext{void \bold{style_}SetFontScript }\fixedindent{(struct style 
*\paramname{style}, enum style_ScriptMovement \paramname{Basis}, long 
\paramname{Operand}, enum style_Unit \paramname{Unit});} 

\fixedtext{void \bold{style_}SetFontSize }\fixedindent{(struct style 
*\paramname{style}, enum style_FontSize \paramname{Basis}, long 
\paramname{Operand});} 

\fixedtext{\bold{style_}SetJustification }\fixedindent{(struct style 
*\paramname{style}, \paramname{just});} 

\fixedtext{void \bold{style_}SetMenuName }\fixedindent{(struct style 
*\paramname{style}, char *\paramname{name});} 

\fixedtext{void \bold{style_}SetName }\fixedindent{(struct style 
*\paramname{style}, char *\paramname{name});} 

\fixedtext{void \bold{style_}SetNewAbove }\fixedindent{(struct style 
*\paramname{style}, enum style_SpacingValue \paramname{Basis}, long 
\paramname{Operand}, enum style_Unit \paramname{Unit});} 

\fixedtext{void \bold{style_}SetNewBelow }\fixedindent{(struct style 
*\paramname{style}, enum style_SpacingValue \paramname{Basis}, long 
\paramname{Operand}, enum style_Unit \paramname{Unit});} 

\fixedtext{void \bold{style_}SetNewBottomMargin }\fixedindent{(struct style 
*\paramname{style}, enum style_MarginValue \paramname{Basis}, long 
\paramname{Operand}, enum style_Unit \paramname{Unit});} 

\fixedtext{void \bold{style_}SetNewIndentation }\fixedindent{(struct style 
*\paramname{style}, enum style_MarginValue \paramname{Basis}, long 
\paramname{Operand}, enum style_Unit \paramname{Unit});} 

\fixedtext{void \bold{style_}SetNewInterlineSpacing }\fixedindent{(struct 
style *\paramname{style}, enum style_SpacingValue \paramname{Basis}, long 
\paramname{Operand}, enum style_Unit \paramname{Unit});} 

\fixedtext{void \bold{style_}SetNewInterparagraphSpacing }\fixedindent{(struct 
style *\paramname{style}, enum style_SpacingValue \paramname{Basis}, long 
\paramname{Operand}, enum style_Unit \paramname{Unit});} 

\fixedtext{void \bold{style_}SetNewLeftMargin }\fixedindent{(struct style 
*\paramname{style}, enum style_MarginValue \paramname{Basis}, long 
\paramname{Operand}, enum style_Unit \paramname{Unit});} 

\fixedtext{void \bold{style_}SetNewRightMargin }\fixedindent{(struct style 
*\paramname{style}, enum style_MarginValue \paramname{Basis}, long 
\paramname{Operand}, enum style_Unit \paramname{Unit});} 

\fixedtext{void \bold{style_}SetNewTopMargin }\fixedindent{(struct style 
*\paramname{style}, enum style_MarginValue \paramname{Basis}, long 
\paramname{Operand}, enum style_Unit \paramname{Unit});} 

\fixedtext{\bold{style_}TestAddFlag }\fixedindent{(struct style 
*\paramname{style}, \paramname{flag});} 

\fixedtext{\bold{style_}TestRemoveFlag }\fixedindent{(struct style 
*\paramname{style}, \paramname{flag});} 

\fixedtext{\bold{style_}TestUseOldFlag }\fixedindent{(struct style 
*\paramname{style}, \paramname{flag});} 

\fixedtext{\bold{style_}UseOldChangeBar }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}UseOldContinueIndent }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}UseOldFlag }\fixedindent{(struct style 
*\paramname{style}, \paramname{flag});} 

\fixedtext{\bold{style_}UseOldHidden }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}UseOldHinge }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}UseOldNewPage }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}UseOldNoWrap }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}UseOldOverBar }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}UseOldPassThru }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}UseOldReadOnly }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{\bold{style_}UseOldUnderline }\fixedindent{(struct style 
*\paramname{style});} 

\fixedtext{void \bold{style_}WriteAttr }\fixedindent{(struct style 
*\paramname{style}, FILE *\paramname{fp});} 

\fixedtext{void \bold{style_}WriteMenu }\fixedindent{(struct style 
*\paramname{style}, FILE *\paramname{fp});} 

\fixedtext{void \bold{style_}Write }\fixedindent{(struct style 
*\paramname{style}, FILE *\paramname{fp});} 



\section{Overview of styles

}
\subsection{External data representation}\indexi{Style++Datastream}


The basic paradigm for the templates, stylesheets, and styles is that each of 
them contain a list of their subordinates (e.g. a stylesheet contains a list 
of styles), and most of the methods deal with adding to, deleting from or 
finding subordinates within that list. 


The external data representation is entirely in ascii, and is expected to be 
used both for storing objects in files and for cut and paste operations.  A 
stylesheet can contain zero or more styles. Text documents which contain no 
style information or other objects are treated as uninterpreted files and 
stored in a straightforward manner.  Text documents which do contain these 
extra dimensions are written with a special syntax.  The general syntax of 
these interpreted files follows the protocols defined in the documentation for 
stylesheet. 


The actual datastream format for a style might look like this: 


\programexample{
\\define\{comment

attr:[FontFace Italic Int Set]

attr:[FontFace FixedFace Int Clear]

attr:[FontSize PreviousFontSize Point 2]

attr:[FontFamily Andy Int 0]\}

}

\subsection{Global vs. default styles}\indexi{Style++Global and default}


There are two ways of defining the appearance of normal (unstyled) text for a 
particular application.  One way is through the global style, and the other is 
through the default style. 


The global style is associated with the text object.  This style is attached 
to the root environment of the 2-3 tree.  Usually, this style would be under 
control of the application program and it defines the basic attributes for all 
text (i.e. it is global to the document).  The global style enables the 
definition of application specific attributes (e.g. using a fixed with font 
and left justification (no fill) in ctext). 


The default style is associated with the textview.  This style is attached to 
the textview object.  Usually, this style is defined by the user through the 
preferences file.  The default style enables the definition of user specific 
attributes (e.g. bodyfont (fontfamily and fontsize) in typescript). 

\begindata{bp,538928264}
\enddata{bp,538928264}
\view{bpv,538928264,428,0,0}
\subsection{General Example}\indexi{Style++Creating}


Here is a general example of creating a style, taken from an InitializeObject 
procedure: 


\example{
struct stylesheet *ssptr;

struct style *styleptr;


if ((styleptr = stylesheet_Find(ssptr, "bold")) == NULL) \{

	styleptr = style_New();

	style_SetName(styleptr, "bold");

	style_SetMenuName(styleptr, "Font~1,Bold~10");

	stylesheet_Add(ssptr, styleptr);

\}

style_AddNewFontFace(styleptr, fontdesc_Bold);} 



Note:  It is not necessary to add the style to a stylesheet, programs may 
create and use styles independently of the stylesheet. 


\subsection{The style structure}\indexi{Style++Structure}


The style structure consists of the following: 


\formatnote{
\formatnote{\smaller{char *name}}\formatnote{  --  }the actual name of the

style,  e.g. "italic".


\formatnote{\smaller{char *menuName}}\formatnote{  --  }the name to be used

for menu, e.g. "Font~1,Italic~11".


\formatnote{\smaller{short template}}\formatnote{  --  }a boolean, true if 
this

style came from the current template.


\formatnote{\smaller{struct marginstyle NewLeftMargin}} \formatnote{ --  }the 
left margin attribute.


\formatnote{\smaller{struct marginstyle NewRightMargin}}\formatnote{  --  }the 
right margin attribute.


\formatnote{\smaller{struct marginstyle NewTopMargin}} \formatnote{ --  }the 
top margin attribute.


\formatnote{\smaller{struct marginstyle NewBottomMargin}}\formatnote{  -- 
 }the bottom margin attribute.


\formatnote{\smaller{struct marginstyle NewIndentation}}\formatnote{  --  }the 
indentation attribute.


\formatnote{\smaller{struct spacingstyle 
NewInterparagraphSpacing}}\formatnote{  --  }the spread attribute.


\formatnote{\smaller{struct spacingstyle NewAbove}}\formatnote{  --  }the 
above attribute.


\formatnote{\smaller{struct spacingstyle NewBelow}}\formatnote{  --  }the 
below attribute.


\formatnote{\smaller{struct spacingstyle NewInterlineSpacing}}\formatnote{  -- 
 }the spacing attribute.


\formatnote{\smaller{char *FontFamily}}\formatnote{ --  }the font family 
attribute.


\formatnote{\smaller{struct fontsizestyle FontSize}}\formatnote{  --  }the 
font size attribute.


\formatnote{\smaller{struct fontscriptstyle FontScript}}\formatnote{  --  }the 
script attribute.


\formatnote{\smaller{long AddFontFaces}}\formatnote{  --  }the added font 
faces or'ed together.


\formatnote{\smaller{long OutFontFaces}} \formatnote{ --  }the removed font 
faces or'ed together.


\formatnote{\smaller{enum style_Justification NewJustification}}\formatnote{ 
 --  }the justification attribute.


\formatnote{\smaller{long NumTabChanges}}\formatnote{  --  }the number of 
tabs.


\formatnote{\smaller{struct tabentry *TabChangeList}}\formatnote{  --  }a 
pointer to the array of tabs.


\formatnote{\smaller{long AddMiscFlags}}\formatnote{  --  }the or'ed value of 
the flags added.


\formatnote{\smaller{long OutMiscFlags}}\formatnote{  --  }the or'ed value of 
the flags removed.


\formatnote{\smaller{struct namespace *AdditionalAttributes}}\formatnote{  -- 
 }lists attributes that are added on the fly.

}

\subsection{The operand parameter}\indexi{Style++Operand}


Some style methods require an operand value to be passed.  The following 
applies to the computation of the operand values: 


\itemize{
If the unit values are style_Inches or style_CM, then enter the number of 
inches or centimeters desired multiplied by 65536 and rounded off as the 
operand. 


If the unit values are style_Points or style_RawDot, then enter the actual 
number of pixels desired as the operand. 


The style_Ems and style_Lines unit values are currently unimplemented. 

}
\begindata{bp,538928136}
\enddata{bp,538928136}
\view{bpv,538928136,429,0,0}
\section{Creating styles}\indexi{Style++Creating}


\subsection{Creating a new style}


\paragraph{Creating an instance of a style}

\indexi{ \italic{style_New}} 

\example{struct style *style_New()

}
\leftindent{\bold{Class procedure description.} \italic{style_New} creates a 
new style by dynamically allocating memory for a style structure. 


\bold{Return value.}  A pointer to the newly created instance. 


\bold{Usage.}  This procedure would be called to create an empty style. 


\bold{Example.}\example{

 

struct style *HighlightStyle;

HighlightStyle = style_New();

}

creates the style, HighlightStyle. 

}

\paragraph{Copying a style}


\example{void style_Copy(style, dest)\indexi{Style++Copy}

struct style *style, *dest;}\indexi{ \italic{style_Copy}}


\leftindent{\bold{Method description.  } \italic{style_Copy} copies the 
information from an existing style into a new location. 


\bold{Return value.}  A pointer to the new style. 


\bold{Usage.}  This method would be used to make copies of styles when working 
with templates.  Templates are usually considered read-only, therefore any 
modifications to the styles would have to be local changes. 


\bold{Example.}\example{

 

struct style *TemplateHighlight, *HighlightStyle; 

HighlightStyle = style_New();

style_Copy(TemplateHighlight, HighlightStyle);

}
 

creates a new style, HighlightStyle, and copies information from the existing 
style, TemplateHighlight, into it. 

}
\begindata{bp,538928072}
\enddata{bp,538928072}
\view{bpv,538928072,430,0,0}
\subsection{Naming styles}\indexi{Style++Naming}


\paragraph{Setting a style name}


\example{void style_SetName(style, name)

struct style *style;

char *name;}\indexi{ \italic{style_SetName}}


\leftindent{\bold{Method description.  }  \italic{style_SetName} sets the name 
of a style. 


\bold{Usage.}  This method would be called to set the name that is used when 
referring to a style. 


\bold{Example.}\example{

 

struct style *HighlightStyle;

style_SetName(HighlightStyle, "highlight");

}
sets the name of the style, HighlightStyle, to "highlight". 

}


\paragraph{Getting a style name}


\example{char *style_GetName(style)

struct style *style;}\indexi{ \italic{style_GetName}}


\leftindent{\bold{Method description.  }  \italic{style_GetName} retrieves the 
name of a style. 


\bold{Return value.}  The name of the style. 


\bold{Usage.}  This method would be used when writing out the style definition 
or when writing a style reference in the body of the text. 


\bold{Example.}\example{

 

struct style *HighlightStyle;

char *stylename;

stylename = style_GetName(HighlightStyle);

}
returns the name, stylename, for the style, Highlight Style. 

}

\begindata{bp,538928008}
\enddata{bp,538928008}
\view{bpv,538928008,431,0,0}
\paragraph{Setting a menu name for a style}\indexi{Style++Menu name}


\example{void style_SetMenuName(style, menuName)

struct style *style;

char *menuName;}\indexi{ \italic{style_SetMenuName}}


\leftindent{\bold{Method description.  }  \italic{style_SetMenuName} sets the 
menu name for a style. 


\bold{Usage.}  This method would be called to set the name that is used on the 
menu for this style, if any. 


\bold{Example.}\example{

 

struct style *HighlightStyle;

style_SetMenuName(HighlightStyle, "Highlight~12");

}

sets the menu name of the style, HighlightStyle, to "Highlight" and sets its 
menu priority to 12 (See the documentation on menus for more information about 
setting priorities. 

}


\paragraph{Getting a menu name}


\example{char *style_GetMenuName(style)

struct style *style;}\indexi{ \italic{style_GetMenuName}}


\leftindent{\bold{Method description.  }  \italic{style_GetMenuName} retrieves 
the menu name of a style. 


\bold{Return value.}  The menu name of the style. 


\bold{Usage.}  This method would be used when writing out the style definition 
or when creating a menulist. 


\bold{Example.}\example{

  

struct style *HighlightStyle;

char *menuname;

menuname = style_GetMenuName(HighlightStyle);

}

returns the menu name, menuname, for the style, Highlight Style. 

}
\begindata{bp,538927944}
\enddata{bp,538927944}
\view{bpv,538927944,432,0,0}
\section{File I/O methods}


\subsection{Reading and writing styles}\indexi{Style++Reading and writing}


\paragraph{Reading a style}


\example{long style_Read(style, fileptr)

struct style *style;

FILE *fileptr;}\indexi{ \italic{style_Read}}


\leftindent{\bold{Method description.  }  \italic{style_Read} parses all of 
the components of the style definition. 


\bold{Return value.}  NULL is returned if successful.  -1 is returned if an 
error occurred. 


\bold{Example.}\example{


struct style *HighlightStyle;

FILE *myfile;


if (style_Read(HighlightStyle, myfile) < 0)

	fprintf(stderr, "Error occurred while reading file.\\n");

}

reads the components of the style definition and prints an error message if 
the read returned an error. 

 

}

\paragraph{Writing a style}


\example{void style_Write(style, fileptr)

struct style *style;

FILE *fileptr;}\indexi{ \italic{style_Write}}


\leftindent{\bold{Method description.  }  \italic{style_Write} writes a style. 





\bold{Example.}\example{


struct style *HighlightStyle;

FILE *myfile;


style_Write(HighlightStyles, myfile);

}

writes  the style, HighlightStyle, out to the file, myfile. 

}
\begindata{bp,538927880}
\enddata{bp,538927880}
\view{bpv,538927880,433,0,0}
\subsection{Reading and writing menu styles}


\paragraph{Reading a menu style}


\example{long style_ReadMenu(style, fileptr)

struct style *style;

FILE *fileptr;}\indexi{ \italic{style_ReadMenu}}


\leftindent{\bold{Method description.  }  \italic{style_ReadMenu} parses all 
of the components of the menu style definition. 


\bold{Return value.}  NULL is returned if successful.  -1 is returned if an 
error occurred. 


\bold{Example.}\example{


struct style *HighlightStyle;

FILE *myfile;


if (style_ReadMenu(HighlightStyle, myfile) < 0)

	fprintf(stderr, "Error occurred while reading file.\\n");

}

reads the components of the menu style definition and prints an error message 
if the read returned an error. 

 

}


\paragraph{Writing a menu style}


\example{void style_WriteMenu(style, fileptr)

struct style *style;

FILE *fileptr;}\indexi{ \italic{style_WriteMenu}}


\leftindent{\bold{Method description.  }  \italic{style_WriteMenu} writes a 
menu style. 


\bold{Example.}\example{


struct style *HighlightStyle;

FILE *myfile;


style_WriteMenu(HighlightStyles, myfile);

}

writes the menu style, HighlightStyle, out to the file, myfile. 

}
\begindata{bp,538927816}
\enddata{bp,538927816}
\view{bpv,538927816,434,0,0}
\subsection{Reading and writing style attributes}


\paragraph{Reading a style attribute}


\example{long style_ReadAttr(style, fileptr)

struct style *style;

FILE *fileptr;}\indexi{ \italic{style_WriteMenu}}


\leftindent{\bold{Method description.  }  \italic{style_ReadAttr} parses all 
of the components of the style attribute definition. 


\bold{Return value.}  NULL is returned if successful.  -1 is returned if an 
error occurred. 


\bold{Example.}\example{


struct style *HighlightStyle;

FILE *myfile;


if (style_ReadAttr(HighlightStyle, myfile) < 0)

	fprintf(stderr, "Error occurred while reading file.\\n");

}

reads the components of the style attribute definition and prints an error 
message if the read returned an error. 

 

}

\paragraph{Writing a style attribute}


\example{void style_WriteAttr(style, fileptr)

struct style *style;

FILE *fileptr;}\indexi{ \italic{style_WriteAttr}}


\leftindent{\bold{Method description.  }  \italic{style_WriteAttr} writes a 
style attribute. 


\bold{Example.}\example{


struct style *HighlightStyle;

FILE *myfile;


style_WriteAttr(HighlightStyles, myfile);

}

writes the style attributes for HighlightStyle out to the file, myfile. 

}
\begindata{bp,538927688}
\enddata{bp,538927688}
\view{bpv,538927688,435,0,0}
\section{Manipulating attributes of styles}

 

\subsection{Working with margins}\indexi{Style++Margins}


\paragraph{Setting a new left margin}


\example{void style_SetNewLeftMargin(style, Basis, Operand,Unit)

struct style *style;

enum style_MarginValue  Basis;

long Operand;

enum style_Unit Unit;}\indexi{ \italic{style_SetNewLeftMargin}}


\leftindent{\bold{Method description.  }  \italic{style_SetNewLeftMargin} sets 
a new left margin for a style. 


\bold{Usage.}  The basis value indicates the reference point from which 
measurement should begin (where style_ConstantMargin indicates an absolute 
value).  The operand value is the actual numeric specification.  The unit 
value indicates the unit used in specifying the operand. 


Possible basis values are:  style_ConstantMargin, style_LeftMargin, 
style_LeftEdge, style_RightMargin, style_RightEdge


Possible unit values are: style_Inches, style_CM, style_Points, style_Ems, 
style_Lines,style_RawDot. 

}

\paragraph{Getting a new left margin}


\example{void style_GetNewLeftMargin(style,RefBasis,RefOperand,

RefUnit)

struct style *style;

enum style_MarginValue *RefBasis;

long *RefOperand;

enum style_Unit *RefUnit; }\indexi{ \italic{style_GetNewLeftMargin}}


\leftindent{\bold{Method description.  }  \italic{style_GetNewLeftMargin} gets 
the new left margin for the style. 


\bold{Usage.}  This method is used for writing out the attribute specification 
for a style. 

}

\begindata{bp,538927752}
\enddata{bp,538927752}
\view{bpv,538927752,436,0,0}
\paragraph{Setting a new right margin}\indexi{Style++Margins}


\example{void style_SetNewRightMargin(style,Basis,Operand,Unit)

struct style *style;

enum style_MarginValue Basis;

long Operand;

enum style_Unit Unit;}\indexi{ \italic{style_SetNewRightMargin}}


\leftindent{\bold{Method description.  }  \italic{style_SetNewRightMargin} 
sets a new right margin for a style. 


\bold{Usage.}  The basis value indicates the reference point from which 
measurement should begin (where style_ConstantMargin indicates an absolute 
value).  The operand value is the actual numeric specification.  The unit 
value indicates the unit used in specifying the operand. 


Possible basis values are:  style_ConstantMargin, style_LeftMargin, 
style_LeftEdge,style_RightMargin, style_RightEdge


Possible unit values are:  style_Inches, style_CM, style_Points, style_Ems, 
style_Lines, style_RawDot

}

\paragraph{Getting the new right margin}


\example{void style_GetNewRightMargin(style,RefBasis,RefOperand,

RefUnit)

struct style *style;

enum style_MarginValue *RefBasis;

long *RefOperand;

enum style_Unit *RefUnit;}\indexi{ \italic{style_GetNewRightMargin}}


\leftindent{\bold{Method description.  }  \italic{style_GetNewRightMargin} 
gets the new right margin for the style. 


\bold{Usage.}  This method is used for writing out the attribute specification 
for a style.} 



\paragraph{Setting a new top margin}


\example{void style_SetNewTopMargin(style,Basis,Operand,Unit)

struct style *style;

enum style_MarginValue Basis;

long Operand;

enum style_Unit Unit;}\indexi{ \italic{style_SetNewTopMargin}}


\leftindent{\bold{Method description.  }  \italic{style_SetNewTopMargin} sets 
a new top margin for a style. 


\bold{Usage.}  The basis value indicates the reference point from which 
measurement should begin (where style_ConstantMargin indicates an absolute 
value).  The operand value is the actual numeric specification.  The unit 
value indicates the unit used in specifying the operand. 


Possible basis values are:  style_ConstantMargin, style_TopMargin, 
 style_TopEdge,style_BottomMargin, style_BottomEdge


Possible unit values are: style_Inches, style_CM, style_Points, style_Ems, 
style_Lines,style_RawDot


}
\begindata{bp,538928328}
\enddata{bp,538928328}
\view{bpv,538928328,437,0,0}
\paragraph{Getting the new top margin}\indexi{Style++Margins}


\example{void style_GetNewTopMargin(style,RefBasis,RefOperand,RefUnit)

struct style *style;

enum style_MarginValue *RefBasis;

long *RefOperand;

enum style_Unit *RefUnit;}\indexi{ \italic{style_GetNewTopMargin}}


\leftindent{\bold{Method description.  }  \italic{style_GetNewTopMargin} gets 
the new top margin for the style. 


\bold{Usage.}  This method is used for writing out the attribute specification 
for a style. 

}


\paragraph{Setting a new bottom margin}


\example{void style_SetNewBottomMargin(style,Basis,Operand,Unit)

struct style *style;

enum style_MarginValue Basis;

long Operand;

enum style_Unit Unit;}\indexi{ \italic{style_SetNewBottomMargin}}


\leftindent{\bold{Method description.  }  \italic{style_SetNewBottomMargin} 
sets a new bottom margin for a style. 


\bold{Usage.}  The basis value indicates the reference point from which 
measurement should begin (where style_ConstantMargin indicates an absolute 
value).  The operand value is the actual numeric specification.  The unit 
value indicates the unit used in specifying the operand. 


Possible basis values are:  style_ConstantMargin, style_TopMargin, 
 style_TopEdge, style_BottomMargin, style_BottomEdge. 


Possible unit values are:  style_Inches, style_CM, style_Points, style_Ems, 
style_Lines, style_RawDot. 

}

\paragraph{Getting a new bottom margin}


\example{void style_GetNewBottomMargin(style,RefBasis,RefOperand,

RefUnit)

struct style *style;

enum style_MarginValue *RefBasis;

long *RefOperand;

enum style_Unit *RefUnit;}\indexi{ \italic{style_GetNewBottomMargin}}


\leftindent{\bold{Method description.  }  \italic{style_GetNewBottomMargin} 
gets the new bottom margin for the style. 


\bold{Usage.}  This method is used for writing out the attribute specification 
for a style.} 

\begindata{bp,538928200}
\enddata{bp,538928200}
\view{bpv,538928200,438,0,0}
\subsection{Working with indentations and spacing}


\paragraph{Setting a new indentation}\indexi{Style++Indentation}


\example{void style_SetNewIndentation(style,Basis,Operand,Unit)

struct style *style;

enum style_MarginValue Basis;

long Operand;

enum style_Unit Unit;}\indexi{ \italic{style_SetNewIndentation}}


\leftindent{\bold{Method description.  }  \italic{style_SetNewIndentation} 
sets a new indentation for a style. 


\bold{Usage.}  The basis value indicates the reference point from which 
measurement should begin (where style_ConstantMargin indicates an absolute 
value).  The operand value is the actual numeric specification.  The unit 
value indicates the unit used in specifying the operand. 


Possible basis values are:  style_ConstantMargin, style_PreviousIndentation. 


Possible unit values are:  style_Inches, style_CM, style_Points, style_Ems, 
style_Lines, style_RawDot. 

}

\paragraph{Getting a new indentation}


\example{void style_GetNewIndentation(style,RefBasis,RefOperand,

RefUnit)

struct style *style;

enum style_MarginValue *RefBasis;

long *RefOperand;

enum style_Unit *RefUnit;}\indexi{ \italic{style_GetNewIndentation}}


\leftindent{\bold{Method description.  }  \italic{style_GetNewIndentation} 
gets the new indentation for the style. 


\bold{Usage.}  This method is used for writing out the attribute specification 
for a style. 

}

\paragraph{Setting a new spacing between paragraphs}\indexi{Style++Paragraph 
spacing}


\example{void style_SetNewInterparagraphSpacing(style,Basis,Operand,

Unit)

struct style *style;

enum style_SpacingValue Basis;

long Operand;

enum style_Unit Unit;}\indexi{ \italic{style_SetNewInterparagraphSpacing}}


\leftindent{\bold{Method description. 
 }  \italic{style_SetNewInterparagraphSpacing} sets a new inter-paragraph 
spacing. 


\bold{Usage.}  The basis value indicates the reference point from which 
measurement should begin (where style_ConstantSpacing indicates an absolute 
value).  The operand value is the actual numeric specification.  The unit 
value indicates the unit used in specifying the operand. 


Possible basis values are:  style_ConstantSpacing, 
style_InterparagraphSpacing. 


Possible unit values are:  style_Inches, style_CM, style_Points, style_Ems, 
style_Lines, style_RawDot. 

}

\paragraph{Getting a new interparagraph spacing}


\example{void style_GetNewInterparagraphSpacing(style,RefBasis,

RefOperand,RefUnit)

struct style *style;

enum style_SpacingValue *RefBasis;

long *RefOperand;

enum style_Unit *RefUnit; }\indexi{ \italic{style_GetNewInterparagraphSpacing}}


\leftindent{\bold{Method description. 
 }  \italic{style_GetNewInterparagraphSpacing} gets the new inter-paragraph 
spacing for the style. 


\bold{Usage.}  This method is used for writing out the attribute specification 
for a style. 

}

\paragraph{Setting a new above spacing}\indexi{Style++Line spacing}


\example{void style_SetNewAbove(style,Basis,Operand,Unit)

struct style *style;

enum style_SpacingValue Basis;

long Operand;

enum style_Unit Unit; }\indexi{ \italic{style_SetNewAbove}}


\leftindent{\bold{Method description.  }  \italic{style_SetNewAbove} sets a 
new above for a style. 


\bold{Usage.}  The basis value indicates the reference point from which 
measurement should begin (where style_ConstantSpacing indicates an absolute 
value).  The operand value is the actual numeric specification.  The unit 
value indicates the unit used in specifying the operand. 


Possible basis values are:  style_ConstantMargin, style_AboveSpacing. 


Possible unit values are:  style_Inches, style_CM, style_Points, style_Ems, 
style_Lines, style_RawDot. 

}

\paragraph{Getting a new above spacing}


\example{void style_GetNewAbove(style,RefBasis,RefOperand,RefUnit)

struct style *style;

enum style_SpacingValue *RefBasis;

long *RefOperand;

enum style_Unit *RefUnit;}\indexi{ \italic{style_GetNewAbove}}


\leftindent{\bold{Method description.  }  \italic{style_GetNewAbove} gets the 
new above for the style. 


\bold{Usage.}  This method is used for writing out the attribute specification 
for a style.} 


\paragraph{Setting a new below spacing}


\example{void style_SetNewBelow(style,Basis,Operand,Unit)

struct style *style;

enum style_SpacingValue Basis;

long Operand;

enum style_Unit Unit;}\indexi{ \italic{style_SetNewBelow}}


\leftindent{\bold{Method description.  }  \italic{style_SetNewBelow} sets a 
new below for a style. 


\bold{Usage.}  The basis value indicates the reference point from which 
measurement should begin (where style_ConstantSpacing indicates an absolute 
value).  The operand value is the actual numeric specification.  The unit 
value indicates the unit used in specifying the operand. 


Possible basis values are:  style_ConstantMargin, style_BelowSpacing. 


Possible unit values are:  style_Inches, style_CM, style_Points, style_Ems, 
style_Lines, style_RawDot. 

}

\paragraph{Getting a new below spacing}


\example{void style_GetNewBelow(style,RefBasis,RefOperand,RefUnit)

struct style *style;

enum style_SpacingValue *RefBasis;

long *RefOperand;

enum style_Unit *RefUnit;}\indexi{ \italic{style_GetNewBelow}}


\leftindent{\bold{Method description.  }  \italic{style_GetNewBelow} gets the 
new below for the style. 


\bold{Usage.}  This method is used for writing out the attribute specification 
for a style.} 



\paragraph{Setting a new inter-line spacing}\indexi{Style++Inter-line spacing}


\example{void style_SetNewInterlineSpacing(style,Basis,Operand,Unit)

struct style *style;

enum style_SpacingValue Basis;

long Operand;

enum style_Unit Unit;}\indexi{ \italic{style_SetNewInterlineSpacing}}


\leftindent{\bold{Method description.  }  \italic{style_SetNewInterlineSpacing} 
sets a new inter-line spacing for a style. 


\bold{Usage.}  The basis value indicates the reference point from which 
measurement should begin (where style_ConstantSpacing indicates an absolute 
value).  The operand value is the actual numeric specification.  The unit 
value indicates the unit used in specifying the operand. 


Possible basis values are:  style_ConstantMargin, style_InterlineSpacing. 


Possible unit values are:  style_Inches, style_CM, style_Points, style_Ems, 
style_Lines, style_RawDot. 

}

\paragraph{Getting new interline spacing}


\example{void style_GetNewInterlineSpacing(style,RefBasis,RefOperand,

RefUnit)

struct style *style;

enum style_SpacingValue *RefBasis;

long *RefOperand;

enum style_Unit *RefUnit;}\indexi{ \italic{style_GetNewInterlineSpacing}}


\leftindent{\bold{Method description.  }  \italic{style_GetNewInterlineSpacing} 
gets the new inter-line spacing for the style. 


\bold{Usage.}  This method is used for writing out the attribute specification 
for a style. 

}
\begindata{bp,538928392}
\enddata{bp,538928392}
\view{bpv,538928392,439,0,0}
\subsection{Working with fonts}


\paragraph{Setting the font family}\indexi{Style++Font family}


\example{void style_SetFontFamily(style,NewFont)

struct style *style;

char *NewFont;}\indexi{ \italic{style_SetFontFamily}}


\leftindent{\bold{Method description.  }  \italic{style_SetFontFamily} sets a 
new font family for a style. 


\bold{Usage.}  NewFont indicates the family name of the new font to be used. 


Possible font families include:  Andy, AndySans, AndyType, etc. 

}

\paragraph{Getting the font family}


\example{void style_GetFontFamily(style,FontName, bufsize)

struct style *style;

char *FontName;

int bufsize;}\indexi{ \italic{style_GetFontFamily}}


\leftindent{\bold{Method description.  }  \italic{style_GetFontFamily} gets 
the font family for the style. 


\bold{Usage.}  This method is used for writing out the attribute specification 
for a style. 

}

\paragraph{Setting the font size}\indexi{Style++Font size}


\example{void style_SetFontSize(style,Basis,Operand)

struct style *style;

enum style_FontSize Basis;

long Operand; }\indexi{ \italic{style_SetFontSize}}


\leftindent{\bold{Method description.  }  \italic{style_SetFontSize} sets the 
font size for a style. 


\bold{Usage.}  The basis value indicates the reference point from which 
measurement should begin (where style_ConstantFontSize indicates an absolute 
value).  The operand value is the actual numeric specification. 


Possible basis values are:  style_PreviousFontSize, style_ConstantFontSize. 


}

\paragraph{Getting the font size}


\example{void style_GetFontSize(style,RefBasis,RefOperand)

struct style *style;

enum style_FontSize *RefBasis;

long *RefOperand;}\indexi{ \italic{style_GetFontSize}}


\leftindent{\bold{Method description.  }  \italic{style_GetFontSize} gets the 
font size for the style


\bold{Usage.}  This method is used for writing out the attribute specification 
for a style. 


}

\paragraph{Setting the font script}\indexi{Style++Font script}


\example{void style_SetFontScript(style,Basis,Operand,Unit)

struct style *style;

enum style_ScriptMovement Basis;

long Operand;

enum style_Unit Unit;}\indexi{ \italic{style_SetFontScript}}


\leftindent{\bold{Method description.  }  \italic{style_SetFontScript} sets a 
new font script for the font family of the style.  It is used to set 
superscripts and subscripts in text. 


\bold{Usage.}  The basis value indicates the reference point from which 
measurement should begin (where style_ConstantScriptMovement indicates an 
absolute value).  The operand value is the actual numeric specification.  The 
unit value indicates the unit used in specifying the operand. 


Possible basis values are:  style_PreviousScriptMovement, 
style_ConstantScriptMovement. 


Possible unit values are:  style_Inches, style_CM, style_Points, style_Ems, 
style_Lines,style_RawDot. 


}

\paragraph{Getting the font script}


\example{void style_GetFontScript(style,RefBasis,RefOperand,RefUnit)

struct style *style;

enum style_ScriptMovement *RefBasis;

long *RefOperand;

enum style_Unit *RefUnit;}\indexi{ \italic{style_GetFontScript}}


\leftindent{\bold{Method description.  }  \italic{style_GetFontScript} gets 
the font script for the style. 


\bold{Usage.}  This method is used for writing out the attribute specification 
for a style. 

}

\begindata{bp,538927624}
\enddata{bp,538927624}
\view{bpv,538927624,440,0,0}
\subsection{Working with tabs}\indexi{Style++Tabs}


All tabs are currently fixed at 8 characters. 


\paragraph{Clearing tabs}


\example{void style_ClearTabChanges(style)

struct style *style;}\indexi{ \italic{style_ClearTabChanges}}


\leftindent{\bold{Method description.  }  \italic{style_ClearTabChanges} 
clears all tabs from a style. 

}

\paragraph{Adding a tab}


\example{void style_AddTabChange(style,TabOp,Where,Unit)

struct style *style;

enum style_TabAlignment TabOp;

long Where;

enum style_Unit Unit;}\indexi{ \italic{style_AddTabChange}}


\leftindent{\bold{Method description.  }  \italic{style_AddTabChange} adds a 
tab to a style. 


}
\paragraph{Getting the tab change list}


\example{void style_GetTabChangeList(style,RefNumTabChanges,Where,

Unit)

struct style *style;

long *RefNumTabChanges;

long Where;

enum style_Unit Unit;}\indexi{ \italic{style_GetTabChangeList}}


\leftindent{\bold{Method description.  }  \italic{style_GetTabChangeList} gets 
a list of the tab changes for a style. 

}
\begindata{bp,538927560}
\enddata{bp,538927560}
\view{bpv,538927560,441,0,0}
\subsection{Working with arbitrary attributes}\indexi{Style++Arbritrary 
attributes}


\paragraph{Adding a new attribute}


\example{void style_AddAttribute(style,NewAttributeName,

NewAttributeValue)

struct style *style;

char *NewAttributeName;

char *New AttributeValue;

}
\leftindent{\bold{Method description.  }  \italic{style_AddAttribute} adds a 
new attribute to the environment state vector. 


}\paragraph{Removing an attribute}


\example{void style_RemoveAttribute(style,OldAttributeName)

struct style *style;

char *OldAttributeName;

}
\leftindent{\bold{Method description.  }  \italic{style_RemoveAttribute} 
removes an attribute from the environment state vector. 

}
\paragraph{Getting an attribute}


\example{char *style_GetAttribute(style,OldAttributeName)

struct style *style;

char *OldAttributeName;

}\indexi{ \italic{style_GetAttribute}} 

\leftindent{\bold{Method description.  }  \italic{style_GetAttribute} gets the 
value of an attribute. 

}

\paragraph{Checking for the existence of an attribute}


\example{boolean style_IsAttribute(style,TestAttributeName)

struct style *style;

char *TestAttributeName;

}\indexi{ \italic{style_IsAttribute}} 

\leftindent{\bold{Method description.  }  \italic{style_IsAttribute} checks to 
see whether an attribute exists. 

}

\begindata{bp,538927496}
\enddata{bp,538927496}
\view{bpv,538927496,442,0,0}
\subsection{Working with font faces}\indexi{Style++Font faces}


\paragraph{Clearing added font faces}


\example{style_ClearNewFontFaces(style)

struct style *style;

}\indexi{ \italic{style_ClearNewFontFaces}} 

\leftindent{\bold{Macro method description. 
 }  \italic{style_ClearNewFontFaces} sets the AddFontFaces byte to 
fontdesc_Plain. 


\bold{Usage.}  Called to clear out any font faces that had been added. 


}
\paragraph{Marking a font face for addition}


\example{style_AddNewFontFace(style, NewFace)

struct style *style;

int NewFace;

}\indexi{ \italic{style_AddNewFontFace}} 

\leftindent{\bold{Macro method description.  }\italic{style_AddNewFontFace} 
or's the new font face with the AddFontFaces byte. 


\bold{Usage.}  Called to add a font face to the AddFontFaces byte. 


Possible font face values are:  fontdesc_Plain, fontdesc_Bold, 
fontdesc_Italic, (fontdesc_Shadow), fontdesc_Fixed,(fontdesc_Outline), 
(fontdesc_Thin), (fontdesc_Black), (fontdesc_Medium),(fontdesc_Heavy), 
(fontdesc_Condense). 


\{Note:  font face values in parentheses are currently unimplemented.\}


}

\paragraph{Clearing removed font faces}


\example{style_ClearOldFontFaces(style)

struct style *style;

}\indexi{ \italic{style_ClearOldFontFaces}} 

\leftindent{\bold{Macro method description. 
 }  \italic{style_ClearOldFontFaces} sets the OutFontFaces byte ~ 
fontdesc_Plain. 


\bold{Usage.}  Called to clear out any font faces that had been removed. 

}
\begindata{bp,538927432}
\enddata{bp,538927432}
\view{bpv,538927432,443,0,0}
\paragraph{Marking a font face for removal}


\example{style_RemoveOldFontFaces(style, OldFace)

struct style *style;

int OldFace;

}\indexi{ \italic{style_RemoveOldFontFaces}} 

\leftindent{\bold{Macro method description.  }  \italic{style_AddOldFontFaces} 
and's the inverse of the old font face with OutFontFaces byte. 


\bold{Usage.}  Called to add a font face to the OutFontFaces byte. 


Possible font face values are:  fontdesc_Plain, fontdesc_Bold, 
fontdesc_Italic, (fontdesc_Shadow), fontdesc_Fixed,(fontdesc_Outline), 
(fontdesc_Thin), (fontdesc_Black), (fontdesc_Medium),(fontdesc_Heavy), 
(fontdesc_Condense). 


\{Note:  font face values in parentheses are currently unimplemented.\}


}

\paragraph{Getting all of the added font faces}


\example{style_GetAddedFontFaces(style)

struct style *style;

}\indexi{ \italic{style_GetAddedFontFace}} 

\leftindent{\bold{Macro method description.}  Gets all of the added font 
faces.} 



\paragraph{Getting all of the removed font faces}


\example{style_GetRemovedFontFaces(style)

struct style *style;

}\indexi{ \italic{style_GetRemovedFontFaces}} 

\bold{\leftindent{Macro method description.  }}Gets all of the removed font 
faces. 



\paragraph{Checking which font faces have been added}


\example{style_IsAllAddedFontFace(style,TestFace)

struct style *style;

long TestFace;

}\indexi{ \italic{style_IsAllAddedFontFace}} 

\leftindent{\bold{Macro method description.}   Checks which font faces have 
been added by checking for an exact match. 

}


\paragraph{Checking which font faces have been removed}


\example{style_IsAllRemovedFontFace(style,TestFace)

struct style *style;

long TestFace;

}\indexi{ \italic{style_IsAllRemovedFontFace}} 

\leftindent{\bold{Macro method description.}   Checks which font faces have 
been removed by checking for an exact match. 

}

\begindata{bp,538927368}
\enddata{bp,538927368}
\view{bpv,538927368,444,0,0}
\paragraph{Checking whether any font faces have been added}


\example{style_IsAnyAddedFontFace(style,TestFace)

struct style *style;

long TestFace;

}\indexi{ \italic{style_IsAnyAddedFontFace}} 

\leftindent{\bold{Macro method description.}  Checks whether any font faces 
have been added. 

}

\paragraph{Checking whether any font faces have been removed}


\example{style_IsAnyRemovedFontFace(style,TestFace)

struct style *style;

long TestFace;

}\indexi{ \italic{style_IsAnyRemovedFontFace}} 

\leftindent{\bold{Macro method description.}  Checks if any font faces have 
been removed.} 


\subsection{Working with justifications}\indexi{Style++Justification}


\paragraph{Setting the justification}


\example{style_SetJustification(style,Justification)

struct style *style;

enum style_Justification Justification;

}\indexi{ \italic{style_SetJustification}} 

\leftindent{\bold{Macro method description.  }Sets the justification. 


Possible values for the justification are:  style_PreviousJustification, 
style_LeftJustified, style_RightJustified, style_Centered, 
style_LeftAndRightJustified, style_LeftThenRightJustified. 

}

\paragraph{Getting the justification}


\example{style_GetJustification(style)

struct style *style;

}\indexi{ \italic{style_GetJustification}} 

\leftindent{\bold{Macro method description.}  Gets the justification. 

}





\begindata{bp,537558784}
\enddata{bp,537558784}
\view{bpv,537558784,446,0,0}
Copyright 1992 Carnegie Mellon University and IBM.  All rights reserved.

\smaller{\smaller{$Disclaimer: 

Permission to use, copy, modify, and distribute this software and its 

documentation for any purpose is hereby granted without fee, 

provided that the above copyright notice appear in all copies and that 

both that copyright notice, this permission notice, and the following 

disclaimer appear in supporting documentation, and that the names of 

IBM, Carnegie Mellon University, and other copyright holders, not be 

used in advertising or publicity pertaining to distribution of the software 

without specific, written prior permission.



IBM, CARNEGIE MELLON UNIVERSITY, AND THE OTHER COPYRIGHT HOLDERS 

DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING 

ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.  IN NO EVENT 

SHALL IBM, CARNEGIE MELLON UNIVERSITY, OR ANY OTHER COPYRIGHT HOLDER 

BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY 

DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, 

WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS 

ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 

OF THIS SOFTWARE.

 $

}}\enddata{text,538492872}
