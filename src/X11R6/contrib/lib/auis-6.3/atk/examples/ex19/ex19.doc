\begindata{text,539029164}
\textdsversion{12}
\template{default}
\define{global
}
\define{itemize
}
\smaller{\indent{Copyright 1989 Nathaniel S. Borenstein

Permission to use, copy, modify, and distribute this software and its

documentation for any purpose and without fee is hereby granted,

provided that the above copyright notice appear in all copies and

that both that copyright notice and this permission notice appear in

supporting documentation, and that the name of 

Nathaniel S. Borenstein not be used in

advertising or publicity pertaining to distribution of the software

without specific, written prior permission. 


Nathaniel S. Borenstein DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, 
INCLUDING ALL

IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL

Nathaniel S. Borenstein BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY

DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER

IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING

OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

}}
\formatnote{\chapter{Example 19: Changing cursors}} \indexi{Cursors}


This example modifies the helloworld program to display different types of 
cursors for different functions or panels.  


The discussion that follows presents a step-by-step description of how to 
modify the \italic{helloworld} class in Example 18 to produce Example 19.  If 
you were to follow the steps, you would produce a program, called 
\italic{helloworldapp}, in seven files: 


\itemize{
a hello.ch file -- will contain the class definition for the 
\italic{helloworld }data object.  This will be exactly the same as in Example 
18. 


a hello.c file -- will contain statements that import Andrew Toolkit classes 
used by the data object, initialize the class, and define the Read and Write 
methods.  This will be exactly the same as in Example 18. 


a hellov.ch file -- will contain the class definition for the 
\italic{helloworld} view.  We will add three cursor holders to the data:  an 
idleCursor, a placeCursor, and a dragCursor. 


a hellov.c file -- will contain statements that import Andrew Toolkit classes 
used by the view and definitions of the methods.  We will add statements to 
create three new types of cursors, and post or retract them as necessary. 

 

a helloa.ch file -- will contain the class definition for the application 
program that will display an instance of the class in a window.  This will be 
exactly the same as in Example 18. 


a helloa.c -- will contain declarations needed by the Andrew Toolkit linking 
and loading facilities as well the definition of the \italic{helloworldview} 
application method.  This will be exactly the same as in Example 18. 


Makefile -- will contain the directions for compiling, linking and loading. 
 This will be exactly the same as in Example 18. 

}

For a complete listing of these files, see \italic{Program listing for Example 
19 } at the end of this section on p. 
\begindata{textref,539236104}
\textdsversion{12}
# ExNineteenListing\
\enddata{textref,539236104}
\view{textrefv,539236104,938,0,0}. The source code is available in the 
directory /usr/andrew/examples/ex19, together with the compiled program. 


Although the discussion refers directly to this example, the information 
applies generally to the creating of any application that has multiple cursor 
types. 

\begindata{bp,538928968}
\enddata{bp,538928968}
\view{bpv,538928968,939,0,0}
\section{Running the example program}


\formatnote{\bold{Action 1.}   \formatnote{To run the program, at the 
\bold{command }prompt type


runapp /usr/andrew/examples/ex19/helloa


and press the Enter key.

}

\bold{Response.}\formatnote{   }The program will produce two windows each with 
two panels as in the previous example.  The mouse cursor, however, will appear 
as a large X in the left panel (the one with the child text view), and as a 
curved arrow in the right panel (the text view).  (The cursor will appear as 
the double arrow in the scroll bars as before).


\bold{Action 2.} \formatnote{   }Click in the left panel with the left mouse 
button.


\bold{Response. } \formatnote{   }The cursor will change briefly into a left 
angle bracket cursor before the child view moves to that location.


\bold{Action 3.}\formatnote{   }Click in the left panel with the right mouse 
button, and drag the child text view object.


\bold{Response. }\formatnote{   }The cursor will appear as a black octagon 
while you drag the child view.


\bold{Action 4.}\formatnote{   }Click in the right panel with either the right 
or left mouse button.


\bold{Response.} \formatnote{   }The cursor will appear as the curved arrow, 
and the text caret will also appear at the end of \bold{Hello} \italic{world}!


\bold{Action 5.}\formatnote{   }To quit the program choose Quit from the menu 
cards.


\bold{Response.} \formatnote{   }The program will disappear from the screen.

}\
\begindata{bp,538928712}
\enddata{bp,538928712}
\view{bpv,538928712,940,0,0}
\section{An overview of cursors}


There are three basic types of cursors:  \italic{window cursors}, which 
are\indexi{Window cursors} cursors that are assigned to an entire window, 
\italic{view cursors}, \indexi{View cursors} which are assigned to views and 
sub-rectangles thereof , and \italic{process cursors}, \indexi{Process cursors} 
which are displayed in all windows associated with a process.  A mouse cursor 
that is constant in an entire window would be a window cursor, and cursors 
that change shape depending on its position in the window would be view 
cursor. Cursors not associated with a particular view may \italic{only} be 
used as window or process cursors; a view cursor is bound to its view. Process 
cursors override all other cursors. Window cursors override view cursors. 


Only one window cursor and one process cursor is allowed per window. 
 \indexi{Cursors++Parent}

Views that use either of these kinds of cursors should make sure to unset them 
when their input focus is lost.  Parent views should call 
\italic{view_RetractViewCursors} on their children before calling their 
child's \italic{FullUpdate} routine, but view cursors are automatically 
retracted (but not destroyed) during a \italic{FullUpdate}. \indexi{Full 
Update} It is up to the view's FullUpdate method to repost view cursors if 
necessary.  If a cursor \indexi{Cursors++Destroying}

is destroyed, however, then it is automatically retracted, and a call to a 
retract method is not necessary.  When cursors are created, they are posted up 
to the interaction manager which keeps a list of the cursors.  


Process cursors are set by the interaction manager with a call to

\indexi{Cursors++Posting} 

\italic{im_SetProcessCursor}, window cursors are posted by a call to 
\italic{im_SetWindowCursor}, and view cursors are posted with a call to 
\italic{view_PostCursor}.  Cursor posts are time dependent, and the last post 
made will always have precedence over previous posts.  However, reposting an 
already posted cursor will not affect it's precedence. To give a reposted 
cursor priority over other cursors, you  first call \italic{view_RetractCursor} 
 to take the cursor out completely, then repost it. 
 \indexi{Cursors++Retracting}


If a posted cursor requests a rectangle that completely obscures a previously 
posted cursor, the previous cursor is \italic{not} automatically retracted. 
 Thus, a post followed by a retraction will leave the cursors in the same 
original state.  Posts and retractions filter up the tree, so it is possible 
for parents to filter their children's posts.  Cursor posts made when the 
window or process cursor is already set are noted but not activated until the 
window or process cursor is unset. 


\subsection{Creating cursors} \indexi{Cursors++Creating}


\example{cursor_Create (view) struct view *view;} 


\italic{cursor_Create} creates a new cursor associated with \italic{view}, and 
returns a pointer to the newly created instance of the cursor.  You would call 
this procedure to create the cursor, and use the methods below to set its 
shape, then use one of \italic{im_SetProcessCursor}, 
\italic{im_SetWindowCursor}, or \italic{view_PostCursor} to post it. 

\indexi{ \italic{cursor_Create}}  

\indexi{ \italic{im_SetWindowCursor}} \indexi{ \italic{view_PostCursor}}


The following cursors are currently supported under WM and X window managers. 
 \indexi{Cursors++Types}


\leftindent{Cursor_Arrow

Cursor_Gunsight 

Cursor_Cross 

Cursor_Wait 

Cursor_HorizontalBars  

Cursor_LowerRightCorner 

Cursor_UpperLeftCorner 

Cursor_VerticalBars 

Cursor_DangerousBend 

Cursor_Caret 

Cursor_VerticalArrows 

Cursor_HorizontalArrows 

Cursor_Octagon 

Cursor_LeftPointer

Cursor_RightPointer

Cursor_CrossHairs

Cursor_DownPointer

Cursor_UpPointer

Cursor_Cutter

Cursor_LargeUpArrow

Cursor_LargeDownArrow

Cursor_EnclosedDot

Cursor_SmallCross

Cursor_SmallLeftPointer

Cursor_SmallRightPointer

}

The following sections will show how to modify the cursors in Example 18 to 
appear as the three different types of cursors (large X, angle bracket, black 
octagon) that appear in this example. 




\section{Modifying the class definition}


\subsection{Defining the view}

\indexi{Views++Defining} 


\formatnote{
#include "rect.h"


class helloworldview[hellov]: view \{

overrides:

    SetDataObject(struct helloworld *hw);

    FullUpdate(enum view_UpdateType type, long left, long top, long width, 
long height);

    Update();

    Hit (enum view_MouseAction action, long x, long y, long numberOfClicks) 
returns struct view *;

    ReceiveInputFocus();

    LoseInputFocus();

    GetInterface(int type) returns char *;

    GetApplicationLayer() returns struct view *;

    DeleteApplicationLayer(struct view *);

    LinkTree(struct view *parent);

    ObservedChanged(struct helloworld *obj, long val);

classprocedures:

    InitializeClass() returns boolean;

data:

    struct keystate *keystate;

    struct menulist *menulist;

    boolean HaveDownTransition;

    boolean haveInputFocus;

    long hitX,hitY;

    int x,y;

    boolean blackOnWhite;

    boolean redrawSubView;

    long frameX, frameY;

    long newFrameX, newFrameY;

    int vrWidth,vrHeight;

    struct view *view;

    struct view *applayer;

    \bold{struct cursor *idleCursor, *placeCursor, *dragCursor;}

\};

}

In order to display different types of cursors in a view, there must exist 
data types that correspond to the different types of cursors.  In this 
example, we will implement three different types of cursors in addition to the 
default scroll bar, text, and text caret cursors that have appeared in the 
previous examples.  These new cursors will be called the idle cursor, the 
place cursor, and the drag cursor, and are added to the list of data in the 
view definition. 




\subsection{Creating the cursors for the view}  \indexi{Cursors++Creating}

\indexi{Objects++Initializing} 

\indexi{ \italic{InitializeObject}}

\formatnote{
#include "cursor.ih"


boolean helloworldview__InitializeObject(classID,hwv)

struct classheader *classID;

struct helloworldview *hwv;   

\{

    hwv->haveInputFocus=FALSE;

    hwv->HaveDownTransition=FALSE;

    hwv->keystate=keystate_Create(hwv,helloworldviewKeymap);

    hwv->menulist=menulist_DuplicateML(helloworldviewMenulist,hwv);

    hwv->newFrameX=0;

    hwv->newFrameY=0;

    hwv->view=NULL;

    hwv->applayer=NULL;

    hwv->redrawSubView=TRUE;

   \bold{  hwv->idleCursor=cursor_Create(hwv);

            cursor_SetStandard(hwv->idleCursor,Cursor_Cross);

            hwv->placeCursor=cursor_Create(hwv);

            cursor_SetStandard(hwv->placeCursor,Cursor_UpperLeftCorner);

            hwv->dragCursor=cursor_Create(hwv);

            cursor_SetStandard(hwv->dragCursor,Cursor_Octagon);}

    return TRUE;

\}

}

We create the different types of cursors in the view's InitializeObject 
definition.  In general, the initialization looks like this: 


\example{
cursorptr=cursor_Create(view) cursor_SetStandard(cursorptr, cursortype)

}

The \italic{cursor_Create} method creates a cursor, specified by a pointer to 
a cursor, for a specified view.  The \italic{cursor_SetStandard} actually maps 
the cursor that was created to one of the available cursor types.  In this 
example, all cursors are created for the helloworldview, hwv.  The cursor we 
call idleCursor is set to be a large X cursor (Cursor_Cross), the placeCursor 
is set to be an angle bracket cursor (Cursor_UpperLeftCorner), and finally the 
dragCursor is set to be a black octagon (Cursor_Octagon). 

\indexi{Cursors++Creating}  

\indexi{ \italic{cursor_Create}} 

\indexi{ \italic{cursor_SetStandard}} 

\indexi{View cursors} \indexi{Cursors++View}


The idlecursor is a \italic{view cursor} since it's shape changes depending 
upon it's position in the window -- when it is in the helloworldview, it is a 
cross, and when it is in the textview, it is an arrow.  On the other hand, the 
placeCursor and the dragCursors are window cursors and override the view 
cursor when in force. 


The mouse functions (hit or drag) associated with the window cursors are bound 
and posted to the interaction manager in a modified Hit method; the view 
cursor is posted in the Full Update. 


\subsection{Clearing cursors}

\indexi{Cursors++Clearing} 

\indexi{Objects++Finalizing} 

\indexi{Cursors++Destroying} 

\indexi{ \italic{FinalizeObject}} 

\indexi{ \italic{cursor_Destroy}}


\formatnote{
void helloworldview__FinalizeObject(classID,hwv)

struct classheader *classID;

struct helloworldview *hwv;

\{

    if(hwv->view!=NULL)\{

	view_DeleteApplicationLayer(hwv->view,hwv->applayer);

	view_Destroy(hwv->view);

    \}

    \bold{cursor_Destroy(hwv->idleCursor);

          cursor_Destroy(hwv->placeCursor);

          cursor_Destroy(hwv->dragCursor);}

\}

}

When cursors are set in a view's InitializeObject procedure, they must also be 
explicitly destroyed in the view's FinalizeObject procedure.  This is 
accomplished by a call to \italic{cursor_Destroy} for each of the cursor 
types. 



\subsection{Posting and retracting view cursors}

\indexi{View cursors++Posting} 

 \indexi{View cursors++Retracting} 

\indexi{Cursors++View} 

\indexi{ \italic{FullUpdate}}


\formatnote{
void helloworldview__FullUpdate(hwv,type,left,top,width,height)

struct helloworldview *hwv;

enum view_UpdateType type;

long left;

long top;

long width;

long height; 

\{

    struct helloworld *hw=(struct helloworld*)hwv->header.view.dataobject;

    struct rectangle myVisualRect,rec;


    helloworldview_GetVisualBounds(hwv,&myVisualRect);

    hwv->vrWidth=rectangle_Width(&myVisualRect);

    hwv->vrHeight=rectangle_Height(&myVisualRect);


    \bold{helloworldview_PostCursor(hwv,&myVisualRect,hwv->idleCursor);}


    if (hwv->newFrameX+hwv->vrWidth>TOTALSIZE)

	hwv->newFrameX=TOTALSIZE-hwv->vrWidth;

    if (hwv->newFrameY+hwv->vrHeight>TOTALSIZE)

	hwv->newFrameY=TOTALSIZE-hwv->vrHeight;


    hwv->frameX=hwv->newFrameX;

    hwv->frameY=hwv->newFrameY;


    if(hw->x==POSUNDEF)\{

	hw->x=hwv->frameX+(hwv->vrWidth-WIDTH)/2;

	hw->y=hwv->frameY+(hwv->vrHeight-HEIGHT)/2;

    \}


    hwv->x=hw->x;

    hwv->y=hw->y;

    hwv->blackOnWhite=hw->blackOnWhite;


    rectangle_SetRectSize(&rec,hwv->x-hwv->frameX-1,

	hwv->y-hwv->frameY-1,WIDTH+1,HEIGHT+1);


    helloworldview_SetTransferMode(hwv,graphic_COPY);


    if(hw->blackOnWhite)\{

	helloworldview_FillRect(hwv,&myVisualRect,

		helloworldview_WhitePattern(hwv));

	/* if on white background, draw a rectangle around it */

	helloworldview_DrawRect(hwv,&rec);

    \}else\{

	helloworldview_FillRect(hwv,&myVisualRect,

		helloworldview_BlackPattern(hwv));

	helloworldview_FillRect(hwv,&rec, 		helloworldview_WhitePattern(hwv));

    \}


    rec.top++;

    rec.left++;

    rec.width--;

    rec.height--;


    view_InsertView(hwv->applayer,hwv,&rec);

}\formatnote{ 
\bold{      helloworldview_RetractViewCursors(hwv,hwv->applayer);}


    view_FullUpdate(hwv->applayer,view_FullRedraw,0,0,WIDTH,HEIGHT);

    hwv->redrawSubView=FALSE;

\}

}
View cursors are posted and retracted (but not destroyed) in an object's Full 
Update method.  In this example, the only view cursor is the large X or cross 
cursor in helloworldview which switches to an arrow cursor in textview.  The 
view_PostCursor method is used to post view cursors.  The method takes a view, 
a rectangle in the view, and a cursor pointer.  Correspondingly, the 
view_RetractViewCursors method takes a view and a view requesting the 
retraction; the request is sent to the interaction manager to retract a 
previously posted cursor. 

\indexi{ \italic{PostCursor}}  

\indexi{ \italic{RetractViewCursors}}


Since we have created the view cursor in this example under the name 
idleCursor, we post it with the following call: 


\example{
\bold{helloworldview_PostCursor(hwv,&myVisualRect,hwv->idleCursor);} 

}

and retract it with: 


\example{
\bold{helloworldview_RetractViewCursors(hwv,hwv->applayer);} 

}


\subsection{Posting window cursors}

\indexi{Window cursors++Posting} 

\indexi{Cursors++Window} 

\indexi{ \italic{Hit}}


\formatnote{
struct view *helloworldview__Hit(hwv,action,x,y,numberOfClicks)

struct helloworldview *hwv;

enum view_MouseAction action;

long x;

long y;

long numberOfClicks;

\{

    struct helloworld *hw=(struct helloworld *)hwv->header.view.dataobject;


    if(!hwv->HaveDownTransition &&

       x>=(hwv->x-hwv->frameX) && x<(hwv->x-hwv->frameX+WIDTH) &&

	y>=(hwv->y-hwv->frameY) && y<(hwv->y-hwv->frameY+HEIGHT))

	return view_Hit(hwv->applayer,

			action,

			x-(hwv->x-hwv->frameX),

			y-(hwv->y-hwv->frameY),

			numberOfClicks);


    if(hwv->HaveDownTransition)\{

	switch(action)\{

	    case view_RightUp:

		hwv->HaveDownTransition=FALSE;

		/* fall through */

	    case view_RightMovement:

		hw->x+=x-hwv->hitX;

		hw->y+=y-hwv->hitY;

		hwv->hitX=x;

		hwv->hitY=y;

		break;

	    case view_LeftUp:

		hwv->HaveDownTransition=FALSE;

		hw->x=x+hwv->frameX;

		hw->y=y+hwv->frameY;

		break;

	    case view_LeftMovement:

		/* do nothing */

		break;

	    default:

		/* re-synchronize mouse */

		hwv->HaveDownTransition=FALSE;

	\}

}	\formatnote{if(!hwv->HaveDownTransition)

          \bold{im_SetWindowCursor(helloworldview_GetIM(hwv),NULL);

    \}


   if(!hwv->HaveDownTransition)

	switch(action)\{

	    struct cursor *activeCursor;

	    case view_RightDown:

	    case view_LeftDown:

	        if(action==view_RightDown)\{

                        hwv->hitX=x;

                        hwv->hitY=y;

	        activeCursor=hwv->dragCursor;

	           \}else

	           activeCursor=hwv->placeCursor;


	           hwv->HaveDownTransition=TRUE;

	           im_SetWindowCursor(helloworldview_GetIM(hwv),activeCursor);

                           helloworldview_WantInputFocus(hwv,hwv);

		break;

	\}}


    helloworld_NotifyObservers(hw,0);


    return (struct view *)hwv;

\}

}

Window cursors are posted via a call to \italic{im_SetWindowCursor},

\indexi{ \italic{im_SetWindowCursor}} 

which takes a pointer to an interaction manager and a pointer to a cursor.  In 
this example, we post the window cursors from within the Hit method.  First, 
we call the im_SetWindowCursor method, with the parameters 
helloworldview_GetIM(hwv)

\indexi{ \italic{GetIM}} 

and NULL.  Since window cursors are window dependent, and each window has its 
own interaction manager at the top of its view tree, the call to GetIM ensures 
that the correct interaction manager is found for the current window.  Calling 
SetWindowCursor with a NULL cursor pointer deactivates any currently set 
window cursors, and restores local (view) cursors. 


Next, we associate the two types of window cursors with the down transition of 
the mouse buttons.  If the right mouse button has been hit, then the 
dragCursor (octagon) will appear, otherwise (i.e. the left mouse button has 
been hit) the placeCursor (angle bracket) will appear.  Finally, 
SetWindowCursor is called again with a pointer to the current activeCursor 
(either dragCursor or placeCursor) so that the cursor will be posted to the 
interaction manager. 

\begindata{bp,538929032}
\enddata{bp,538929032}
\view{bpv,538929032,941,0,0}
\begindata{texttag,539315976}
\textdsversion{12}
ExNineteenListing\
\enddata{texttag,539315976}
\view{texttagv,539315976,942,0,0}
\section{Program listing for Example 19}


\formatnote{
\bold{hello.ch}


#define POSUNDEF (-1)


class helloworld[hello]: dataobject[dataobj] \{

overrides:

    Read(FILE *file,long id) returns long;

    Write(FILE *file,long writeId,int level) returns long;

classprocedures:

    InitializeObject(struct helloworld *hw) returns boolean;

    FinalizeObject(struct helloworld *hw);

data:

    long x,y;

    boolean blackOnWhite;

    struct dataobject *dobj;

\};


#define helloworld_SubObjectChanged 1 /* constant for NotifyObservers */



\bold{hello.c}


#include <stdio.h>

#include <class.h>


#include "hello.eh"


#include "dataobj.ih"

#include "text.ih"

#include "style.ih"


struct dataobject *createInitialDobj()

\{

    struct text *text=text_New();

    struct style *bold=style_New(),*italic=style_New();


    style_SetName(bold,"bold");

    style _AddNewFontFace(bold,fontdesc_Bold);


    style_SetName(italic,"italic");

    style_AddNewFontFace(italic,fontdesc_Italic);


    text_InsertCharacters(text,0,"Hello world!",sizeof("Hello world!")-1);


    text_AddStyle(text,0,5,bold);

    text_AddStyle(text,6,5,italic);


    return (struct dataobject *)text;

\}


boolean helloworld__InitializeObject(classID,hw)

struct classheader *classID;

struct helloworld *hw;   

\{

    hw->x = POSUNDEF;

    hw->y = POSUNDEF;

    hw->blackOnWhite = TRUE;

    hw->dobj=createInitialDobj();


    return TRUE;

\}


void helloworld__FinalizeObject(classID,hw)

struct classheader *classID;

struct helloworld *hw;

\{

    dataobject_Destroy(hw->dobj);

\}


long helloworld__Read(hw,file,id)

struct helloworld *hw;

FILE *file;

long id;

\{

    char buf[100],classNameBuf[100];

    long retVal,dobjObjId;


    helloworld_SetID(hw,helloworld_UniqueID(hw));


    if(fgets(buf,sizeof(buf),file)==NULL ||

       /* the %hd tells scanf that blackOnWhite is a short, not an int */

       sscanf(buf,"%d %d %hd\\n",&hw->x,&hw->y,&hw->blackOnWhite)<3 ||

       fgets(buf,sizeof(buf),file)==NULL ||

       sscanf(buf,"\\\\begindata\{%[^,],%d\}\\n",

		classNameBuf,&dobjObjId)<2)

	retVal=dataobject_PREMATUREEOF;

    else\{

	if(strcmp(classNameBuf,class_GetTypeName(hw->dobj))!=0)\{

	    /* the type of the sub-object has changed */

	    struct dataobject *oldDobj;


	    if(!class_IsTypeByName(classNameBuf,"dataobject"))

		return dataobject_BADFORMAT;


	    oldDobj=hw->dobj;

	    hw->dobj=(struct dataobject *)class_NewObject(classNameBuf);


	    helloworld_NotifyObservers

			(hw,helloworld_SubObjectChanged);


	    dataobject_Destroy(oldDobj);

	\}


	retVal=dataobject_Read(hw->dobj,file,id);

	if(retVal==dataobject_NOREADERROR)

	    if(fgets(buf,sizeof(buf),file)==NULL) /* read in the \\enddata\{...\} */

		retVal=dataobject_MISSINGENDDATAMARKER;

    \}


    return retVal;

\}


long helloworld__Write(hw,file,writeId,level)

struct helloworld *hw;

FILE *file;

long writeId;

int level;

\{

    if(writeId!=helloworld_GetWriteID(hw))\{ /* only write a given version 
once */

	helloworld_SetWriteID(hw,writeId);

	fprintf(file,"\\\\begindata\{%s,%d\}\\n",

		class_GetTypeName(hw), helloworld_UniqueID(hw));

	fprintf(file,"%d %d %d\\n",hw->x,hw->y,hw->blackOnWhite);

	dataobject_Write(hw->dobj,file,writeId,level);

	fprintf(file,"\\\\enddata\{%s,%d\}\\n",

		class_GetTypeName(hw), helloworld_UniqueID(hw));

    \}


    return helloworld_UniqueID(hw);

\}



\bold{hellov.ch}


#include "rect.h"


class helloworldview[hellov]: view \{

overrides:

    SetDataObject(struct helloworld *hw);

    FullUpdate(enum view_UpdateType type, long left, long top, long width, 
long right);

    Update();

    Hit (enum view_MouseAction action, long x, long y, long numberOfClicks) 
returns struct view *;

    ReceiveInputFocus();

    LoseInputFocus();

    GetInterface(int type) returns char *;

    GetApplicationLayer() returns struct view *;

    DeleteApplicationLayer(struct view *);

    LinkTree(struct view *parent);

    ObservedChanged(struct helloworld *obj, long val);

classprocedures:

    InitializeClass() returns boolean;

data:

    struct keystate *keystate;

    struct menulist *menulist;

    boolean HaveDownTransition;

    boolean haveInputFocus;

    long hitX,hitY;

    int x,y;

    boolean blackOnWhite;

    boolean redrawSubView;

    long frameX, frameY;

    long newFrameX, newFrameY;

    int vrWidth,vrHeight;

    struct view *view;

    struct view *applayer;

    struct cursor *idleCursor, *placeCursor, *dragCursor;

\};



\bold{hellov.c}


#include <stdio.h>

#include <class.h>


#include "hellov.eh"


#include "graphic.ih"

#include "fontdesc.ih"

#include "rect.h"

#include "point.h"

#include "keymap.ih"

#include "keystate.ih"

#include "menulist.ih"

#include "scroll.ih"

#include "bind.ih"

#include "message.ih"

#include "im.ih"

#include "observe.ih"

#include "dataobj.ih"

#include "view.ih"

#include "cursor.ih"


#include "hello.ih"


#define TOTALSIZE 1500


static void xgetinfo(), xsetframe(), ygetinfo(), ysetframe();

static long xwhat(), ywhat();


static struct scrollfns horizInterface = \{

    xgetinfo, xsetframe, NULL, xwhat

\};


static struct scrollfns vertInterface = \{

    ygetinfo, ysetframe, NULL, ywhat

\};


static struct keymap *helloworldviewKeymap;

static struct menulist *helloworldviewMenulist;


boolean helloworldview__InitializeObject(classID,hwv)

struct classheader *classID;

struct helloworldview *hwv;   

\{

    hwv->haveInputFocus=FALSE;

    hwv->HaveDownTransition=FALSE;

    hwv->keystate=keystate_Create(hwv,helloworldviewKeymap);

    hwv->menulist=menulist_DuplicateML(helloworldviewMenulist,hwv);

    hwv->newFrameX=0;

    hwv->newFrameY=0;

    hwv->view=NULL;

    hwv->applayer=NULL;

    hwv->redrawSubView=TRUE;

    hwv->idleCursor=cursor_Create(hwv);

    cursor_SetStandard(hwv->idleCursor,Cursor_Cross);

    hwv->placeCursor=cursor_Create(hwv);

    cursor_SetStandard(hwv->placeCursor,Cursor_UpperLeftCorner);

    hwv->dragCursor=cursor_Create(hwv);

    cursor_SetStandard(hwv->dragCursor,Cursor_Octagon);

    return TRUE;

\}


void helloworldview__FinalizeObject(classID,hwv)

struct classheader *classID;

struct helloworldview *hwv;

\{

    if(hwv->view!=NULL)\{

	view_DeleteApplicationLayer(hwv->view,hwv->applayer);

	view_Destroy(hwv->view);

    \}

    cursor_Destroy(hwv->idleCursor);

    cursor_Destroy(hwv->placeCursor);

    cursor_Destroy(hwv->dragCursor);

\}


void helloworldview__LinkTree(hwv,parent)

struct helloworldview *hwv;

struct view *parent;

\{

    if(hwv->applayer!=NULL)

	view_LinkTree(hwv->applayer,hwv);

    super_LinkTree(hwv,parent);

\}


static void setSubView(hwv,dobj)

struct helloworldview *hwv;

struct dataobject *dobj;

\{

    if(hwv->view!=NULL)\{

	view_UnlinkTree(hwv->applayer);

	if(hwv->view!=hwv->applayer)

	    view_DeleteApplicationLayer(hwv->view,hwv->applayer);

	view_Destroy(hwv->view);

    \}


    if(dobj!=NULL)\{

	hwv->view=(struct view *)class_NewObject(dataobject_ViewName(dobj));


	hwv->applayer=view_GetApplicationLayer(hwv->view);

	if(hwv->applayer==NULL)

	    hwv->applayer=hwv->view;


	view_SetDataObject(hwv->view,dobj);


	view_LinkTree(hwv->applayer,hwv);

    \}else

	hwv->view=hwv->applayer=NULL;


    hwv->redrawSubView=TRUE;

\}


void helloworldview__SetDataObject(hwv,hw)

struct helloworldview *hwv;

struct helloworld *hw;

\{

    hwv->x=hw->x;

    hwv->y=hw->y;

    hwv->blackOnWhite=hw->blackOnWhite;

    setSubView(hwv,hw->dobj);

    super_SetDataObject(hwv,hw);

\}


struct view *helloworldview__GetApplicationLayer(hwv)

struct helloworldview *hwv;

\{

    return (struct view *)scroll_Create(hwv,scroll_LEFT+scroll_BOTTOM);

\}


void helloworldview__DeleteApplicationLayer(hwv,scrollbar)

struct helloworldview *hwv;

struct scroll *scrollbar;

\{

    scroll_Destroy(scrollbar);

\}


void helloworldview__ObservedChanged(hwv,changed,val)

struct helloworldview *hwv;

struct helloworld *changed;

long val;

\{

    struct helloworld *hw=(struct helloworld *)hwv->header.view.dataobject;


    if(changed==hw)

	switch(val)\{

	    case helloworld_SubObjectChanged:

		setSubView(hwv,hw->dobj);

		break;

	    case observable_OBJECTDESTROYED:

		setSubView(hwv,NULL);

		break;

	\}


    super_ObservedChanged(hwv,changed,val);

\}


#define WIDTH 100

#define HEIGHT 100


void helloworldview__FullUpdate(hwv,type,left,top,width,height)

struct helloworldview *hwv;

enum view_UpdateType type;

long left;

long top;

long width;

long height; 

\{

    struct helloworld *hw=(struct helloworld *)hwv->header.view.dataobject;

    struct rectangle myVisualRect,rec;


    helloworldview_GetVisualBounds(hwv,&myVisualRect);

    hwv->vrWidth=rectangle_Width(&myVisualRect);

    hwv->vrHeight=rectangle_Height(&myVisualRect);


    helloworldview_PostCursor(hwv,&myVisualRect,hwv->idleCursor);


    if (hwv->newFrameX+hwv->vrWidth>TOTALSIZE)

	hwv->newFrameX=TOTALSIZE-hwv->vrWidth;

    if (hwv->newFrameY+hwv->vrHeight>TOTALSIZE)

	hwv->newFrameY=TOTALSIZE-hwv->vrHeight;


    hwv->frameX=hwv->newFrameX;

    hwv->frameY=hwv->newFrameY;


    if(hw->x==POSUNDEF)\{

	hw->x=hwv->frameX+(hwv->vrWidth-WIDTH)/2;

	hw->y=hwv->frameY+(hwv->vrHeight-HEIGHT)/2;

    \}


    hwv->x=hw->x;

    hwv->y=hw->y;

    hwv->blackOnWhite=hw->blackOnWhite;


    rectangle_SetRectSize(&rec,hwv->x-hwv->frameX-1,

	hwv->y-hwv->frameY-1,WIDTH+1,HEIGHT+1);


    helloworldview_SetTransferMode(hwv,graphic_COPY);


    if(hw->blackOnWhite)\{

	helloworldview_FillRect(hwv,&myVisualRect,

		helloworldview_WhitePattern(hwv));

	/* if on white background, draw a rectangle around it */

	helloworldview_DrawRect(hwv,&rec);

    \}else\{

	helloworldview_FillRect(hwv,&myVisualRect,

		helloworldview_BlackPattern(hwv));

	helloworldview_FillRect(hwv,&rec, helloworldview_WhitePattern(hwv));

    \}


    rec.top++;

    rec.left++;

    rec.width--;

    rec.height--;


    view_InsertView(hwv->applayer,hwv,&rec);

	

    /* clearing the child's cursors is bogus-- views should clear their own.

     * hopefully this convention will change some day

     */

    helloworldview_RetractViewCursors(hwv,hwv->applayer);


    view_FullUpdate(hwv->applayer,view_FullRedraw,0,0,WIDTH,HEIGHT);

    hwv->redrawSubView=FALSE;

\}


void helloworldview__Update(hwv)

struct helloworldview *hwv;

\{    

    struct helloworld *hw=(struct helloworld *)hwv->header.view.dataobject;


    helloworldview_SetTransferMode(hwv, graphic_COPY);


    if(hwv->x!=hw->x ||

       hwv->y!=hw->y ||

       hwv->frameX!=hwv->newFrameX ||

       hwv->frameY!=hwv->newFrameY ||

       hwv->blackOnWhite!=hw->blackOnWhite ||

       hwv->redrawSubView)\{

	struct rectangle rec;


	if(hwv->x!=hw->x ||

	   hwv->y!=hw->y)\{

	    static char buf[100];

	    sprintf(buf,"Hello world at (%d,%d)",hw->x,hw->y);

	    message_DisplayString(hwv,0,buf);

	\}	    


	if(hw->blackOnWhite!=hwv->blackOnWhite)\{

	    struct rectangle vr;

	    helloworldview_GetVisualBounds(hwv,&vr);

	    if(hw->blackOnWhite)

		helloworldview_FillRect(hwv,&vr,

			helloworldview_WhitePattern(hwv));

	    else

		helloworldview_FillRect(hwv,&vr,

			helloworldview_BlackPattern(hwv));

	    hwv->blackOnWhite=hw->blackOnWhite;

	\}


	/* includes 1 pixel border */

	rectangle_SetRectSize(&rec,hwv->x-hwv->frameX-1,

		hwv->y-hwv->frameY-1,WIDTH+2,HEIGHT+2);


	if(hw->blackOnWhite)

	    helloworldview_FillRect(hwv,&rec,

		helloworldview_WhitePattern(hwv));

	else

	    helloworldview_FillRect(hwv,&rec,

		helloworldview_BlackPattern(hwv));


	hwv->x=hw->x;

	hwv->y=hw->y;

  	hwv->frameX=hwv->newFrameX;

  	hwv->frameY=hwv->newFrameY;

  

	rectangle_SetRectSize(&rec,hwv->x-hwv->frameX,

		hwv->y-hwv->frameY,WIDTH,HEIGHT);

	view_InsertView(hwv->applayer,hwv,&rec);


	if(hw->blackOnWhite)

	    helloworldview_DrawRectSize(hwv,hwv->x-hwv->frameX-1,

		hwv->y-hwv->frameY-1,WIDTH+1,HEIGHT+1);


	helloworldview_RetractViewCursors(hwv,hwv->applayer);


	view_FullUpdate(hwv->applayer,view_FullRedraw,0,0,

		WIDTH,HEIGHT);

	hwv->redrawSubView=FALSE;

    \}else

	view_Update(hwv->applayer);

\}



struct view *helloworldview__Hit(hwv,action,x,y,numberOfClicks)

struct helloworldview *hwv;

enum view_MouseAction action;

long x;

long y;

long numberOfClicks;

\{

    struct helloworld *hw=(struct helloworld *)hwv->header.view.dataobject;


    if(!hwv->HaveDownTransition &&

       x>=(hwv->x-hwv->frameX) && x<(hwv->x-hwv->frameX+WIDTH) &&

	y>=(hwv->y-hwv->frameY) && y<(hwv->y-hwv->frameY+HEIGHT))

	return view_Hit(hwv->applayer,

			action,

			x-(hwv->x-hwv->frameX),

			y-(hwv->y-hwv->frameY),

			numberOfClicks);


    if(hwv->HaveDownTransition)\{

	switch(action)\{

	    case view_RightUp:

		hwv->HaveDownTransition=FALSE;

		/* fall through */

	    case view_RightMovement:

		hw->x+=x-hwv->hitX;

		hw->y+=y-hwv->hitY;

		hwv->hitX=x;

		hwv->hitY=y;

		break;

	    case view_LeftUp:

		hwv->HaveDownTransition=FALSE;

		hw->x=x+hwv->frameX;

		hw->y=y+hwv->frameY;

		break;

	    case view_LeftMovement:

		/* do nothing */

		break;

	    default:

		/* re-synchronize mouse */

		hwv->HaveDownTransition=FALSE;

	\}


	if(!hwv->HaveDownTransition)

	    im_SetWindowCursor(helloworldview_GetIM(hwv),NULL);

    \}


    if(!hwv->HaveDownTransition)

	switch(action)\{

		struct cursor *activeCursor;

	    case view_RightDown:

	    case view_LeftDown:

		if(action==view_RightDown)\{

		    hwv->hitX=x;

		    hwv->hitY=y;

		    activeCursor=hwv->dragCursor;

		\}else

		    activeCursor=hwv->placeCursor;


		hwv->HaveDownTransition=TRUE;

		im_SetWindowCursor(helloworldview_GetIM(hwv),

				activeCursor);

		helloworldview_WantInputFocus(hwv,hwv);

		break;

	\}


    helloworld_NotifyObservers(hw,0);


    return (struct view *)hwv;

\}



void helloworldview__ReceiveInputFocus(hwv)

struct helloworldview *hwv;

\{

    hwv->haveInputFocus=TRUE;

    hwv->keystate->next=NULL;

    helloworldview_PostKeyState(hwv,hwv->keystate);

    helloworldview_PostMenus(hwv,hwv->menulist);

\}



void helloworldview__LoseInputFocus(hwv)

struct helloworldview *hwv;

\{

    hwv->haveInputFocus=FALSE;

\}


static void Center(hwv,rock)

struct helloworldview *hwv;

long rock;

\{

    struct helloworld *hw=(struct helloworld *)hwv->header.view.dataobject;


    hw->x = hwv->newFrameX + hwv->vrWidth / 2;

    hw->y = hwv->newFrameY + hwv->vrHeight / 2;


    helloworld_NotifyObservers(hw,0);

\}



static void Invert(hwv, rock)

struct helloworldview *hwv;

long rock;

\{

    struct helloworld *hw=(struct helloworld *)hwv->header.view.dataobject;


    hw->blackOnWhite=!hw->blackOnWhite;

    helloworld_NotifyObservers(hw,0);

\}



static void relocate(hwv,rock)

struct helloworldview *hwv;

long rock;

\{

    struct helloworld *hw=(struct helloworld *)hwv->header.view.dataobject;

    char buf[100];

    int x,y;


    message_AskForString(hwv,0,"New location (x,y): ",NULL,buf,sizeof(buf));


    if(sscanf(buf,"%d,%d",&x,&y)!=2)

	message_DisplayString(hwv,1,"Bad format; must be: number,number");

    else\{

	hw->x=x;

	hw->y=y;


	helloworld_NotifyObservers(hw,0);

    \}

\}



static void readHW(hwv,rock)

struct helloworldview *hwv;

long rock;

\{

    char file[100], msgBuf[100];

    FILE *fp;


    message_AskForString(hwv,0,"Read file: ",NULL,file,sizeof(file));

    fp=fopen(file,"r");

    if(fp==NULL)\{

	sprintf(msgBuf,"Couldn't open %s for reading.", file);

	message_DisplayString(hwv,1,msgBuf);

    \}else\{

	char header[100];


	if(fgets(header,sizeof(header),fp)==NULL)\{

	    sprintf(msgBuf,"Premature end-of-file in %s.",file);

	    message_DisplayString(hwv,1,msgBuf);

	\}else\{

	    char name[20];

	    int id;


	    if(sscanf(header,"\\\\begindata\{%[^,],%d\}\\n",

			name,&id)!=2)\{

		sprintf(msgBuf,"%s doesn't contain a 

			valid datastream header.",file);

		message_DisplayString(hwv,1,msgBuf);

	    \}else\{

		struct helloworld *hw=

		  (struct helloworld *)hwv->header.view.dataobject;


		if(strcmp(name,class_GetTypeName(hw))!=0)\{

		    sprintf(msgBuf,"%s doesn't contain a 

				helloworld dataobject.", file);

		    message_DisplayString(hwv,1,msgBuf);

		\}else\{

		    /* FINALLY, read the object in... */

		    helloworld_Read(hw,fp,id);

		    fclose(fp);

		    helloworld_NotifyObservers(hw,0);

		\}

	    \}

	\}

    \}

\}



static void writeHW(hwv,rock)

struct helloworldview *hwv;

long rock;

\{

    char file[100], msgBuf[100];

    FILE *fp;


    message_AskForString(hwv,0,"Write file: ",NULL,file,sizeof(file));

    fp=fopen(file,"w");

    if(fp==NULL)\{

	sprintf(msgBuf,"Couldn't open %s for writing.",file);

	message_DisplayString(hwv,1,msgBuf);

    \}else\{

	struct helloworld *hw=

	  (struct helloworld *)hwv->header.view.dataobject;

	

	helloworld_Write(hw,fp,im_GetWriteID(),0);

	fclose(fp);

    \}

\}



static void changeObj(hwv,rock)

struct helloworldview *hwv;

long rock;

\{

    char objtype[100],msgbuf[100];

    struct helloworld *hw=(struct helloworld *)hwv->header.view.dataobject;

    struct dataobject *oldDobj=hw->dobj;


    message_AskForString(hwv,0,"Type of new object: 
",NULL,objtype,sizeof(objtype));


    if(!class_IsTypeByName(objtype,"dataobject"))\{

	sprintf(msgbuf,"%s is not a dataobject!",objtype);

	message_DisplayString(hwv,1,msgbuf);

	return;

    \}


    hw->dobj=(struct dataobject *)class_NewObject(objtype);

    if(hw->dobj==NULL)\{

	message_DisplayString(hwv,1,"Error creating the object!");

	hw->dobj=oldDobj;

	return;

    \}


    helloworld_NotifyObservers(hw,helloworld_SubObjectChanged);


    dataobject_Destroy(oldDobj); /* get rid of the old one */

\}


static void xgetinfo(hwv, total, seen, dot)

struct helloworldview *hwv;

struct range *total, *seen, *dot;

\{

    struct helloworld *hw=(struct helloworld *)hwv->header.view.dataobject;


    total->beg = 0;

    total->end = TOTALSIZE;

    seen->beg = hwv->frameX;

    seen->end = hwv->frameX + hwv->vrWidth;

    dot->beg = dot->end = hw->x;

\}


static void ygetinfo(hwv, total, seen, dot)

struct helloworldview *hwv;

struct range *total, *seen, *dot;

\{

    struct helloworld *hw=(struct helloworld *)hwv->header.view.dataobject;


    total->beg = 0;

    total->end = TOTALSIZE;

    seen->beg = hwv->frameY;

    seen->end = hwv->frameY + hwv->vrHeight;

    dot->beg = dot->end = hw->y;

\}


static void xsetframe(hwv, posn, cord, outof)

struct helloworldview *hwv;

int posn;

long cord, outof;

\{

    hwv->newFrameX = posn - hwv->vrWidth * cord / outof;

    if (hwv->newFrameX + hwv->vrWidth > TOTALSIZE)

	hwv->newFrameX = TOTALSIZE - hwv->vrWidth;

    else if (hwv->newFrameX < 0)

	hwv->newFrameX = 0;

    helloworldview_WantUpdate(hwv, hwv);

\}


static void ysetframe(hwv, posn, cord, outof)

struct helloworldview *hwv;

int posn;

long cord, outof;

\{

    hwv->newFrameY = posn - hwv->vrHeight * cord / outof;

    if (hwv->newFrameY + hwv->vrHeight > TOTALSIZE)

	hwv->newFrameY = TOTALSIZE - hwv->vrHeight;

    else if (hwv->newFrameY < 0)

	hwv->newFrameY = 0;

    helloworldview_WantUpdate(hwv, hwv);

\}


static long xwhat(hwv, cord, outof)

struct helloworldview *hwv;

long cord, outof;

\{

    return hwv->frameX + hwv->vrWidth * cord / outof;

\}


static long ywhat(hwv, cord, outof)

struct helloworldview *hwv;

long cord, outof;

\{

    return hwv->frameY + hwv->vrHeight * cord / outof;

\}



char *helloworldview__GetInterface(hwv, type)

struct helloworldview *hwv;

char *type;

\{

    if (strcmp(type, "scroll,vertical") == 0)

	return (char *) &vertInterface;

    else if (strcmp(type, "scroll,horizontal") == 0)

	return (char *) &horizInterface;

    else

	return NULL;

\}



static struct bind_Description helloworldviewBindings[]=\{

    \{"helloworldview-center", "\\003",0, "Hello World,Center",0,0, Center, 
"Center the helloworldview string."\},

    \{"helloworldview-invert", "\\011",0, "Hello World,Invert",0,0, Invert, 
"Invert the helloworldview string."\},

    \{"helloworldview-relocate", "\\022",0, "Hello World,Relocate",0,0, 
relocate, "Relocate the helloworld string."\},

    \{"helloworldview-read", NULL,0, "Hello World,Read",0,0, readHW, "Read in 
a new hello world."\},

    \{"helloworldview-write", NULL,0, "Hello World,Write",0,0, writeHW, "Write 
out the current hello world to a file."\},

    \{"helloworldview-change-obj",NULL,0, "Hello World,Change Object",0,0, 
changeObj, "Change the object in the square."\},

    NULL

\};


boolean helloworldview__InitializeClass(classID)

struct classheader *classID;

\{

    helloworldviewMenulist=menulist_New();

    helloworldviewKeymap=keymap_New();

    bind_BindList(helloworldviewBindings,helloworldviewKeymap, 
	helloworldviewMenulist,&helloworldview_classinfo);


    return TRUE;

\}



\bold{helloa.ch}


class helloworldapp[helloa] : application[app]\{

    overrides:

	Start() returns boolean;

\};



\bold{helloa.c}


#include <class.h>


#include "helloa.eh"


#include "dataobj.ih"

#include "view.ih"

#include "im.ih"

#include "frame.ih"

#include "lpair.ih"

#include "text.ih"

#include "textv.ih"

#include "style.ih"

#include "hello.ih"


static struct view *appLayerOrDestroy(v)

struct view *v;

\{

    if(v==NULL)

	return NULL;

    else\{

	struct view *al=view_GetApplicationLayer(v);


	if(al==NULL)\{

	    view_Destroy(v);

	    return NULL;

	\}


	return al;

    \}

\}


static boolean makeSplitWindow(dobj1,dobj2)

struct dataobject *dobj1,*dobj2;

\{

    struct view *v1,*v2;

    struct view *al1,*al2,*lpAl;

    struct frame *frame;

    struct im *im;

    struct lpair *lp;


    al1=appLayerOrDestroy(v1=(struct view 
*)class_NewObject(dataobject_ViewName(dobj1)));

    if(al1==NULL)

	return FALSE;


    al2=appLayerOrDestroy(v2=(struct view 
*)class_NewObject(dataobject_ViewName(dobj2)));

    if(al2==NULL) \{

	view_DeleteApplicationLayer(v1,al1);

    	view_Destroy(v1);

	return FALSE;

    \}


    lpAl=appLayerOrDestroy((struct view *)(lp=lpair_New()));

    if(lpAl==NULL) \{

	view_DeleteApplicationLayer(v2,al2);

    	view_Destroy(v2);

	return FALSE;

    \}


    /* this call makes a left/right split, with the given

     * percentage allocated to the left view

     */

    lpair_HSplit(lp,al1,al2,40 /* percent */,TRUE /* movable boundary */);


    frame=frame_New();

    if(frame==NULL)  \{

	lpair_DeleteApplicationLayer(lp,lpAl);

    	lpair_Destroy(lp);

	return FALSE;

    \}


    im=im_Create(NULL);

    if(im==NULL) \{

	frame_Destroy(frame);

	return FALSE;

    \}


    view_SetDataObject(v1,dobj1);

    view_SetDataObject(v2,dobj2);

    frame_SetView(frame,lpAl);

    im_SetView(im,frame);


    view_WantInputFocus(v1,v1);


    return TRUE;


\}


boolean helloworldapp__Start(hwapp)

struct helloworldapp *hwapp;

\{

    struct helloworld *hw;

    struct text *t;

    struct style *bold,*italic;


    if(!super_Start(hwapp))

	return FALSE;


    hw=helloworld_New();

    if(hw==NULL)

	return FALSE;


    t=text_New();

    if(t==NULL) \{

	helloworld_Destroy(hw);

	return FALSE;

    \}


    bold=style_New();

    if(bold==NULL) \{

	text_Destroy(t);

	return FALSE;

    \}

    style_AddNewFontFace(bold,fontdesc_Bold);


    italic=style_New();

    if(italic==NULL) \{

	style_Destroy(bold);

	return FALSE;

   \}

    style_AddNewFontFace(italic,fontdesc_Italic);


    text_InsertCharacters(t,0,"Hello world!",sizeof("Hello world!")-1);

    text_AddStyle(t,0,5,bold);

    text_AddStyle(t,6,5,italic);


    if(!makeSplitWindow((struct dataobject *)hw,(struct dataobject *)t) ||

       !makeSplitWindow((struct dataobject *)hw,(struct dataobject *)t)) \{

	style_Destroy(italic);

	return FALSE;

    \}


    return TRUE;


\}



\bold{Makefile}


SRCDIR=/usr/andrew/

INCLUDES= -I. -I$\{SRCDIR\}include/atk -I$\{SRCDIR\}include

INCLUDESRC = $\{SRCDIR\}include/atk

CC=cc

DEBUG = -g

TOOLS = $\{SRCDIR\}bin/

CFLAGS= $\{DEBUG\} $\{INCLUDES\} 

CLASSFLAGS=$\{INCLUDES\}


MAKEDO = $\{TOOLS\}makedo $\{DEBUG\} -b $\{TOOLS\} -d $\{SRCDIR\}lib 

CLASS = $\{TOOLS\}class


.SUFFIXES: .ih .eh .ch .do


.ch.ih:

	$\{CLASS\} $\{CLASSFLAGS\} $*.ch

.ch.eh:

	$\{CLASS\} $\{CLASSFLAGS\} $*.ch


.o.do:

	$\{MAKEDO\} $<



all:  helloa.do hello.do hellov.do


helloa.do: helloa.o helloa.eh

hello.do:  hello.o hello.eh

hellov.do: hellov.o hellov.eh


helloa.o: helloa.c

helloa.o: $\{INCLUDESRC\}/app.ih

helloa.o: $\{INCLUDESRC\}/atom.ih

helloa.o: $\{INCLUDESRC\}/dataobj.ih

helloa.o: $\{INCLUDESRC\}/frame.ih

helloa.o: $\{INCLUDESRC\}/graphic.ih

helloa.o: $\{INCLUDESRC\}/im.ih

helloa.o: $\{INCLUDESRC\}/lpair.ih

helloa.o: $\{INCLUDESRC\}/message.ih

helloa.o: $\{INCLUDESRC\}/namespc.ih

helloa.o: $\{INCLUDESRC\}/observe.ih

helloa.o: $\{INCLUDESRC\}/point.h

helloa.o: $\{INCLUDESRC\}/rect.h

helloa.o: $\{INCLUDESRC\}/view.ih

helloa.o: $\{SRCDIR\}include/class.h

helloa.o: hello.ih

helloa.o: hellov.ih

helloa.o: helloa.eh

helloa.eh helloa.ih: helloa.ch

helloa.eh helloa.ih: $\{INCLUDESRC\}/app.ih

hello.o: hello.c

hello.o: $\{INCLUDESRC\}/atom.ih

hello.o: $\{INCLUDESRC\}/dataobj.ih

hello.o: $\{INCLUDESRC\}/namespc.ih

hello.o: $\{INCLUDESRC\}/observe.ih

hello.o: $\{SRCDIR\}include/class.h

hello.o: hello.eh

hello.eh hello.ih: hello.ch

hello.eh hello.ih: $\{INCLUDESRC\}/atom.ih

hello.eh hello.ih: $\{INCLUDESRC\}/dataobj.ih

hello.eh hello.ih: $\{INCLUDESRC\}/namespc.ih

hello.eh hello.ih: $\{INCLUDESRC\}/observe.ih

hellov.o: hellov.c

hellov.o: $\{INCLUDESRC\}/atom.ih

hellov.o: $\{INCLUDESRC\}/bind.ih

hellov.o: $\{INCLUDESRC\}/dataobj.ih

hellov.o: $\{INCLUDESRC\}/graphic.ih

hellov.o: $\{INCLUDESRC\}/keymap.ih

hellov.o: $\{INCLUDESRC\}/keystate.ih

hellov.o: $\{INCLUDESRC\}/menulist.ih

hellov.o: $\{INCLUDESRC\}/message.ih

hellov.o: $\{INCLUDESRC\}/namespc.ih

hellov.o: $\{INCLUDESRC\}/observe.ih

hellov.o: $\{INCLUDESRC\}/point.h

hellov.o: $\{INCLUDESRC\}/rect.h

hellov.o: $\{INCLUDESRC\}/scroll.ih

hellov.o: $\{INCLUDESRC\}/view.ih

hellov.o: $\{SRCDIR\}include/class.h

hellov.o: hello.ih

hellov.o: hellov.eh

hellov.eh hellov.ih: hellov.ch

hellov.eh hellov.ih: $\{INCLUDESRC\}/graphic.ih

hellov.eh hellov.ih: $\{INCLUDESRC\}/observe.ih

hellov.eh hellov.ih: $\{INCLUDESRC\}/point.h

hellov.eh hellov.ih: $\{INCLUDESRC\}/rect.h

hellov.eh hellov.ih: $\{INCLUDESRC\}/view.ih

hellov.eh hellov.ih: $\{SRCDIR\}include/class.h



}

\begindata{bp,537558784}
\enddata{bp,537558784}
\view{bpv,537558784,944,0,0}
Copyright 1992 Carnegie Mellon University and IBM.  All rights reserved.

\smaller{\smaller{$Disclaimer: 

Permission to use, copy, modify, and distribute this software and its 

documentation for any purpose is hereby granted without fee, 

provided that the above copyright notice appear in all copies and that 

both that copyright notice, this permission notice, and the following 

disclaimer appear in supporting documentation, and that the names of 

IBM, Carnegie Mellon University, and other copyright holders, not be 

used in advertising or publicity pertaining to distribution of the software 

without specific, written prior permission.



IBM, CARNEGIE MELLON UNIVERSITY, AND THE OTHER COPYRIGHT HOLDERS 

DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING 

ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.  IN NO EVENT 

SHALL IBM, CARNEGIE MELLON UNIVERSITY, OR ANY OTHER COPYRIGHT HOLDER 

BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY 

DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, 

WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS 

ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 

OF THIS SOFTWARE.

 $

}}\enddata{text,539029164}
